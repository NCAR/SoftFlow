1,571c1,581
< ! This code is part of
< ! RRTM for GCM Applications - Parallel (RRTMGP)
< !
< ! Eli Mlawer and Robert Pincus
< ! Andre Wehe and Jennifer Delamere
< ! email:  rrtmgp@aer.com
< !
< ! Copyright 2015,  Atmospheric and Environmental Research and
< ! Regents of the University of Colorado.  All right reserved.
< !
< ! Use and duplication is permitted under the terms of the
< !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause
< !
< ! Description: Numeric calculations for gas optics. Absorption and Rayleigh optical depths, 
< !   source functions. 
< 
< module mo_gas_optics_kernels
<   use mo_rrtmgp_kind,      only: wp
<   implicit none 
<   
<   interface interpolate2D
<     module procedure interpolate2D_1, interpolate2D_all
<   end interface interpolate2D
< contains
<   ! --------------------------------------------------------------------------------------
<   subroutine gas_optical_depths_major(ncol,nlay,ngpt,nflav, &
<     gpoint_flavor,kmajor,col_mix,fmajor,&
<     jeta,tropo,jtemp,jpress, &
<     tau)
<     ! input dimensions
<     integer, intent(in) :: ncol, nlay, ngpt, nflav ! dimensions
< 
<     ! inputs from object
<     integer,  dimension(2,ngpt),  intent(in) :: gpoint_flavor
<     real(wp), dimension(:,:,:,:), intent(in) :: kmajor
<     
<     ! inputs from profile or parent function
<     real(wp), dimension(2,    nflav,ncol,nlay), intent(in) :: col_mix
<     real(wp), dimension(2,2,2,nflav,ncol,nlay), intent(in) :: fmajor
<     integer,  dimension(2,    nflav,ncol,nlay), intent(in) :: jeta
<     logical,  dimension(ncol,nlay), intent(in) :: tropo
<     integer,  dimension(ncol,nlay), intent(in) :: jtemp, jpress
< 
<     ! outputs
<     real(wp), dimension(ngpt,nlay,ncol), intent(inout) :: tau
<     ! -----------------
<     ! local variables
<     real(wp) :: tau_major ! major species optical depth
<     ! local index
<     integer :: icol, ilay, iflav, igpt, itropo
<     ! -----------------
< 
<     do ilay = 1, nlay
<       do icol = 1, ncol 
< 
<         ! itropo = 1 lower atmosphere; itropo = 2 upper atmosphere
<         itropo = merge(1,2,tropo(icol,ilay))
< 
<         ! optical depth calculation for major species
<         do igpt = 1, ngpt
<           iflav = gpoint_flavor(itropo, igpt)
<           tau_major = &
<             ! interpolation in temperature, pressure, and eta
<             interpolate3D(col_mix(:,iflav,icol,ilay), &
<                           fmajor(:,:,:,iflav,icol,ilay), kmajor(igpt,:,:,:), &
<                           jeta(:,iflav,icol,ilay), jtemp(icol,ilay),jpress(icol,ilay)+itropo)
<           tau(igpt,ilay,icol) = tau(igpt,ilay,icol) + tau_major
<         end do ! igpt
<       end do 
<     end do ! ilay
<   end subroutine gas_optical_depths_major
< 
<   ! ----------------------------------------------------------
<   ! compute water vapor continuum optical depths
<   subroutine gas_optical_depths_continuum( &
<     ncol,nlay,ngpt,ngas,nflav, &
<     flavor,gpoint_flavor,selfrefin,forrefin,stpfac, &
<     idx_h2o, play,tlay,vmr,col_gas,fminor,jeta,tropo,jtemp, &
<     tau)
<     ! input dimensions
<     integer, intent(in) :: ncol,nlay,ngpt,ngas,nflav
< 
<     ! inputs from object
<     integer,  dimension(:,:),   intent(in) :: flavor
<     integer,  dimension(:,:),   intent(in) :: gpoint_flavor
<     real(wp), dimension(:,:,:), intent(in) :: selfrefin, forrefin
<     real(wp),                   intent(in) :: stpfac
< 
<     ! inputs from profile or parent function
<     integer,                             intent(in) :: idx_h2o
<     real(wp), dimension(ncol,nlay),      intent(in) :: play, tlay
<     real(wp), dimension(ncol,nlay,ngas), intent(in) :: vmr
<     real(wp), dimension(ncol,nlay,ngas), intent(in) :: col_gas
<     real(wp), dimension(2,2,nflav,ncol,nlay), intent(in) :: fminor
<     integer,  dimension(2,  nflav,ncol,nlay), intent(in) :: jeta
<     logical,  dimension(ncol,nlay),      intent(in) :: tropo
<     integer,  dimension(ncol,nlay),      intent(in) :: jtemp
< 
<     ! outputs
<     real(wp), dimension(ngpt,nlay,ncol), intent(inout) :: tau
<     ! -----------------
<     ! local variables
<     ! factor needed for foreign continuum optical depth calculation
<     real(wp) :: forfac(ncol),  selffac(ncol) ! scaling variables for foreign and self-continuum 
<     real(wp) :: tau_for(ngpt), tau_self(ngpt)
< 
<     ! local index
<     integer :: icol, ilay, iflav, igpt, itropo
<     logical :: water_is_key(ngpt, 2) ! Continuum only contributes if water is a key species
<                                      ! Second dimension is lower/upper  
<     ! -----------------
<     do igpt = 1, ngpt
<       water_is_key(igpt, 1) = any(flavor(:, gpoint_flavor(1, igpt)) == idx_h2o)
<       water_is_key(igpt, 2) = any(flavor(:, gpoint_flavor(2, igpt)) == idx_h2o) 
<     end do     
<     
<     do ilay = 1, nlay
<       do icol = 1, ncol
<         ! foreign continuum variables
<         forfac(icol) = stpfac * play(icol,ilay)/tlay(icol,ilay) *  & 
<                        col_gas(icol,ilay,idx_h2o) / (1._wp + vmr(icol,ilay,idx_h2o))
<         ! factor that multiplies self continuum absorption coefficient
<         selffac(icol)  = vmr(icol,ilay,idx_h2o) * forfac(icol)
<       end do
<       do icol = 1, ncol
<         itropo = merge(1,2,tropo(icol,ilay)) ! itropo = 1 lower atmosphere; itropo = 2 upper atmosphere
<         do igpt = 1, ngpt
<           iflav = gpoint_flavor(itropo, igpt)
<           ! interpolation in temperature and eta
<           tau_for(igpt)  = forfac (icol) * & 
<                            interpolate2D(fminor(:,:,iflav,icol,ilay), forrefin(igpt,:,:), & 
<                                          jeta(:,iflav,icol,ilay), jtemp(icol,ilay))
<           tau_self(igpt) = selffac(icol) * & 
<                            interpolate2D(fminor(:,:,iflav,icol,ilay), selfrefin(igpt,:,:), & 
<                                          jeta(:,iflav,icol,ilay), jtemp(icol,ilay))
<         end do 
<         tau(1:ngpt,ilay,icol) = tau(1:ngpt,ilay,icol) + merge(tau_for(1:ngpt) + tau_self(1:ngpt), & 
<                                                               0._wp,                              & 
<                                                               water_is_key(1:ngpt, itropo))
<       end do 
<     end do ! ilay
<   end subroutine gas_optical_depths_continuum
< 
<   ! ----------------------------------------------------------
<   ! compute minor species optical depths
<   subroutine gas_optical_depths_minor( &
<     ncol,nlay,ngpt,ngas,nflav, & ! input dimensions
<     gpoint_flavor,band2gpt,kminor_lower,kminor_upper,kminor_activity, &
<     idx_h2o,idx_o2,idx_n2, play,tlay,col_dry,col_gas,idx_gas_list,fminor,jeta,tropo,jtemp, &
<     tau )
<     ! input dimensions
<     integer, intent(in) :: ncol,nlay,ngpt,ngas,nflav
< 
<     ! inputs from object
<     integer, dimension(:,:), intent(in) :: gpoint_flavor
<     integer, dimension(:,:), intent(in) :: band2gpt
<     real(wp), dimension(:,:,:,:), intent(in) :: kminor_lower, kminor_upper
<     integer,  dimension(:,:),     intent(in) :: kminor_activity
< 
<     ! inputs from profile or parent function
<     integer, intent(in) :: idx_h2o,idx_o2,idx_n2
<     real(wp), dimension(ncol,nlay),      intent(in) :: play, tlay
<     real(wp), dimension(ncol,nlay),      intent(in) :: col_dry
<     real(wp), dimension(ncol,nlay,ngas), intent(in) :: col_gas
<     integer, dimension(:), intent(in)               :: idx_gas_list     ! Index of minor gases to be used in gas_optics
<     real(wp), dimension(2,2,nflav,ncol,nlay), intent(in) :: fminor
<     integer,  dimension(2,  nflav,ncol,nlay), intent(in) :: jeta
<     logical,  dimension(ncol,nlay),      intent(in) :: tropo
<     integer,  dimension(ncol,nlay),      intent(in) :: jtemp
< 
<     ! outputs
<     real(wp), dimension(ngpt,nlay,ncol), intent(inout) :: tau
<     ! -----------------
<     ! local variables
<     real(wp) :: kminor, tau_minor ! minor species absorption coefficient, optical depth 
< 
<     ! local index
<     integer ::  icol, ilay, iflav, igpt, itropo, imnr, ilist, nlist
<     real(wp) :: scaling 
<     ! -----------------
<     do ilay = 1, nlay
<       do icol = 1, ncol 
<         itropo = merge(1,2,tropo(icol,ilay)) ! itropo = 1 lower atmosphere; itropo = 2 upper atmosphere
<         ! loop through the list of species/band combinations for which contributions of minor species are included
<         nlist = size(kminor_activity, dim=2)
<         do ilist = 1, nlist
<           igpt = kminor_activity(1,ilist)
<           imnr = kminor_activity(2,ilist)
<           iflav = gpoint_flavor(itropo, igpt)
< 
<           if (any (imnr .eq. idx_gas_list)) then
< 
<              ! interpolation in temperature and eta
<              if (tropo(icol,ilay)) then ! lower atmosphere
<                kminor = &
<                  interpolate2D(fminor(:,:,iflav,icol,ilay), kminor_lower(imnr,igpt,:,:), jeta(:,iflav,icol,ilay), jtemp(icol,ilay))
<              else ! upper atmosphere
<                kminor = &
<                  interpolate2D(fminor(:,:,iflav,icol,ilay), kminor_upper(imnr,igpt,:,:), jeta(:,iflav,icol,ilay), jtemp(icol,ilay))
<              end if
< 
<              scaling = col_gas(icol,ilay,imnr) ! standard treatment of minor gases
<              ! different treatment for collision-induced absorption
<              ! oxygen
<              if (imnr == idx_o2) & 
<                scaling = scaling * play(icol,ilay) / tlay(icol,ilay)
<              ! nitrogen
<              if (imnr == idx_n2) then
<                scaling = scaling * play(icol,ilay) / tlay(icol,ilay)
<                if (igpt < band2gpt(2,1)) &  ! if band == 1 then
<                 ! absorption only due to N2-N2
<                  scaling = scaling * (col_gas(icol,ilay,imnr) / (col_dry(icol,ilay) + col_gas(icol,ilay,idx_h2o))) 
<              end if 
<           
<              tau_minor = kminor * scaling
<              tau(igpt,ilay,icol) = tau(igpt,ilay,icol) + tau_minor
<           end if
< 
<         end do ! ilist
<       end do 
<     end do ! ilay
<   end subroutine gas_optical_depths_minor
< 
<   ! ----------------------------------------------------------
<   ! compute minor species optical depths
<   subroutine gas_optical_depths_rayleigh( &
<     ncol,nlay,ngpt,ngas,nflav, & ! input dimensions
<     gpoint_flavor,krayl, &
<     idx_h2o,idx_o2,idx_n2, play,tlay,col_dry,col_gas,fminor,jeta,tropo,jtemp, &
<     tau_rayleigh)
<     
<     ! input dimensions
<     integer, intent(in) :: ncol,nlay,ngpt,ngas,nflav
< 
<     ! inputs from object
<     integer, dimension(:,:), intent(in) :: gpoint_flavor
<     real(wp), dimension(:,:,:,:), intent(in) :: krayl
< 
<     ! inputs from profile or parent function
<     integer, intent(in) :: idx_h2o,idx_o2,idx_n2
<     real(wp), dimension(ncol,nlay),      intent(in) :: play, tlay
<     real(wp), dimension(ncol,nlay),      intent(in) :: col_dry
<     real(wp), dimension(ncol,nlay,ngas), intent(in) :: col_gas
<     real(wp), dimension(2,2,nflav,ncol,nlay), intent(in) :: fminor
<     integer,  dimension(2,  nflav,ncol,nlay), intent(in) :: jeta
<     logical,  dimension(ncol,nlay),      intent(in) :: tropo
<     integer,  dimension(ncol,nlay),      intent(in) :: jtemp
< 
<     ! outputs
<     real(wp), dimension(ngpt,nlay,ncol), intent(inout) :: tau_rayleigh
<     ! -----------------
<     ! local variables
<     real(wp) :: k, tau_rayl ! rayleigh scattering coefficient, optical depth 
< 
<     ! local index
<     integer :: icol, ilay, iflav, igpt, itropo, imnr, ilist, nlist
<     ! -----------------
<     do ilay = 1, nlay
<       do icol = 1, ncol
<         itropo = merge(1,2,tropo(icol,ilay)) ! itropo = 1 lower atmosphere; itropo = 2 upper atmosphere
<         do igpt = 1, ngpt
<           iflav = gpoint_flavor(itropo, igpt)
<           k = interpolate2D(fminor(:,:,iflav,icol,ilay), krayl(igpt,:,:,itropo), jeta(:,iflav,icol,ilay), jtemp(icol,ilay))
<           tau_rayleigh(igpt,ilay,icol) =  k * (col_gas(icol,ilay,idx_h2o)+col_dry(icol,ilay))
<         end do ! igpt
<       end do 
<     end do ! ilay
<   end subroutine gas_optical_depths_rayleigh
<   
<   ! ----------------------------------------------------------
<   subroutine source(ncol, nlay, ngpt, nbnd, ngas, nflav,  & 
<                     tlay, tlev, tsfc, sfc_lay,            & 
<                     fmajor, jeta, tropo, jtemp, jpress,   & 
<                     band2gpt, pfracin, temp_ref_min, totplnk_delta, totplnk, gpoint_flavor, & 
<                     sfc_src, lay_src, lev_src_inc, lev_src_dec)
<     integer,            intent(in) :: ncol, nlay, ngpt, nbnd, ngas, nflav, sfc_lay   
<     real(wp), dimension(ncol,nlay  ) :: tlay 
<     real(wp), dimension(ncol,nlay+1) :: tlev 
<     real(wp), dimension(ncol       ) :: tsfc 
<     ! Interpolation variables 
<     real(wp), dimension(2,2,2,nflav,ncol,nlay), intent(in) :: fmajor
<     integer,  dimension(2,    nflav,ncol,nlay), intent(in) :: jeta
<     logical,  dimension(            ncol,nlay), intent(in) :: tropo
<     integer,  dimension(            ncol,nlay), intent(in) :: jtemp, jpress
<     ! Table-specific
<     integer, dimension(2, nbnd),  intent(in) :: band2gpt! Starting and ending g-points of bands
<     real(wp),                     intent(in) :: temp_ref_min, totplnk_delta
<     real(wp), dimension(:,:,:,:), intent(in) :: pfracin       ! change to provide size 
<     real(wp), dimension(:,:),     intent(in) :: totplnk       ! change to provide size 
<     integer,  dimension(:,:),     intent(in) :: gpoint_flavor ! change to provide size 
< 
<     real(wp), dimension(ngpt,       ncol), intent(out) :: sfc_src 
<     real(wp), dimension(ngpt,nlay,  ncol), intent(out) :: lay_src 
<     real(wp), dimension(ngpt,nlay+1,ncol), intent(out) :: lev_src_inc, lev_src_dec
<     ! -----------------
<     ! local
<     integer  :: ilay, icol, igpt, ibnd, itropo, iflav
<     real(wp) :: pfrac(ngpt, ncol, nlay)
<     real(wp) :: planck_function(nbnd)
<     ! -----------------
< 
<     do ilay = 1, nlay
<       do icol = 1, ncol
<         ! itropo = 1 lower atmosphere; itropo = 2 upper atmosphere
<         itropo = merge(1,2,tropo(icol,ilay))
<         ! Planck fraction calculation
<         do igpt = 1, ngpt
<           iflav = gpoint_flavor(itropo, igpt)
<           pfrac(igpt,icol,ilay) = &
<             ! interpolation in temperature, pressure, and eta
<             interpolate3D((/1._wp,1._wp/), fmajor(:,:,:,iflav,icol,ilay), pfracin(igpt,:,:,:), &
<                           jeta(:,iflav,icol,ilay), jtemp(icol,ilay),jpress(icol,ilay)+itropo)
<         end do ! igpt
<       end do ! col
<     end do 
< 
<     ! compute surface source radiances for each g-point
<     do icol = 1, ncol
<       planck_function(:) = interpolate1D(tsfc(icol), temp_ref_min, totplnk_delta, totplnk)
<       do ibnd = 1, nbnd
<         sfc_src(band2gpt(1,ibnd):band2gpt(2,ibnd),icol) = &  
<                pfrac(band2gpt(1,ibnd):band2gpt(2,ibnd),icol,sfc_lay) * planck_function(ibnd) 
<       end do 
<     end do ! icol
< 
<     ! compute layer source radiances for each g-point
<     do icol = 1, ncol
<       do ilay = 1, nlay
<         planck_function(:) = interpolate1D(tlay(icol,ilay), temp_ref_min, totplnk_delta, totplnk)
<         do ibnd = 1, nbnd
<           lay_src(band2gpt(1,ibnd):band2gpt(2,ibnd),ilay,icol) = &
<                       pfrac(band2gpt(1,ibnd):band2gpt(2,ibnd),icol,ilay) * planck_function(ibnd) 
<         end do 
<       end do ! ilay
<     end do ! icol
< 
<     ! compute level Planck source function for each g-point in increasing ilay direction
<     do icol = 1, ncol
<       do ilay = 2, nlay
<         planck_function(:) = interpolate1D(tlev(icol,ilay), temp_ref_min, totplnk_delta, totplnk)
<         do ibnd = 1, nbnd
<           lev_src_inc(band2gpt(1,ibnd):band2gpt(2,ibnd),ilay,icol) = &
<                           pfrac(band2gpt(1,ibnd):band2gpt(2,ibnd),icol,ilay-1) * planck_function(ibnd) 
<           lev_src_dec(band2gpt(1,ibnd):band2gpt(2,ibnd),ilay,icol) = &
<                           pfrac(band2gpt(1,ibnd):band2gpt(2,ibnd),icol,ilay  ) * planck_function(ibnd) 
<         end do 
<       end do ! ilay
<     end do ! icol
< 
<     ! Edge cases 
<     lev_src_inc(:,1,     :) = 0 ! this value is padding
<     lev_src_dec(:,nlay+1,:) = 0 ! this value is padding
<     do icol = 1, ncol
<         ilay = 1 
<         planck_function(:) = interpolate1D(tlev(icol,ilay), temp_ref_min, totplnk_delta, totplnk)
<         do ibnd = 1, nbnd
<           lev_src_dec(band2gpt(1,ibnd):band2gpt(2,ibnd),ilay,icol) = &
<                           pfrac(band2gpt(1,ibnd):band2gpt(2,ibnd),icol,ilay) * planck_function(ibnd) 
<         end do 
<         ilay = nlay+1
<         planck_function(:) = interpolate1D(tlev(icol,ilay), temp_ref_min, totplnk_delta, totplnk)
<         do ibnd = 1, nbnd
<           lev_src_inc(band2gpt(1,ibnd):band2gpt(2,ibnd),ilay,icol) = &
<                           pfrac(band2gpt(1,ibnd):band2gpt(2,ibnd),icol,ilay-1) * planck_function(ibnd) 
<         end do         
<     end do ! icol
< 
<   end subroutine source
<   ! ----------------------------------------------------------
<   !
<   ! One dimensional interpolation -- return all values along second table dimension
<   ! 
<   pure function interpolate1D(val, offset, delta, table) result(res)
<     ! input
<     real(wp), intent(in) :: val,    & ! axis value at which to evaluate table 
<                             offset, & ! minimum of table axis
<                             delta     ! step size of table axis 
<     real(wp), dimension(:,:), & 
<               intent(in) :: table ! dimensions (axis, values)
<     ! output
<     real(wp), dimension(size(table,dim=2)) :: res 
<     
<     ! local
<     real(wp) :: val0 ! fraction index adjusted by offset and delta
<     integer :: index ! index term
<     real(wp) :: frac ! fractional term
<     ! -------------------------------------
<     val0 = (val - offset) / delta
<     frac = val0 - int(val0) ! get fractional part
<     index = min(size(table,dim=1)-1, max(1, int(val0)+1)) ! limit the index range
<     res(:) = table(index,:) + frac * (table(index+1,:) - table(index,:))
<   end function interpolate1D
<  ! ----------------------------------------------------------
<  !
<  ! interpolation in temperature and eta
<  !   First function returns all values along first axis of k (absorption coefficent) table 
<  !
<   pure function interpolate2D_all(fminor, k, jeta, jtemp) result(res)
<     real(wp), dimension(2,2),    intent(in) :: fminor ! interpolation fractions for minor species and continuum
<                                        ! index(1) : reference eta level (temperature dependent)
<                                        ! index(2) : reference temperature level
<     real(wp), dimension(:, :,:), intent(in) :: k ! (gpoint, eta, temp)
<     integer,                     intent(in) :: jtemp ! interpolation index for temperature
<     integer, dimension(2),       intent(in) :: jeta ! interpolation index for binary species parameter (eta)
<     real(wp), dimension(size(k,1))          :: res ! the result
< 
<     res(:) =  &
<       fminor(1,1) * k(:, jeta(1)  , jtemp  ) + &
<       fminor(2,1) * k(:, jeta(1)+1, jtemp  ) + &
<       fminor(1,2) * k(:, jeta(2)  , jtemp+1) + &
<       fminor(2,2) * k(:, jeta(2)+1, jtemp+1)
<   end function interpolate2D_all
<   ! ------------
<  !   This function returns a single value from a subset (in gpoint) of the k table 
<  !
<   pure function interpolate2D_1(fminor, k, jeta, jtemp) result(res)
<     real(wp), dimension(2,2), intent(in) :: fminor ! interpolation fractions for minor species and continuum
<                                        ! index(1) : reference eta level (temperature dependent)
<                                        ! index(2) : reference temperature level
<     real(wp), dimension(:,:), intent(in) :: k ! (eta, temp)
<     integer,                  intent(in) :: jtemp ! interpolation index for temperature
<     integer, dimension(2),    intent(in) :: jeta ! interpolation index for binary species parameter (eta)
<     real(wp)                             :: res ! the result
< 
<     res =  &
<       fminor(1,1) * k(jeta(1)  , jtemp  ) + &
<       fminor(2,1) * k(jeta(1)+1, jtemp  ) + &
<       fminor(1,2) * k(jeta(2)  , jtemp+1) + &
<       fminor(2,2) * k(jeta(2)+1, jtemp+1)
<   end function interpolate2D_1
< 
<   ! ----------------------------------------------------------
<   ! interpolation in temperature, pressure, and eta
<   pure function interpolate3D(scaling, fmajor, k, jeta, jtemp, jpress) result(res)
<     real(wp), dimension(2),     intent(in) :: scaling
<     real(wp), dimension(2,2,2), intent(in) :: fmajor ! interpolation fractions for major species
<                                                      ! index(1) : reference eta level (temperature dependent)
<                                                      ! index(2) : reference pressure level
<                                                      ! index(3) : reference temperature level
<     real(wp), dimension(:,:,:),  intent(in) :: k ! (eta,temp,press)
<     integer,                     intent(in) :: jpress ! interpolation index for pressure
<     integer, dimension(2),       intent(in) :: jeta ! interpolation index for binary species parameter (eta)
<     integer,                     intent(in) :: jtemp ! interpolation index for temperature
<     real(wp)                                :: res ! the result
<     ! each code block is for a different reference temperature
<     res =  &
<       scaling(1) * &
<       ( &
<         fmajor(1,1,1) * k(jeta(1)  , jpress-1, jtemp  ) + &
<         fmajor(2,1,1) * k(jeta(1)+1, jpress-1, jtemp  ) + &
<         fmajor(1,2,1) * k(jeta(1)  , jpress  , jtemp  ) + &
<         fmajor(2,2,1) * k(jeta(1)+1, jpress  , jtemp  ) &
<       ) + &
<       scaling(2) * &
<       ( &
<         fmajor(1,1,2) * k(jeta(2)  , jpress-1, jtemp+1) + &
<         fmajor(2,1,2) * k(jeta(2)+1, jpress-1, jtemp+1) + &
<         fmajor(1,2,2) * k(jeta(2)  , jpress  , jtemp+1) + &
<         fmajor(2,2,2) * k(jeta(2)+1, jpress  , jtemp+1) &
<       )
<   end function interpolate3D
< 
<   ! ----------------------------------------------------------
<   ! Compute interpolation coefficients
<   ! for calculations of major optical depths, minor optical depths,
<   ! continuum optical depths, and Planck fractions
<   subroutine interpolation(ncol,nlay,nflav,neta, &
<     flavor,press_ref_log,temp_ref,press_ref_log_delta,temp_ref_min,temp_ref_delta,press_ref_trop_log,vmr_ref,nlay_ref, &
<     play,tlay,col_gas, &
<     jtemp,fmajor,fminor,col_mix,tropo,jeta,jpress)
<     ! input dimensions
<     integer, intent(in) :: ncol,nlay,nflav,neta
< 
<     ! inputs from object
<     integer,  dimension(:,:),   intent(in) :: flavor
<     real(wp), dimension(:),     intent(in) :: press_ref_log
<     real(wp), dimension(:),     intent(in) :: temp_ref
<     real(wp), intent(in)                 :: press_ref_log_delta, & 
<                                             temp_ref_min, temp_ref_delta, & 
<                                             press_ref_trop_log
<     real(wp), dimension(:,:,:), intent(in) :: vmr_ref
<     integer,                    intent(in) :: nlay_ref
< 
<     ! inputs from profile or parent function
<     real(wp), dimension(:,:),   intent(in) :: play, tlay
<     real(wp), dimension(:,:,:), intent(in) :: col_gas
< 
<     ! outputs
<     integer,  dimension(ncol,nlay), intent(out) :: jtemp, jpress
<     logical,  dimension(ncol,nlay), intent(out) :: tropo
<     integer,  dimension(2,    nflav,ncol,nlay), intent(out) :: jeta
<     real(wp), dimension(2,    nflav,ncol,nlay), intent(out) :: col_mix
<     real(wp), dimension(2,2,2,nflav,ncol,nlay), intent(out) :: fmajor
<     real(wp), dimension(2,2,  nflav,ncol,nlay), intent(out) :: fminor
<     ! -----------------
<     ! local
<     real(wp), dimension(ncol,nlay) :: ftemp, fpress ! interpolation fraction for temperature, pressure 
<     real(wp) :: locpress ! needed to find location in pressure grid
<     real(wp) :: ratio_eta_half ! ratio of vmrs of major species that defines eta=0.5 
<                                ! for given flavor and reference temperature level
<     real(wp) :: eta, feta   ! binary_species_parameter, interpolation variable for eta
<     real(wp) :: loceta ! needed to find location in eta grid
<     ! -----------------
<     ! local indexes
<     integer :: icol, ilay, iflav, igases(2), itropo
< 
<     do ilay = 1, nlay
<       do icol = 1, ncol
<         ! index and factor for temperature interpolation
<         jtemp(icol,ilay) = int((tlay(icol,ilay) - (temp_ref_min - temp_ref_delta)) / temp_ref_delta)
<         jtemp(icol,ilay) = min(size(temp_ref) - 1, max(1, jtemp(icol,ilay))) ! limit the index range
<         ftemp(icol,ilay) = (tlay(icol,ilay) - temp_ref(jtemp(icol,ilay))) / temp_ref_delta
< 
<         ! index and factor for pressure interpolation
<         locpress = 1._wp + (log(play(icol,ilay)) - press_ref_log(1)) / press_ref_log_delta
<         jpress(icol,ilay) = min(nlay_ref-2, max(1, int(locpress)))
<         fpress(icol,ilay) = locpress - float(jpress(icol,ilay))
< 
<         ! determine if in lower or upper part of atmosphere
<         tropo(icol,ilay) = log(play(icol,ilay)) > press_ref_trop_log
< 
<         ! itropo = 1 lower atmosphere; itropo = 2 upper atmosphere
<         itropo = merge(1,2,tropo(icol,ilay))
< 
<         ! loop over implemented combinations of major species
<         do iflav = 1, nflav
<           igases(:) = flavor(:,iflav)
< 
<           ! compute interpolation fractions needed for lower reference temperature level
<           ! compute binary species parameter (eta) for flavor and temperature, and associated interpolation index and factor
<           ratio_eta_half = vmr_ref(itropo,igases(1),jtemp(icol,ilay)) / vmr_ref(itropo,igases(2),jtemp(icol,ilay))
<           col_mix(1,iflav,icol,ilay) = col_gas(icol,ilay,igases(1)) + ratio_eta_half * col_gas(icol,ilay,igases(2))
<           eta = merge(col_gas(icol,ilay,igases(1)) / col_mix(1,iflav,icol,ilay), & 
<                       0.5_wp, col_mix(1,iflav,icol,ilay) > 2._wp * tiny(col_mix))
<           loceta = eta * float(neta-1)
<           jeta(1,iflav,icol,ilay) = min(int(loceta)+1, neta-1)
<           feta = mod(loceta, 1.0_wp)
< 
<           ! compute interpolation fractions needed for minor species and continuum
<           fminor(1,1,iflav,icol,ilay) = (1._wp-feta) * (1._wp-ftemp(icol,ilay))
<           fminor(2,1,iflav,icol,ilay) =        feta  * (1._wp-ftemp(icol,ilay))
<           ! compute interpolation fractions needed for major species
<           fmajor(1,1,1,iflav,icol,ilay) = (1._wp-fpress(icol,ilay)) * fminor(1,1,iflav,icol,ilay)
<           fmajor(2,1,1,iflav,icol,ilay) = (1._wp-fpress(icol,ilay)) * fminor(2,1,iflav,icol,ilay)
<           fmajor(1,2,1,iflav,icol,ilay) =        fpress(icol,ilay)  * fminor(1,1,iflav,icol,ilay)
<           fmajor(2,2,1,iflav,icol,ilay) =        fpress(icol,ilay)  * fminor(2,1,iflav,icol,ilay)
< 
<           ! compute interpolation fractions needed for lower reference temperature level
<           ! compute binary species parameter (eta) for flavor and temperature, and associated interpolation index and factor
<           ratio_eta_half = vmr_ref(itropo,igases(1),jtemp(icol,ilay)+1) / vmr_ref(itropo,igases(2),jtemp(icol,ilay)+1)
<           col_mix(2,iflav,icol,ilay) = col_gas(icol,ilay,igases(1)) + ratio_eta_half * col_gas(icol,ilay,igases(2))
<           eta = merge(col_gas(icol,ilay,igases(1)) / col_mix(2,iflav,icol,ilay), & 
<                       0.5_wp, col_mix(2,iflav,icol,ilay) > 2._wp * tiny(col_mix))
<           loceta = eta * float(neta-1)
<           jeta(2,iflav,icol,ilay) = min(int(loceta)+1, neta-1)
<           feta = mod(loceta, 1.0_wp)
< 
<           ! compute interpolation fractions needed for minor species and continuum
<           fminor(1,2,iflav,icol,ilay) = (1._wp-feta) * ftemp(icol,ilay)
<           fminor(2,2,iflav,icol,ilay) =        feta  * ftemp(icol,ilay)
<           ! compute interpolation fractions needed for major species
<           fmajor(1,1,2,iflav,icol,ilay) = (1._wp-fpress(icol,ilay)) * fminor(1,2,iflav,icol,ilay)
<           fmajor(2,1,2,iflav,icol,ilay) = (1._wp-fpress(icol,ilay)) * fminor(2,2,iflav,icol,ilay)
<           fmajor(1,2,2,iflav,icol,ilay) =        fpress(icol,ilay)  * fminor(1,2,iflav,icol,ilay)
<           fmajor(2,2,2,iflav,icol,ilay) =        fpress(icol,ilay)  * fminor(2,2,iflav,icol,ilay)
< 
<         end do ! iflav
<       end do ! icol,ilay
<     end do 
<   end subroutine interpolation
< 
---
> !KGEN-generated Fortran source file 
>   
> !Generated at : 2017-06-01 10:39:47 
> !KGEN version : 0.7.3 
>   
> ! This code is part of
> ! RRTM for GCM Applications - Parallel (RRTMGP)
> !
> ! Eli Mlawer and Robert Pincus
> ! Andre Wehe and Jennifer Delamere
> ! email:  rrtmgp@aer.com
> !
> ! Copyright 2015,  Atmospheric and Environmental Research and
> ! Regents of the University of Colorado.  All right reserved.
> !
> ! Use and duplication is permitted under the terms of the
> !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause
> !
> ! Description: Numeric calculations for gas optics. Absorption and Rayleigh optical depths, 
> !   source functions. 
> 
> module mo_gas_optics_kernels
>     USE mo_rrtmgp_kind, ONLY: wp 
>     USE kgen_utils_mod, ONLY: kgen_dp, kgen_array_sumcheck 
>     USE tprof_mod, ONLY: tstart, tstop, tnull, tprnt 
>     IMPLICIT NONE 
>   
>   interface interpolate2D
>     module procedure interpolate2D_1, interpolate2D_all
>   end interface interpolate2D
> contains
>   ! --------------------------------------------------------------------------------------
>   subroutine gas_optical_depths_major(ncol,nlay,ngpt,nflav, &
>     gpoint_flavor,kmajor,col_mix,fmajor,&
>     jeta,tropo,jtemp,jpress, &
>     tau)
>     ! input dimensions
>     integer, intent(in) :: ncol, nlay, ngpt, nflav ! dimensions
> 
>     ! inputs from object
>     integer,  dimension(2,ngpt),  intent(in) :: gpoint_flavor
>     real(wp), dimension(:,:,:,:), intent(in) :: kmajor
>     
>     ! inputs from profile or parent function
>     real(wp), dimension(2,    nflav,ncol,nlay), intent(in) :: col_mix
>     real(wp), dimension(2,2,2,nflav,ncol,nlay), intent(in) :: fmajor
>     integer,  dimension(2,    nflav,ncol,nlay), intent(in) :: jeta
>     logical,  dimension(ncol,nlay), intent(in) :: tropo
>     integer,  dimension(ncol,nlay), intent(in) :: jtemp, jpress
> 
>     ! outputs
>     real(wp), dimension(ngpt,nlay,ncol), intent(inout) :: tau
>     ! -----------------
>     ! local variables
>     real(wp) :: tau_major ! major species optical depth
>     ! local index
>     integer :: icol, ilay, iflav, igpt, itropo
>     ! -----------------
> 
>     do ilay = 1, nlay
>       do icol = 1, ncol 
> 
>         ! itropo = 1 lower atmosphere; itropo = 2 upper atmosphere
>         itropo = merge(1,2,tropo(icol,ilay))
> 
>         ! optical depth calculation for major species
>         do igpt = 1, ngpt
>           iflav = gpoint_flavor(itropo, igpt)
>           tau_major = &
>             ! interpolation in temperature, pressure, and eta
>             interpolate3D(col_mix(:,iflav,icol,ilay), &
>                           fmajor(:,:,:,iflav,icol,ilay), kmajor(igpt,:,:,:), &
>                           jeta(:,iflav,icol,ilay), jtemp(icol,ilay),jpress(icol,ilay)+itropo)
>             ! interpolation in temperature, pressure, and eta
>           tau(igpt,ilay,icol) = tau(igpt,ilay,icol) + tau_major
>         end do ! igpt
>       end do 
>     end do ! ilay
>   end subroutine gas_optical_depths_major
> 
>   ! ----------------------------------------------------------
>   ! compute water vapor continuum optical depths
>   subroutine gas_optical_depths_continuum( &
>     ncol,nlay,ngpt,ngas,nflav, &
>     flavor,gpoint_flavor,selfrefin,forrefin,stpfac, &
>     idx_h2o, play,tlay,vmr,col_gas,fminor,jeta,tropo,jtemp, &
>     tau)
>     ! input dimensions
>     integer, intent(in) :: ncol,nlay,ngpt,ngas,nflav
> 
>     ! inputs from object
>     integer,  dimension(:,:),   intent(in) :: flavor
>     integer,  dimension(:,:),   intent(in) :: gpoint_flavor
>     real(wp), dimension(:,:,:), intent(in) :: selfrefin, forrefin
>     real(wp),                   intent(in) :: stpfac
> 
>     ! inputs from profile or parent function
>     integer,                             intent(in) :: idx_h2o
>     real(wp), dimension(ncol,nlay),      intent(in) :: play, tlay
>     real(wp), dimension(ncol,nlay,ngas), intent(in) :: vmr
>     real(wp), dimension(ncol,nlay,ngas), intent(in) :: col_gas
>     real(wp), dimension(2,2,nflav,ncol,nlay), intent(in) :: fminor
>     integer,  dimension(2,  nflav,ncol,nlay), intent(in) :: jeta
>     logical,  dimension(ncol,nlay),      intent(in) :: tropo
>     integer,  dimension(ncol,nlay),      intent(in) :: jtemp
> 
>     ! outputs
>     real(wp), dimension(ngpt,nlay,ncol), intent(inout) :: tau
>     ! -----------------
>     ! local variables
>     ! factor needed for foreign continuum optical depth calculation
>     real(wp) :: forfac(ncol),  selffac(ncol) ! scaling variables for foreign and self-continuum 
>     real(wp) :: tau_for(ngpt), tau_self(ngpt)
> 
>     ! local index
>     integer :: icol, ilay, iflav, igpt, itropo
>     logical :: water_is_key(ngpt, 2) ! Continuum only contributes if water is a key species
>                                      ! Second dimension is lower/upper  
>     ! -----------------
>     do igpt = 1, ngpt
>       water_is_key(igpt, 1) = any(flavor(:, gpoint_flavor(1, igpt)) == idx_h2o)
>       water_is_key(igpt, 2) = any(flavor(:, gpoint_flavor(2, igpt)) == idx_h2o) 
>     end do     
>     
>     do ilay = 1, nlay
>       do icol = 1, ncol
>         ! foreign continuum variables
>         forfac(icol) = stpfac * play(icol,ilay)/tlay(icol,ilay) *  & 
>                        col_gas(icol,ilay,idx_h2o) / (1._wp + vmr(icol,ilay,idx_h2o))
>         ! factor that multiplies self continuum absorption coefficient
>         selffac(icol)  = vmr(icol,ilay,idx_h2o) * forfac(icol)
>       end do
>       do icol = 1, ncol
>         itropo = merge(1,2,tropo(icol,ilay)) ! itropo = 1 lower atmosphere; itropo = 2 upper atmosphere
>         do igpt = 1, ngpt
>           iflav = gpoint_flavor(itropo, igpt)
>           ! interpolation in temperature and eta
>           tau_for(igpt)  = forfac (icol) * & 
>                            interpolate2D(fminor(:,:,iflav,icol,ilay), forrefin(igpt,:,:), & 
>                                          jeta(:,iflav,icol,ilay), jtemp(icol,ilay))
>           tau_self(igpt) = selffac(icol) * & 
>                            interpolate2D(fminor(:,:,iflav,icol,ilay), selfrefin(igpt,:,:), & 
>                                          jeta(:,iflav,icol,ilay), jtemp(icol,ilay))
>         end do 
>         tau(1:ngpt,ilay,icol) = tau(1:ngpt,ilay,icol) + merge(tau_for(1:ngpt) + tau_self(1:ngpt), & 
>                                                               0._wp,                              & 
>                                                               water_is_key(1:ngpt, itropo))
>       end do 
>     end do ! ilay
>   end subroutine gas_optical_depths_continuum
> 
>   ! ----------------------------------------------------------
>   ! compute minor species optical depths
>   subroutine gas_optical_depths_minor( &
>     ncol,nlay,ngpt,ngas,nflav, & ! input dimensions
>     gpoint_flavor,band2gpt,kminor_lower,kminor_upper,kminor_activity, &
>     idx_h2o,idx_o2,idx_n2, play,tlay,col_dry,col_gas,idx_gas_list,fminor,jeta,tropo,jtemp, &
>     tau )
>     ! input dimensions
>     integer, intent(in) :: ncol,nlay,ngpt,ngas,nflav
> 
>     ! inputs from object
>     integer, dimension(:,:), intent(in) :: gpoint_flavor
>     integer, dimension(:,:), intent(in) :: band2gpt
>     real(wp), dimension(:,:,:,:), intent(in) :: kminor_lower, kminor_upper
>     integer,  dimension(:,:),     intent(in) :: kminor_activity
> 
>     ! inputs from profile or parent function
>     integer, intent(in) :: idx_h2o,idx_o2,idx_n2
>     real(wp), dimension(ncol,nlay),      intent(in) :: play, tlay
>     real(wp), dimension(ncol,nlay),      intent(in) :: col_dry
>     real(wp), dimension(ncol,nlay,ngas), intent(in) :: col_gas
>     integer, dimension(:), intent(in)               :: idx_gas_list     ! Index of minor gases to be used in gas_optics
>     real(wp), dimension(2,2,nflav,ncol,nlay), intent(in) :: fminor
>     integer,  dimension(2,  nflav,ncol,nlay), intent(in) :: jeta
>     logical,  dimension(ncol,nlay),      intent(in) :: tropo
>     integer,  dimension(ncol,nlay),      intent(in) :: jtemp
> 
>     ! outputs
>     real(wp), dimension(ngpt,nlay,ncol), intent(inout) :: tau
>     ! -----------------
>     ! local variables
>     real(wp) :: kminor, tau_minor ! minor species absorption coefficient, optical depth 
> 
>     ! local index
>     integer ::  icol, ilay, iflav, igpt, itropo, imnr, ilist, nlist
>     real(wp) :: scaling 
>     ! -----------------
>     do ilay = 1, nlay
>       do icol = 1, ncol 
>         itropo = merge(1,2,tropo(icol,ilay)) ! itropo = 1 lower atmosphere; itropo = 2 upper atmosphere
>         ! loop through the list of species/band combinations for which contributions of minor species are included
>         nlist = size(kminor_activity, dim=2)
>         do ilist = 1, nlist
>           igpt = kminor_activity(1,ilist)
>           imnr = kminor_activity(2,ilist)
>           iflav = gpoint_flavor(itropo, igpt)
> 
>           if (any (imnr .eq. idx_gas_list)) then
> 
>              ! interpolation in temperature and eta
>              if (tropo(icol,ilay)) then ! lower atmosphere
>                kminor = &
>                  interpolate2D(fminor(:,:,iflav,icol,ilay), kminor_lower(imnr,igpt,:,:), jeta(:,iflav,icol,ilay), jtemp(icol,ilay))
>              else ! upper atmosphere
>                kminor = &
>                  interpolate2D(fminor(:,:,iflav,icol,ilay), kminor_upper(imnr,igpt,:,:), jeta(:,iflav,icol,ilay), jtemp(icol,ilay))
>              end if
> 
>              scaling = col_gas(icol,ilay,imnr) ! standard treatment of minor gases
>              ! different treatment for collision-induced absorption
>              ! oxygen
>              if (imnr == idx_o2) & 
>                scaling = scaling * play(icol,ilay) / tlay(icol,ilay)
>              ! nitrogen
>              if (imnr == idx_n2) then
>                scaling = scaling * play(icol,ilay) / tlay(icol,ilay)
>                if (igpt < band2gpt(2,1)) &  ! if band == 1 then
>                 ! absorption only due to N2-N2
>                  scaling = scaling * (col_gas(icol,ilay,imnr) / (col_dry(icol,ilay) + col_gas(icol,ilay,idx_h2o))) 
>                 ! absorption only due to N2-N2
>              end if 
>           
>              tau_minor = kminor * scaling
>              tau(igpt,ilay,icol) = tau(igpt,ilay,icol) + tau_minor
>           end if
> 
>         end do ! ilist
>       end do 
>     end do ! ilay
>   end subroutine gas_optical_depths_minor
> 
>   ! ----------------------------------------------------------
>   ! compute minor species optical depths
>   subroutine gas_optical_depths_rayleigh( &
>     ncol,nlay,ngpt,ngas,nflav, & ! input dimensions
>     gpoint_flavor,krayl, &
>     idx_h2o,idx_o2,idx_n2, play,tlay,col_dry,col_gas,fminor,jeta,tropo,jtemp, &
>     tau_rayleigh)
>     
>     ! input dimensions
>     integer, intent(in) :: ncol,nlay,ngpt,ngas,nflav
> 
>     ! inputs from object
>     integer, dimension(:,:), intent(in) :: gpoint_flavor
>     real(wp), dimension(:,:,:,:), intent(in) :: krayl
> 
>     ! inputs from profile or parent function
>     integer, intent(in) :: idx_h2o,idx_o2,idx_n2
>     real(wp), dimension(ncol,nlay),      intent(in) :: play, tlay
>     real(wp), dimension(ncol,nlay),      intent(in) :: col_dry
>     real(wp), dimension(ncol,nlay,ngas), intent(in) :: col_gas
>     real(wp), dimension(2,2,nflav,ncol,nlay), intent(in) :: fminor
>     integer,  dimension(2,  nflav,ncol,nlay), intent(in) :: jeta
>     logical,  dimension(ncol,nlay),      intent(in) :: tropo
>     integer,  dimension(ncol,nlay),      intent(in) :: jtemp
> 
>     ! outputs
>     real(wp), dimension(ngpt,nlay,ncol), intent(inout) :: tau_rayleigh
>     ! -----------------
>     ! local variables
>     real(wp) :: k, tau_rayl ! rayleigh scattering coefficient, optical depth 
> 
>     ! local index
>     integer :: icol, ilay, iflav, igpt, itropo, imnr, ilist, nlist
>     ! -----------------
>     do ilay = 1, nlay
>       do icol = 1, ncol
>         itropo = merge(1,2,tropo(icol,ilay)) ! itropo = 1 lower atmosphere; itropo = 2 upper atmosphere
>         do igpt = 1, ngpt
>           iflav = gpoint_flavor(itropo, igpt)
>           k = interpolate2D(fminor(:,:,iflav,icol,ilay), krayl(igpt,:,:,itropo), jeta(:,iflav,icol,ilay), jtemp(icol,ilay))
>           tau_rayleigh(igpt,ilay,icol) =  k * (col_gas(icol,ilay,idx_h2o)+col_dry(icol,ilay))
>         end do ! igpt
>       end do 
>     end do ! ilay
>   end subroutine gas_optical_depths_rayleigh
>   
>   ! ----------------------------------------------------------
>   subroutine source(ncol, nlay, ngpt, nbnd, ngas, nflav,  & 
>                     tlay, tlev, tsfc, sfc_lay,            & 
>                     fmajor, jeta, tropo, jtemp, jpress,   & 
>                     band2gpt, pfracin, temp_ref_min, totplnk_delta, totplnk, gpoint_flavor, & 
>                     sfc_src, lay_src, lev_src_inc, lev_src_dec)
>     integer,            intent(in) :: ncol, nlay, ngpt, nbnd, ngas, nflav, sfc_lay   
>     real(wp), dimension(ncol,nlay  ) :: tlay 
>     real(wp), dimension(ncol,nlay+1) :: tlev 
>     real(wp), dimension(ncol       ) :: tsfc 
>     ! Interpolation variables 
>     real(wp), dimension(2,2,2,nflav,ncol,nlay), intent(in) :: fmajor
>     integer,  dimension(2,    nflav,ncol,nlay), intent(in) :: jeta
>     logical,  dimension(            ncol,nlay), intent(in) :: tropo
>     integer,  dimension(            ncol,nlay), intent(in) :: jtemp, jpress
>     ! Table-specific
>     integer, dimension(2, nbnd),  intent(in) :: band2gpt! Starting and ending g-points of bands
>     real(wp),                     intent(in) :: temp_ref_min, totplnk_delta
>     real(wp), dimension(:,:,:,:), intent(in) :: pfracin       ! change to provide size 
>     real(wp), dimension(:,:),     intent(in) :: totplnk       ! change to provide size 
>     integer,  dimension(:,:),     intent(in) :: gpoint_flavor ! change to provide size 
> 
>     real(wp), dimension(ngpt,       ncol), intent(out) :: sfc_src 
>     real(wp), dimension(ngpt,nlay,  ncol), intent(out) :: lay_src 
>     real(wp), dimension(ngpt,nlay+1,ncol), intent(out) :: lev_src_inc, lev_src_dec
>     ! -----------------
>     ! local
>     integer  :: ilay, icol, igpt, ibnd, itropo, iflav
>     real(wp) :: pfrac(ngpt, ncol, nlay)
>     real(wp) :: planck_function(nbnd)
>     ! -----------------
> 
>     do ilay = 1, nlay
>       do icol = 1, ncol
>         ! itropo = 1 lower atmosphere; itropo = 2 upper atmosphere
>         itropo = merge(1,2,tropo(icol,ilay))
>         ! Planck fraction calculation
>         do igpt = 1, ngpt
>           iflav = gpoint_flavor(itropo, igpt)
>           pfrac(igpt,icol,ilay) = &
>             ! interpolation in temperature, pressure, and eta
>             interpolate3D((/1._wp,1._wp/), fmajor(:,:,:,iflav,icol,ilay), pfracin(igpt,:,:,:), &
>                           jeta(:,iflav,icol,ilay), jtemp(icol,ilay),jpress(icol,ilay)+itropo)
>             ! interpolation in temperature, pressure, and eta
>         end do ! igpt
>       end do ! col
>     end do 
> 
>     ! compute surface source radiances for each g-point
>     do icol = 1, ncol
>       planck_function(:) = interpolate1D(tsfc(icol), temp_ref_min, totplnk_delta, totplnk)
>       do ibnd = 1, nbnd
>         sfc_src(band2gpt(1,ibnd):band2gpt(2,ibnd),icol) = &  
>                pfrac(band2gpt(1,ibnd):band2gpt(2,ibnd),icol,sfc_lay) * planck_function(ibnd) 
>       end do 
>     end do ! icol
> 
>     ! compute layer source radiances for each g-point
>     do icol = 1, ncol
>       do ilay = 1, nlay
>         planck_function(:) = interpolate1D(tlay(icol,ilay), temp_ref_min, totplnk_delta, totplnk)
>         do ibnd = 1, nbnd
>           lay_src(band2gpt(1,ibnd):band2gpt(2,ibnd),ilay,icol) = &
>                       pfrac(band2gpt(1,ibnd):band2gpt(2,ibnd),icol,ilay) * planck_function(ibnd) 
>         end do 
>       end do ! ilay
>     end do ! icol
> 
>     ! compute level Planck source function for each g-point in increasing ilay direction
>     do icol = 1, ncol
>       do ilay = 2, nlay
>         planck_function(:) = interpolate1D(tlev(icol,ilay), temp_ref_min, totplnk_delta, totplnk)
>         do ibnd = 1, nbnd
>           lev_src_inc(band2gpt(1,ibnd):band2gpt(2,ibnd),ilay,icol) = &
>                           pfrac(band2gpt(1,ibnd):band2gpt(2,ibnd),icol,ilay-1) * planck_function(ibnd) 
>           lev_src_dec(band2gpt(1,ibnd):band2gpt(2,ibnd),ilay,icol) = &
>                           pfrac(band2gpt(1,ibnd):band2gpt(2,ibnd),icol,ilay  ) * planck_function(ibnd) 
>         end do 
>       end do ! ilay
>     end do ! icol
> 
>     ! Edge cases 
>     lev_src_inc(:,1,     :) = 0 ! this value is padding
>     lev_src_dec(:,nlay+1,:) = 0 ! this value is padding
>     do icol = 1, ncol
>         ilay = 1 
>         planck_function(:) = interpolate1D(tlev(icol,ilay), temp_ref_min, totplnk_delta, totplnk)
>         do ibnd = 1, nbnd
>           lev_src_dec(band2gpt(1,ibnd):band2gpt(2,ibnd),ilay,icol) = &
>                           pfrac(band2gpt(1,ibnd):band2gpt(2,ibnd),icol,ilay) * planck_function(ibnd) 
>         end do 
>         ilay = nlay+1
>         planck_function(:) = interpolate1D(tlev(icol,ilay), temp_ref_min, totplnk_delta, totplnk)
>         do ibnd = 1, nbnd
>           lev_src_inc(band2gpt(1,ibnd):band2gpt(2,ibnd),ilay,icol) = &
>                           pfrac(band2gpt(1,ibnd):band2gpt(2,ibnd),icol,ilay-1) * planck_function(ibnd) 
>         end do         
>     end do ! icol
> 
>   end subroutine source
>   ! ----------------------------------------------------------
>   !
>   ! One dimensional interpolation -- return all values along second table dimension
>   ! 
>   pure function interpolate1D(val, offset, delta, table) result(res)
>     ! input
>     real(wp), intent(in) :: val,    & ! axis value at which to evaluate table 
>                             offset, & ! minimum of table axis
>                             delta     ! step size of table axis 
>     real(wp), dimension(:,:), & 
>               intent(in) :: table ! dimensions (axis, values)
>     ! output
>     real(wp), dimension(size(table,dim=2)) :: res 
>     
>     ! local
>     real(wp) :: val0 ! fraction index adjusted by offset and delta
>     integer :: index ! index term
>     real(wp) :: frac ! fractional term
>     ! -------------------------------------
>     val0 = (val - offset) / delta
>     frac = val0 - int(val0) ! get fractional part
>     index = min(size(table,dim=1)-1, max(1, int(val0)+1)) ! limit the index range
>     res(:) = table(index,:) + frac * (table(index+1,:) - table(index,:))
>   end function interpolate1D
>  ! ----------------------------------------------------------
>  !
>  ! interpolation in temperature and eta
>  !   First function returns all values along first axis of k (absorption coefficent) table 
>  !
>   pure function interpolate2D_all(fminor, k, jeta, jtemp) result(res)
>     real(wp), dimension(2,2),    intent(in) :: fminor ! interpolation fractions for minor species and continuum
>                                        ! index(1) : reference eta level (temperature dependent)
>                                        ! index(2) : reference temperature level
>     real(wp), dimension(:, :,:), intent(in) :: k ! (gpoint, eta, temp)
>     integer,                     intent(in) :: jtemp ! interpolation index for temperature
>     integer, dimension(2),       intent(in) :: jeta ! interpolation index for binary species parameter (eta)
>     real(wp), dimension(size(k,1))          :: res ! the result
> 
>     res(:) =  &
>       fminor(1,1) * k(:, jeta(1)  , jtemp  ) + &
>       fminor(2,1) * k(:, jeta(1)+1, jtemp  ) + &
>       fminor(1,2) * k(:, jeta(2)  , jtemp+1) + &
>       fminor(2,2) * k(:, jeta(2)+1, jtemp+1)
>   end function interpolate2D_all
>   ! ------------
>  !   This function returns a single value from a subset (in gpoint) of the k table 
>  !
>   pure function interpolate2D_1(fminor, k, jeta, jtemp) result(res)
>     real(wp), dimension(2,2), intent(in) :: fminor ! interpolation fractions for minor species and continuum
>                                        ! index(1) : reference eta level (temperature dependent)
>                                        ! index(2) : reference temperature level
>     real(wp), dimension(:,:), intent(in) :: k ! (eta, temp)
>     integer,                  intent(in) :: jtemp ! interpolation index for temperature
>     integer, dimension(2),    intent(in) :: jeta ! interpolation index for binary species parameter (eta)
>     real(wp)                             :: res ! the result
> 
>     res =  &
>       fminor(1,1) * k(jeta(1)  , jtemp  ) + &
>       fminor(2,1) * k(jeta(1)+1, jtemp  ) + &
>       fminor(1,2) * k(jeta(2)  , jtemp+1) + &
>       fminor(2,2) * k(jeta(2)+1, jtemp+1)
>   end function interpolate2D_1
> 
>   ! ----------------------------------------------------------
>   ! interpolation in temperature, pressure, and eta
>   pure function interpolate3D(scaling, fmajor, k, jeta, jtemp, jpress) result(res)
>     real(wp), dimension(2),     intent(in) :: scaling
>     real(wp), dimension(2,2,2), intent(in) :: fmajor ! interpolation fractions for major species
>                                                      ! index(1) : reference eta level (temperature dependent)
>                                                      ! index(2) : reference pressure level
>                                                      ! index(3) : reference temperature level
>     real(wp), dimension(:,:,:),  intent(in) :: k ! (eta,temp,press)
>     integer,                     intent(in) :: jpress ! interpolation index for pressure
>     integer, dimension(2),       intent(in) :: jeta ! interpolation index for binary species parameter (eta)
>     integer,                     intent(in) :: jtemp ! interpolation index for temperature
>     real(wp)                                :: res ! the result
>     ! each code block is for a different reference temperature
>     res =  &
>       scaling(1) * &
>       ( &
>         fmajor(1,1,1) * k(jeta(1)  , jpress-1, jtemp  ) + &
>         fmajor(2,1,1) * k(jeta(1)+1, jpress-1, jtemp  ) + &
>         fmajor(1,2,1) * k(jeta(1)  , jpress  , jtemp  ) + &
>         fmajor(2,2,1) * k(jeta(1)+1, jpress  , jtemp  ) &
>       ) + &
>       scaling(2) * &
>       ( &
>         fmajor(1,1,2) * k(jeta(2)  , jpress-1, jtemp+1) + &
>         fmajor(2,1,2) * k(jeta(2)+1, jpress-1, jtemp+1) + &
>         fmajor(1,2,2) * k(jeta(2)  , jpress  , jtemp+1) + &
>         fmajor(2,2,2) * k(jeta(2)+1, jpress  , jtemp+1) &
>       )
>   end function interpolate3D
> 
>   ! ----------------------------------------------------------
>   ! Compute interpolation coefficients
>   ! for calculations of major optical depths, minor optical depths,
>   ! continuum optical depths, and Planck fractions
>   subroutine interpolation(ncol,nlay,nflav,neta, &
>     flavor,press_ref_log,temp_ref,press_ref_log_delta,temp_ref_min,temp_ref_delta,press_ref_trop_log,vmr_ref,nlay_ref, &
>     play,tlay,col_gas, &
>     jtemp,fmajor,fminor,col_mix,tropo,jeta,jpress)
>     ! input dimensions
>     integer, intent(in) :: ncol,nlay,nflav,neta
> 
>     ! inputs from object
>     integer,  dimension(:,:),   intent(in) :: flavor
>     real(wp), dimension(:),     intent(in) :: press_ref_log
>     real(wp), dimension(:),     intent(in) :: temp_ref
>     real(wp), intent(in)                 :: press_ref_log_delta, & 
>                                             temp_ref_min, temp_ref_delta, & 
>                                             press_ref_trop_log
>     real(wp), dimension(:,:,:), intent(in) :: vmr_ref
>     integer,                    intent(in) :: nlay_ref
> 
>     ! inputs from profile or parent function
>     real(wp), dimension(:,:),   intent(in) :: play, tlay
>     real(wp), dimension(:,:,:), intent(in) :: col_gas
> 
>     ! outputs
>     integer,  dimension(ncol,nlay), intent(out) :: jtemp, jpress
>     logical,  dimension(ncol,nlay), intent(out) :: tropo
>     integer,  dimension(2,    nflav,ncol,nlay), intent(out) :: jeta
>     real(wp), dimension(2,    nflav,ncol,nlay), intent(out) :: col_mix
>     real(wp), dimension(2,2,2,nflav,ncol,nlay), intent(out) :: fmajor
>     real(wp), dimension(2,2,  nflav,ncol,nlay), intent(out) :: fminor
>     ! -----------------
>     ! local
>     real(wp), dimension(ncol,nlay) :: ftemp, fpress ! interpolation fraction for temperature, pressure 
>     real(wp) :: locpress ! needed to find location in pressure grid
>     real(wp) :: ratio_eta_half ! ratio of vmrs of major species that defines eta=0.5 
>                                ! for given flavor and reference temperature level
>     real(wp) :: eta, feta   ! binary_species_parameter, interpolation variable for eta
>     real(wp) :: loceta ! needed to find location in eta grid
>     ! -----------------
>     ! local indexes
>     integer :: icol, ilay, iflav, igases(2), itropo
> 
>     do ilay = 1, nlay
>       do icol = 1, ncol
>         ! index and factor for temperature interpolation
>         jtemp(icol,ilay) = int((tlay(icol,ilay) - (temp_ref_min - temp_ref_delta)) / temp_ref_delta)
>         jtemp(icol,ilay) = min(size(temp_ref) - 1, max(1, jtemp(icol,ilay))) ! limit the index range
>         ftemp(icol,ilay) = (tlay(icol,ilay) - temp_ref(jtemp(icol,ilay))) / temp_ref_delta
> 
>         ! index and factor for pressure interpolation
>         locpress = 1._wp + (log(play(icol,ilay)) - press_ref_log(1)) / press_ref_log_delta
>         jpress(icol,ilay) = min(nlay_ref-2, max(1, int(locpress)))
>         fpress(icol,ilay) = locpress - float(jpress(icol,ilay))
> 
>         ! determine if in lower or upper part of atmosphere
>         tropo(icol,ilay) = log(play(icol,ilay)) > press_ref_trop_log
> 
>         ! itropo = 1 lower atmosphere; itropo = 2 upper atmosphere
>         itropo = merge(1,2,tropo(icol,ilay))
> 
>         ! loop over implemented combinations of major species
>         do iflav = 1, nflav
>           igases(:) = flavor(:,iflav)
> 
>           ! compute interpolation fractions needed for lower reference temperature level
>           ! compute binary species parameter (eta) for flavor and temperature, and associated interpolation index and factor
>           ratio_eta_half = vmr_ref(itropo,igases(1),jtemp(icol,ilay)) / vmr_ref(itropo,igases(2),jtemp(icol,ilay))
>           col_mix(1,iflav,icol,ilay) = col_gas(icol,ilay,igases(1)) + ratio_eta_half * col_gas(icol,ilay,igases(2))
>           eta = merge(col_gas(icol,ilay,igases(1)) / col_mix(1,iflav,icol,ilay), & 
>                       0.5_wp, col_mix(1,iflav,icol,ilay) > 2._wp * tiny(col_mix))
>           loceta = eta * float(neta-1)
>           jeta(1,iflav,icol,ilay) = min(int(loceta)+1, neta-1)
>           feta = mod(loceta, 1.0_wp)
> 
>           ! compute interpolation fractions needed for minor species and continuum
>           fminor(1,1,iflav,icol,ilay) = (1._wp-feta) * (1._wp-ftemp(icol,ilay))
>           fminor(2,1,iflav,icol,ilay) =        feta  * (1._wp-ftemp(icol,ilay))
>           ! compute interpolation fractions needed for major species
>           fmajor(1,1,1,iflav,icol,ilay) = (1._wp-fpress(icol,ilay)) * fminor(1,1,iflav,icol,ilay)
>           fmajor(2,1,1,iflav,icol,ilay) = (1._wp-fpress(icol,ilay)) * fminor(2,1,iflav,icol,ilay)
>           fmajor(1,2,1,iflav,icol,ilay) =        fpress(icol,ilay)  * fminor(1,1,iflav,icol,ilay)
>           fmajor(2,2,1,iflav,icol,ilay) =        fpress(icol,ilay)  * fminor(2,1,iflav,icol,ilay)
> 
>           ! compute interpolation fractions needed for lower reference temperature level
>           ! compute binary species parameter (eta) for flavor and temperature, and associated interpolation index and factor
>           ratio_eta_half = vmr_ref(itropo,igases(1),jtemp(icol,ilay)+1) / vmr_ref(itropo,igases(2),jtemp(icol,ilay)+1)
>           col_mix(2,iflav,icol,ilay) = col_gas(icol,ilay,igases(1)) + ratio_eta_half * col_gas(icol,ilay,igases(2))
>           eta = merge(col_gas(icol,ilay,igases(1)) / col_mix(2,iflav,icol,ilay), & 
>                       0.5_wp, col_mix(2,iflav,icol,ilay) > 2._wp * tiny(col_mix))
>           loceta = eta * float(neta-1)
>           jeta(2,iflav,icol,ilay) = min(int(loceta)+1, neta-1)
>           feta = mod(loceta, 1.0_wp)
> 
>           ! compute interpolation fractions needed for minor species and continuum
>           fminor(1,2,iflav,icol,ilay) = (1._wp-feta) * ftemp(icol,ilay)
>           fminor(2,2,iflav,icol,ilay) =        feta  * ftemp(icol,ilay)
>           ! compute interpolation fractions needed for major species
>           fmajor(1,1,2,iflav,icol,ilay) = (1._wp-fpress(icol,ilay)) * fminor(1,2,iflav,icol,ilay)
>           fmajor(2,1,2,iflav,icol,ilay) = (1._wp-fpress(icol,ilay)) * fminor(2,2,iflav,icol,ilay)
>           fmajor(1,2,2,iflav,icol,ilay) =        fpress(icol,ilay)  * fminor(1,2,iflav,icol,ilay)
>           fmajor(2,2,2,iflav,icol,ilay) =        fpress(icol,ilay)  * fminor(2,2,iflav,icol,ilay)
> 
>         end do ! iflav
>       end do ! icol,ilay
>     end do 
>   end subroutine interpolation
> 
1,34c1,40
< ! This code is part of
< ! RRTM for GCM Applications - Parallel (RRTMGP)
< !
< ! Eli Mlawer and Robert Pincus
< ! Andre Wehe and Jennifer Delamere
< ! email:  rrtmgp@aer.com
< !
< ! Copyright 2015,  Atmospheric and Environmental Research and
< ! Regents of the University of Colorado.  All right reserved.
< !
< ! Use and duplication is permitted under the terms of the
< !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause
< !
< 
< ! This module provides the Fortran KIND parameters for REAL and INTEGER variables. 
< !   By default we use constant from the ISO C binding and use double precision for working. 
< !   If the host model in which RRTGMP is embedded has defined these constants elsewhere 
< !   the model definitions can be used instead by renaming. For example, 
< ! use  mo_model_kind, only wp => dp, ... 
< !   where the syntax is local_name => original_name
< !   and all the local names need to be defined 
< 
< module mo_rrtmgp_kind
<   use, intrinsic :: iso_c_binding, only: c_float, c_double, c_long, c_int, c_bool
<   implicit none
<   integer, parameter :: dp = c_double, sp = c_float, i8 = c_long, i4 = c_int
<   ! Floating point working precision
< 
<   integer, parameter :: wp = dp
<   
<   ! Logical - for use with kernels
<   integer, parameter :: wl = c_bool
<   
< end module mo_rrtmgp_kind
---
> !KGEN-generated Fortran source file 
>   
> !Generated at : 2017-06-01 10:39:47 
> !KGEN version : 0.7.3 
>   
> ! This code is part of
> ! RRTM for GCM Applications - Parallel (RRTMGP)
> !
> ! Eli Mlawer and Robert Pincus
> ! Andre Wehe and Jennifer Delamere
> ! email:  rrtmgp@aer.com
> !
> ! Copyright 2015,  Atmospheric and Environmental Research and
> ! Regents of the University of Colorado.  All right reserved.
> !
> ! Use and duplication is permitted under the terms of the
> !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause
> !
> 
> ! This module provides the Fortran KIND parameters for REAL and INTEGER variables. 
> !   By default we use constant from the ISO C binding and use double precision for working. 
> !   If the host model in which RRTGMP is embedded has defined these constants elsewhere 
> !   the model definitions can be used instead by renaming. For example, 
> ! use  mo_model_kind, only wp => dp, ... 
> !   where the syntax is local_name => original_name
> !   and all the local names need to be defined 
> 
> module mo_rrtmgp_kind
>     USE, INTRINSIC :: iso_c_binding, ONLY: c_float, c_double, c_long, c_int 
>     USE kgen_utils_mod, ONLY: kgen_dp, kgen_array_sumcheck 
>     USE tprof_mod, ONLY: tstart, tstop, tnull, tprnt 
>     IMPLICIT NONE 
>   integer, parameter :: dp = c_double, sp = c_float, i8 = c_long, i4 = c_int
>   ! Floating point working precision
> 
>   integer, parameter :: wp = dp
>   
>   ! Logical - for use with kernels
>   
> end module mo_rrtmgp_kind
\ No newline at end of file
1,825c1,257
< !>
< ! Module: mo_gas_optics_specification
< 
< ! This code is part of
< ! RRTM for GCM Applications - Parallel (RRTMGP)
< !
< ! Eli Mlawer and Robert Pincus
< ! Andre Wehe and Jennifer Delamere
< ! email:  rrtmgp@aer.com
< !
< ! Copyright 2015,  Atmospheric and Environmental Research and
< ! Regents of the University of Colorado.  All right reserved.
< !
< ! Use and duplication is permitted under the terms of the
< !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause
< !
< ! Description: Reorder array indecies
< !
< 
< module mo_util_reorder
< 
<   use mo_rrtmgp_kind, only: wp
< 
<   implicit none
< 
<   ! ----- interface for 2D arrays -----
<   interface reorder12x21
<     module procedure reorder_int_12x21, reorder_wp_12x21
<   end interface
< 
<   ! ----- interface for 3D arrays -----
<   interface reorder123x132
<     module procedure reorder_int_123x132, reorder_wp_123x132
<   end interface
< 
<   interface reorder123x213
<     module procedure reorder_int_123x213, reorder_wp_123x213
<   end interface
< 
<   interface reorder123x231
<     module procedure reorder_int_123x231, reorder_wp_123x231
<   end interface
< 
<   interface reorder123x312
<     module procedure reorder_int_123x312, reorder_wp_123x312
<   end interface
< 
<   interface reorder123x321
<     module procedure reorder_int_123x321, reorder_wp_123x321
<   end interface
< 
<   ! ----- interface for 4D arrays -----
<   interface reorder1234x1243
<     module procedure reorder_int_1234x1243, reorder_wp_1234x1243
<   end interface
< 
<   interface reorder1234x1324
<     module procedure reorder_int_1234x1324, reorder_wp_1234x1324
<   end interface
< 
<   interface reorder1234x1342
<     module procedure reorder_int_1234x1342, reorder_wp_1234x1342
<   end interface
< 
<   interface reorder1234x1423
<     module procedure reorder_int_1234x1423, reorder_wp_1234x1423
<   end interface
< 
<   interface reorder1234x1432
<     module procedure reorder_int_1234x1432, reorder_wp_1234x1432
<   end interface
< 
<   interface reorder1234x2134
<     module procedure reorder_int_1234x2134, reorder_wp_1234x2134
<   end interface
< 
<   interface reorder1234x2143
<     module procedure reorder_int_1234x2143, reorder_wp_1234x2143
<   end interface
< 
<   interface reorder1234x2314
<     module procedure reorder_int_1234x2314, reorder_wp_1234x2314
<   end interface
< 
<   interface reorder1234x2341
<     module procedure reorder_int_1234x2341, reorder_wp_1234x2341
<   end interface
< 
<   interface reorder1234x2413
<     module procedure reorder_int_1234x2413, reorder_wp_1234x2413
<   end interface
< 
<   interface reorder1234x2431
<     module procedure reorder_int_1234x2431, reorder_wp_1234x2431
<   end interface
< 
<   interface reorder1234x3124
<     module procedure reorder_int_1234x3124, reorder_wp_1234x3124
<   end interface
< 
<   interface reorder1234x3142
<     module procedure reorder_int_1234x3142, reorder_wp_1234x3142
<   end interface
< 
<   interface reorder1234x3214
<     module procedure reorder_int_1234x3214, reorder_wp_1234x3214
<   end interface
< 
<   interface reorder1234x3241
<     module procedure reorder_int_1234x3241, reorder_wp_1234x3241
<   end interface
< 
<   interface reorder1234x3412
<     module procedure reorder_int_1234x3412, reorder_wp_1234x3412
<   end interface
< 
<   interface reorder1234x3421
<     module procedure reorder_int_1234x3421, reorder_wp_1234x3421
<   end interface
< 
<   interface reorder1234x4123
<     module procedure reorder_int_1234x4123, reorder_wp_1234x4123
<   end interface
< 
<   interface reorder1234x4132
<     module procedure reorder_int_1234x4132, reorder_wp_1234x4132
<   end interface
< 
<   interface reorder1234x4213
<     module procedure reorder_int_1234x4213, reorder_wp_1234x4213
<   end interface
< 
<   interface reorder1234x4231
<     module procedure reorder_int_1234x4231, reorder_wp_1234x4231
<   end interface
< 
<   interface reorder1234x4312
<     module procedure reorder_int_1234x4312, reorder_wp_1234x4312
<   end interface
< 
<   interface reorder1234x4321
<     module procedure reorder_int_1234x4321, reorder_wp_1234x4321
<   end interface
< 
< contains
< 
<   ! ----- reorder for 2D arrays -----
<   ! reorder the indecies of 4D array
<   function reorder_int_12x21(array)
<     integer, dimension(:,:), intent(in) :: array
<     integer, dimension(size(array,dim=2),size(array,dim=1)) :: reorder_int_12x21
<     reorder_int_12x21(:,:) = transpose(array(:,:))
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_wp_12x21(array)
<     real(wp), dimension(:,:), intent(in) :: array
<     real(wp), dimension(size(array,dim=2),size(array,dim=1)) :: reorder_wp_12x21
<     reorder_wp_12x21(:,:) = transpose(array(:,:))
<   end function
< 
<   ! ----- reorder for 3D arrays -----
<   ! reorder the indecies of 4D array
<   function reorder_int_123x132(array)
<     integer, dimension(:,:,:), intent(in) :: array
<     integer, dimension(size(array,dim=1),size(array,dim=3),size(array,dim=2)) :: reorder_int_123x132
<     integer :: i2
<     do i2 = 1, size(array,dim=2)
<       reorder_int_123x132(:,:,i2) = array(:,i2,:)
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_wp_123x132(array)
<     real(wp), dimension(:,:,:), intent(in) :: array
<     real(wp), dimension(size(array,dim=1),size(array,dim=3),size(array,dim=2)) :: reorder_wp_123x132
<     integer :: i2
<     do i2 = 1, size(array,dim=2)
<       reorder_wp_123x132(:,:,i2) = array(:,i2,:)
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_int_123x213(array)
<     integer, dimension(:,:,:), intent(in) :: array
<     integer, dimension(size(array,dim=2),size(array,dim=1),size(array,dim=3)) :: reorder_int_123x213
<     integer :: i3
<     do i3 = 1, size(array,dim=3)
<       reorder_int_123x213(:,:,i3) = transpose(array(:,:,i3))
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_wp_123x213(array)
<     real(wp), dimension(:,:,:), intent(in) :: array
<     real(wp), dimension(size(array,dim=2),size(array,dim=1),size(array,dim=3)) :: reorder_wp_123x213
<     integer :: i3
<     do i3 = 1, size(array,dim=3)
<       reorder_wp_123x213(:,:,i3) = transpose(array(:,:,i3))
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_int_123x231(array)
<     integer, dimension(:,:,:), intent(in) :: array
<     integer, dimension(size(array,dim=2),size(array,dim=3),size(array,dim=1)) :: reorder_int_123x231
<     integer :: i1
<     do i1 = 1, size(array,dim=1)
<       reorder_int_123x231(:,:,i1) = array(i1,:,:)
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_wp_123x231(array)
<     real(wp), dimension(:,:,:), intent(in) :: array
<     real(wp), dimension(size(array,dim=2),size(array,dim=3),size(array,dim=1)) :: reorder_wp_123x231
<     integer :: i1
<     do i1 = 1, size(array,dim=1)
<       reorder_wp_123x231(:,:,i1) = array(i1,:,:)
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_int_123x312(array)
<     integer, dimension(:,:,:), intent(in) :: array
<     integer, dimension(size(array,dim=3),size(array,dim=1),size(array,dim=2)) :: reorder_int_123x312
<     integer :: i2
<     do i2 = 1, size(array,dim=2)
<       reorder_int_123x312(:,:,i2) = transpose(array(:,i2,:))
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_wp_123x312(array)
<     real(wp), dimension(:,:,:), intent(in) :: array
<     real(wp), dimension(size(array,dim=3),size(array,dim=1),size(array,dim=2)) :: reorder_wp_123x312
<     integer :: i2
<     do i2 = 1, size(array,dim=2)
<       reorder_wp_123x312(:,:,i2) = transpose(array(:,i2,:))
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_int_123x321(array)
<     integer, dimension(:,:,:), intent(in) :: array
<     integer, dimension(size(array,dim=3),size(array,dim=2),size(array,dim=1)) :: reorder_int_123x321
<     integer :: i1, i2, i3
<     do i1 = 1, size(array,dim=1)
<       do i2 = 1, size(array,dim=2)
<         do i3 = 1, size(array,dim=3)
<           reorder_int_123x321(i3,i2,i1) = array(i1,i2,i3)
<         end do
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_wp_123x321(array)
<     real(wp), dimension(:,:,:), intent(in) :: array
<     real(wp), dimension(size(array,dim=3),size(array,dim=2),size(array,dim=1)) :: reorder_wp_123x321
<     integer :: i1, i2, i3
<     do i1 = 1, size(array,dim=1)
<       do i2 = 1, size(array,dim=2)
<         do i3 = 1, size(array,dim=3)
<           reorder_wp_123x321(i3,i2,i1) = array(i1,i2,i3)
<         end do
<       end do
<     end do
<   end function
< 
<   ! ----- reorder for 4D arrays -----
<   ! reorder the indecies of 4D array
<   function reorder_int_1234x1243(array)
<     integer, dimension(:,:,:,:), intent(in) :: array
<     integer, dimension(size(array,dim=1),size(array,dim=2),size(array,dim=4),size(array,dim=3)) :: reorder_int_1234x1243
<     integer :: i4,i3
<     do i3 = 1, size(array,dim=3)
<       do i4 = 1, size(array,dim=4)
<         reorder_int_1234x1243(:,:,i4,i3) = array(:,:,i3,i4)
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_wp_1234x1243(array)
<     real(wp), dimension(:,:,:,:), intent(in) :: array
<     real(wp), dimension(size(array,dim=1),size(array,dim=2),size(array,dim=4),size(array,dim=3)) :: reorder_wp_1234x1243
<     integer :: i4,i3
<     do i3 = 1, size(array,dim=3)
<       do i4 = 1, size(array,dim=4)
<         reorder_wp_1234x1243(:,:,i4,i3) = array(:,:,i3,i4)
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_int_1234x1324(array)
<     integer, dimension(:,:,:,:), intent(in) :: array
<     integer, dimension(size(array,dim=1),size(array,dim=3),size(array,dim=2),size(array,dim=4)) :: reorder_int_1234x1324
<     integer :: i2,i4
<     do i4 = 1, size(array,dim=4)
<       do i2 = 1, size(array,dim=2)
<         reorder_int_1234x1324(:,:,i2,i4) = array(:,i2,:,i4)
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_wp_1234x1324(array)
<     real(wp), dimension(:,:,:,:), intent(in) :: array
<     real(wp), dimension(size(array,dim=1),size(array,dim=3),size(array,dim=2),size(array,dim=4)) :: reorder_wp_1234x1324
<     integer :: i2,i4
<     do i4 = 1, size(array,dim=4)
<       do i2 = 1, size(array,dim=2)
<         reorder_wp_1234x1324(:,:,i2,i4) = array(:,i2,:,i4)
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_int_1234x1342(array)
<     integer, dimension(:,:,:,:), intent(in) :: array
<     integer, dimension(size(array,dim=1),size(array,dim=3),size(array,dim=4),size(array,dim=2)) :: reorder_int_1234x1342
<     integer :: i4,i2
<     do i2 = 1, size(array,dim=2)
<       do i4 = 1, size(array,dim=4)
<         reorder_int_1234x1342(:,:,i4,i2) = array(:,i2,:,i4)
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_wp_1234x1342(array)
<     real(wp), dimension(:,:,:,:), intent(in) :: array
<     real(wp), dimension(size(array,dim=1),size(array,dim=3),size(array,dim=4),size(array,dim=2)) :: reorder_wp_1234x1342
<     integer :: i4,i2
<     do i2 = 1, size(array,dim=2)
<       do i4 = 1, size(array,dim=4)
<         reorder_wp_1234x1342(:,:,i4,i2) = array(:,i2,:,i4)
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_int_1234x1423(array)
<     integer, dimension(:,:,:,:), intent(in) :: array
<     integer, dimension(size(array,dim=1),size(array,dim=4),size(array,dim=2),size(array,dim=3)) :: reorder_int_1234x1423
<     integer :: i2,i3
<     do i3 = 1, size(array,dim=3)
<       do i2 = 1, size(array,dim=2)
<         reorder_int_1234x1423(:,:,i2,i3) = array(:,i2,i3,:)
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_wp_1234x1423(array)
<     real(wp), dimension(:,:,:,:), intent(in) :: array
<     real(wp), dimension(size(array,dim=1),size(array,dim=4),size(array,dim=2),size(array,dim=3)) :: reorder_wp_1234x1423
<     integer :: i2,i3
<     do i3 = 1, size(array,dim=3)
<       do i2 = 1, size(array,dim=2)
<         reorder_wp_1234x1423(:,:,i2,i3) = array(:,i2,i3,:)
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_int_1234x1432(array)
<     integer, dimension(:,:,:,:), intent(in) :: array
<     integer, dimension(size(array,dim=1),size(array,dim=4),size(array,dim=3),size(array,dim=2)) :: reorder_int_1234x1432
<     integer :: i3,i2
<     do i2 = 1, size(array,dim=2)
<       do i3 = 1, size(array,dim=3)
<         reorder_int_1234x1432(:,:,i3,i2) = array(:,i2,i3,:)
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_wp_1234x1432(array)
<     real(wp), dimension(:,:,:,:), intent(in) :: array
<     real(wp), dimension(size(array,dim=1),size(array,dim=4),size(array,dim=3),size(array,dim=2)) :: reorder_wp_1234x1432
<     integer :: i3,i2
<     do i2 = 1, size(array,dim=2)
<       do i3 = 1, size(array,dim=3)
<         reorder_wp_1234x1432(:,:,i3,i2) = array(:,i2,i3,:)
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_int_1234x2134(array)
<     integer, dimension(:,:,:,:), intent(in) :: array
<     integer, dimension(size(array,dim=2),size(array,dim=1),size(array,dim=3),size(array,dim=4)) :: reorder_int_1234x2134
<     integer :: i3,i4
<     do i4 = 1, size(array,dim=4)
<       do i3 = 1, size(array,dim=3)
<         reorder_int_1234x2134(:,:,i3,i4) = transpose(array(:,:,i3,i4))
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_wp_1234x2134(array)
<     real(wp), dimension(:,:,:,:), intent(in) :: array
<     real(wp), dimension(size(array,dim=2),size(array,dim=1),size(array,dim=3),size(array,dim=4)) :: reorder_wp_1234x2134
<     integer :: i3,i4
<     do i4 = 1, size(array,dim=4)
<       do i3 = 1, size(array,dim=3)
<         reorder_wp_1234x2134(:,:,i3,i4) = transpose(array(:,:,i3,i4))
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_int_1234x2143(array)
<     integer, dimension(:,:,:,:), intent(in) :: array
<     integer, dimension(size(array,dim=2),size(array,dim=1),size(array,dim=4),size(array,dim=3)) :: reorder_int_1234x2143
<     integer :: i4,i3
<     do i3 = 1, size(array,dim=3)
<       do i4 = 1, size(array,dim=4)
<         reorder_int_1234x2143(:,:,i4,i3) = transpose(array(:,:,i3,i4))
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_wp_1234x2143(array)
<     real(wp), dimension(:,:,:,:), intent(in) :: array
<     real(wp), dimension(size(array,dim=2),size(array,dim=1),size(array,dim=4),size(array,dim=3)) :: reorder_wp_1234x2143
<     integer :: i4,i3
<     do i3 = 1, size(array,dim=3)
<       do i4 = 1, size(array,dim=4)
<         reorder_wp_1234x2143(:,:,i4,i3) = transpose(array(:,:,i3,i4))
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_int_1234x2314(array)
<     integer, dimension(:,:,:,:), intent(in) :: array
<     integer, dimension(size(array,dim=2),size(array,dim=3),size(array,dim=1),size(array,dim=4)) :: reorder_int_1234x2314
<     integer :: i1,i4
<     do i4 = 1, size(array,dim=4)
<       do i1 = 1, size(array,dim=1)
<         reorder_int_1234x2314(:,:,i1,i4) = array(i1,:,:,i4)
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_wp_1234x2314(array)
<     real(wp), dimension(:,:,:,:), intent(in) :: array
<     real(wp), dimension(size(array,dim=2),size(array,dim=3),size(array,dim=1),size(array,dim=4)) :: reorder_wp_1234x2314
<     integer :: i1,i4
<     do i4 = 1, size(array,dim=4)
<       do i1 = 1, size(array,dim=1)
<         reorder_wp_1234x2314(:,:,i1,i4) = array(i1,:,:,i4)
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_int_1234x2341(array)
<     integer, dimension(:,:,:,:), intent(in) :: array
<     integer, dimension(size(array,dim=2),size(array,dim=3),size(array,dim=4),size(array,dim=1)) :: reorder_int_1234x2341
<     integer :: i4,i1
<     do i1 = 1, size(array,dim=1)
<       do i4 = 1, size(array,dim=4)
<         reorder_int_1234x2341(:,:,i4,i1) = array(i1,:,:,i4)
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_wp_1234x2341(array)
<     real(wp), dimension(:,:,:,:), intent(in) :: array
<     real(wp), dimension(size(array,dim=2),size(array,dim=3),size(array,dim=4),size(array,dim=1)) :: reorder_wp_1234x2341
<     integer :: i4,i1
<     do i1 = 1, size(array,dim=1)
<       do i4 = 1, size(array,dim=4)
<         reorder_wp_1234x2341(:,:,i4,i1) = array(i1,:,:,i4)
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_int_1234x2413(array)
<     integer, dimension(:,:,:,:), intent(in) :: array
<     integer, dimension(size(array,dim=2),size(array,dim=4),size(array,dim=1),size(array,dim=3)) :: reorder_int_1234x2413
<     integer :: i1,i3
<     do i3 = 1, size(array,dim=3)
<       do i1 = 1, size(array,dim=1)
<         reorder_int_1234x2413(:,:,i1,i3) = array(i1,:,i3,:)
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_wp_1234x2413(array)
<     real(wp), dimension(:,:,:,:), intent(in) :: array
<     real(wp), dimension(size(array,dim=2),size(array,dim=4),size(array,dim=1),size(array,dim=3)) :: reorder_wp_1234x2413
<     integer :: i1,i3
<     do i3 = 1, size(array,dim=3)
<       do i1 = 1, size(array,dim=1)
<         reorder_wp_1234x2413(:,:,i1,i3) = array(i1,:,i3,:)
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_int_1234x2431(array)
<     integer, dimension(:,:,:,:), intent(in) :: array
<     integer, dimension(size(array,dim=2),size(array,dim=4),size(array,dim=3),size(array,dim=1)) :: reorder_int_1234x2431
<     integer :: i3,i1
<     do i1 = 1, size(array,dim=1)
<       do i3 = 1, size(array,dim=3)
<         reorder_int_1234x2431(:,:,i3,i1) = array(i1,:,i3,:)
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_wp_1234x2431(array)
<     real(wp), dimension(:,:,:,:), intent(in) :: array
<     real(wp), dimension(size(array,dim=2),size(array,dim=4),size(array,dim=3),size(array,dim=1)) :: reorder_wp_1234x2431
<     integer :: i3,i1
<     do i1 = 1, size(array,dim=1)
<       do i3 = 1, size(array,dim=3)
<         reorder_wp_1234x2431(:,:,i3,i1) = array(i1,:,i3,:)
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_int_1234x3124(array)
<     integer, dimension(:,:,:,:), intent(in) :: array
<     integer, dimension(size(array,dim=3),size(array,dim=1),size(array,dim=2),size(array,dim=4)) :: reorder_int_1234x3124
<     integer :: i2,i4
<     do i4 = 1, size(array,dim=4)
<       do i2 = 1, size(array,dim=2)
<         reorder_int_1234x3124(:,:,i2,i4) = transpose(array(:,i2,:,i4))
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_wp_1234x3124(array)
<     real(wp), dimension(:,:,:,:), intent(in) :: array
<     real(wp), dimension(size(array,dim=3),size(array,dim=1),size(array,dim=2),size(array,dim=4)) :: reorder_wp_1234x3124
<     integer :: i2,i4
<     do i4 = 1, size(array,dim=4)
<       do i2 = 1, size(array,dim=2)
<         reorder_wp_1234x3124(:,:,i2,i4) = transpose(array(:,i2,:,i4))
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_int_1234x3142(array)
<     integer, dimension(:,:,:,:), intent(in) :: array
<     integer, dimension(size(array,dim=3),size(array,dim=1),size(array,dim=4),size(array,dim=2)) :: reorder_int_1234x3142
<     integer :: i4,i2
<     do i2 = 1, size(array,dim=2)
<       do i4 = 1, size(array,dim=4)
<         reorder_int_1234x3142(:,:,i4,i2) = transpose(array(:,i2,:,i4))
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_wp_1234x3142(array)
<     real(wp), dimension(:,:,:,:), intent(in) :: array
<     real(wp), dimension(size(array,dim=3),size(array,dim=1),size(array,dim=4),size(array,dim=2)) :: reorder_wp_1234x3142
<     integer :: i4,i2
<     do i2 = 1, size(array,dim=2)
<       do i4 = 1, size(array,dim=4)
<         reorder_wp_1234x3142(:,:,i4,i2) = transpose(array(:,i2,:,i4))
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_int_1234x3214(array)
<     integer, dimension(:,:,:,:), intent(in) :: array
<     integer, dimension(size(array,dim=3),size(array,dim=2),size(array,dim=1),size(array,dim=4)) :: reorder_int_1234x3214
<     integer :: i1,i4
<     do i4 = 1, size(array,dim=4)
<       do i1 = 1, size(array,dim=1)
<         reorder_int_1234x3214(:,:,i1,i4) = transpose(array(i1,:,:,i4))
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_wp_1234x3214(array)
<     real(wp), dimension(:,:,:,:), intent(in) :: array
<     real(wp), dimension(size(array,dim=3),size(array,dim=2),size(array,dim=1),size(array,dim=4)) :: reorder_wp_1234x3214
<     integer :: i1,i4
<     do i4 = 1, size(array,dim=4)
<       do i1 = 1, size(array,dim=1)
<         reorder_wp_1234x3214(:,:,i1,i4) = transpose(array(i1,:,:,i4))
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_int_1234x3241(array)
<     integer, dimension(:,:,:,:), intent(in) :: array
<     integer, dimension(size(array,dim=3),size(array,dim=2),size(array,dim=4),size(array,dim=1)) :: reorder_int_1234x3241
<     integer :: i4,i1
<     do i1 = 1, size(array,dim=1)
<       do i4 = 1, size(array,dim=4)
<         reorder_int_1234x3241(:,:,i4,i1) = transpose(array(i1,:,:,i4))
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_wp_1234x3241(array)
<     real(wp), dimension(:,:,:,:), intent(in) :: array
<     real(wp), dimension(size(array,dim=3),size(array,dim=2),size(array,dim=4),size(array,dim=1)) :: reorder_wp_1234x3241
<     integer :: i4,i1
<     do i1 = 1, size(array,dim=1)
<       do i4 = 1, size(array,dim=4)
<         reorder_wp_1234x3241(:,:,i4,i1) = transpose(array(i1,:,:,i4))
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_int_1234x3412(array)
<     integer, dimension(:,:,:,:), intent(in) :: array
<     integer, dimension(size(array,dim=3),size(array,dim=4),size(array,dim=1),size(array,dim=2)) :: reorder_int_1234x3412
<     integer :: i1,i2
<     do i2 = 1, size(array,dim=2)
<       do i1 = 1, size(array,dim=1)
<         reorder_int_1234x3412(:,:,i1,i2) = array(i1,i2,:,:)
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_wp_1234x3412(array)
<     real(wp), dimension(:,:,:,:), intent(in) :: array
<     real(wp), dimension(size(array,dim=3),size(array,dim=4),size(array,dim=1),size(array,dim=2)) :: reorder_wp_1234x3412
<     integer :: i1,i2
<     do i2 = 1, size(array,dim=2)
<       do i1 = 1, size(array,dim=1)
<         reorder_wp_1234x3412(:,:,i1,i2) = array(i1,i2,:,:)
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_int_1234x3421(array)
<     integer, dimension(:,:,:,:), intent(in) :: array
<     integer, dimension(size(array,dim=3),size(array,dim=4),size(array,dim=2),size(array,dim=1)) :: reorder_int_1234x3421
<     integer :: i2,i1
<     do i1 = 1, size(array,dim=1)
<       do i2 = 1, size(array,dim=2)
<         reorder_int_1234x3421(:,:,i2,i1) = array(i1,i2,:,:)
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_wp_1234x3421(array)
<     real(wp), dimension(:,:,:,:), intent(in) :: array
<     real(wp), dimension(size(array,dim=3),size(array,dim=4),size(array,dim=2),size(array,dim=1)) :: reorder_wp_1234x3421
<     integer :: i2,i1
<     do i1 = 1, size(array,dim=1)
<       do i2 = 1, size(array,dim=2)
<         reorder_wp_1234x3421(:,:,i2,i1) = array(i1,i2,:,:)
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_int_1234x4123(array)
<     integer, dimension(:,:,:,:), intent(in) :: array
<     integer, dimension(size(array,dim=4),size(array,dim=1),size(array,dim=2),size(array,dim=3)) :: reorder_int_1234x4123
<     integer :: i2,i3
<     do i3 = 1, size(array,dim=3)
<       do i2 = 1, size(array,dim=2)
<         reorder_int_1234x4123(:,:,i2,i3) = transpose(array(:,i2,i3,:))
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_wp_1234x4123(array)
<     real(wp), dimension(:,:,:,:), intent(in) :: array
<     real(wp), dimension(size(array,dim=4),size(array,dim=1),size(array,dim=2),size(array,dim=3)) :: reorder_wp_1234x4123
<     integer :: i2,i3
<     do i3 = 1, size(array,dim=3)
<       do i2 = 1, size(array,dim=2)
<         reorder_wp_1234x4123(:,:,i2,i3) = transpose(array(:,i2,i3,:))
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_int_1234x4132(array)
<     integer, dimension(:,:,:,:), intent(in) :: array
<     integer, dimension(size(array,dim=4),size(array,dim=1),size(array,dim=3),size(array,dim=2)) :: reorder_int_1234x4132
<     integer :: i3,i2
<     do i2 = 1, size(array,dim=2)
<       do i3 = 1, size(array,dim=3)
<         reorder_int_1234x4132(:,:,i3,i2) = transpose(array(:,i2,i3,:))
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_wp_1234x4132(array)
<     real(wp), dimension(:,:,:,:), intent(in) :: array
<     real(wp), dimension(size(array,dim=4),size(array,dim=1),size(array,dim=3),size(array,dim=2)) :: reorder_wp_1234x4132
<     integer :: i3,i2
<     do i2 = 1, size(array,dim=2)
<       do i3 = 1, size(array,dim=3)
<         reorder_wp_1234x4132(:,:,i3,i2) = transpose(array(:,i2,i3,:))
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_int_1234x4213(array)
<     integer, dimension(:,:,:,:), intent(in) :: array
<     integer, dimension(size(array,dim=4),size(array,dim=2),size(array,dim=1),size(array,dim=3)) :: reorder_int_1234x4213
<     integer :: i1,i3
<     do i3 = 1, size(array,dim=3)
<       do i1 = 1, size(array,dim=1)
<         reorder_int_1234x4213(:,:,i1,i3) = transpose(array(i1,:,i3,:))
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_wp_1234x4213(array)
<     real(wp), dimension(:,:,:,:), intent(in) :: array
<     real(wp), dimension(size(array,dim=4),size(array,dim=2),size(array,dim=1),size(array,dim=3)) :: reorder_wp_1234x4213
<     integer :: i1,i3
<     do i3 = 1, size(array,dim=3)
<       do i1 = 1, size(array,dim=1)
<         reorder_wp_1234x4213(:,:,i1,i3) = transpose(array(i1,:,i3,:))
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_int_1234x4231(array)
<     integer, dimension(:,:,:,:), intent(in) :: array
<     integer, dimension(size(array,dim=4),size(array,dim=2),size(array,dim=3),size(array,dim=1)) :: reorder_int_1234x4231
<     integer :: i3,i1
<     do i1 = 1, size(array,dim=1)
<       do i3 = 1, size(array,dim=3)
<         reorder_int_1234x4231(:,:,i3,i1) = transpose(array(i1,:,i3,:))
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_wp_1234x4231(array)
<     real(wp), dimension(:,:,:,:), intent(in) :: array
<     real(wp), dimension(size(array,dim=4),size(array,dim=2),size(array,dim=3),size(array,dim=1)) :: reorder_wp_1234x4231
<     integer :: i3,i1
<     do i1 = 1, size(array,dim=1)
<       do i3 = 1, size(array,dim=3)
<         reorder_wp_1234x4231(:,:,i3,i1) = transpose(array(i1,:,i3,:))
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_int_1234x4312(array)
<     integer, dimension(:,:,:,:), intent(in) :: array
<     integer, dimension(size(array,dim=4),size(array,dim=3),size(array,dim=1),size(array,dim=2)) :: reorder_int_1234x4312
<     integer :: i1,i2
<     do i2 = 1, size(array,dim=2)
<       do i1 = 1, size(array,dim=1)
<         reorder_int_1234x4312(:,:,i1,i2) = transpose(array(i1,i2,:,:))
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_wp_1234x4312(array)
<     real(wp), dimension(:,:,:,:), intent(in) :: array
<     real(wp), dimension(size(array,dim=4),size(array,dim=3),size(array,dim=1),size(array,dim=2)) :: reorder_wp_1234x4312
<     integer :: i1,i2
<     do i2 = 1, size(array,dim=2)
<       do i1 = 1, size(array,dim=1)
<         reorder_wp_1234x4312(:,:,i1,i2) = transpose(array(i1,i2,:,:))
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_int_1234x4321(array)
<     integer, dimension(:,:,:,:), intent(in) :: array
<     integer, dimension(size(array,dim=4),size(array,dim=3),size(array,dim=2),size(array,dim=1)) :: reorder_int_1234x4321
<     integer :: i2,i1
<     do i1 = 1, size(array,dim=1)
<       do i2 = 1, size(array,dim=2)
<         reorder_int_1234x4321(:,:,i2,i1) = transpose(array(i1,i2,:,:))
<       end do
<     end do
<   end function
< 
<   ! reorder the indecies of 4D array
<   function reorder_wp_1234x4321(array)
<     real(wp), dimension(:,:,:,:), intent(in) :: array
<     real(wp), dimension(size(array,dim=4),size(array,dim=3),size(array,dim=2),size(array,dim=1)) :: reorder_wp_1234x4321
<     integer :: i2,i1
<     do i1 = 1, size(array,dim=1)
<       do i2 = 1, size(array,dim=2)
<         reorder_wp_1234x4321(:,:,i2,i1) = transpose(array(i1,i2,:,:))
<       end do
<     end do
<   end function
< 
< end module
< 
---
> !KGEN-generated Fortran source file 
>   
> !Generated at : 2017-06-01 10:39:47 
> !KGEN version : 0.7.3 
>   
> !>
> ! Module: mo_gas_optics_specification
> 
> ! This code is part of
> ! RRTM for GCM Applications - Parallel (RRTMGP)
> !
> ! Eli Mlawer and Robert Pincus
> ! Andre Wehe and Jennifer Delamere
> ! email:  rrtmgp@aer.com
> !
> ! Copyright 2015,  Atmospheric and Environmental Research and
> ! Regents of the University of Colorado.  All right reserved.
> !
> ! Use and duplication is permitted under the terms of the
> !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause
> !
> ! Description: Reorder array indecies
> !
> 
> module mo_util_reorder
> 
>     USE mo_rrtmgp_kind, ONLY: wp 
> 
>     USE kgen_utils_mod, ONLY: kgen_dp, kgen_array_sumcheck 
>     USE tprof_mod, ONLY: tstart, tstop, tnull, tprnt 
>     IMPLICIT NONE 
> 
>   ! ----- interface for 2D arrays -----
>   interface reorder12x21
>     module procedure reorder_int_12x21, reorder_wp_12x21
>   end interface
> 
>   ! ----- interface for 3D arrays -----
> 
> 
>   interface reorder123x321
>     module procedure reorder_int_123x321, reorder_wp_123x321
>   end interface
> 
>   ! ----- interface for 4D arrays -----
> 
> 
> contains
> 
>   ! ----- reorder for 2D arrays -----
>   ! reorder the indecies of 4D array
>   function reorder_int_12x21(array)
>     integer, dimension(:,:), intent(in) :: array
>     integer, dimension(size(array,dim=2),size(array,dim=1)) :: reorder_int_12x21
>     reorder_int_12x21(:,:) = transpose(array(:,:))
>   end function
> 
>   ! reorder the indecies of 4D array
>   function reorder_wp_12x21(array)
>     real(wp), dimension(:,:), intent(in) :: array
>     real(wp), dimension(size(array,dim=2),size(array,dim=1)) :: reorder_wp_12x21
>     reorder_wp_12x21(:,:) = transpose(array(:,:))
>   end function
> 
>   ! ----- reorder for 3D arrays -----
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
>   function reorder_int_123x321(array)
>     integer, dimension(:,:,:), intent(in) :: array
>     integer, dimension(size(array,dim=3),size(array,dim=2),size(array,dim=1)) :: reorder_int_123x321
>     integer :: i1, i2, i3
>     do i1 = 1, size(array,dim=1)
>       do i2 = 1, size(array,dim=2)
>         do i3 = 1, size(array,dim=3)
>           reorder_int_123x321(i3,i2,i1) = array(i1,i2,i3)
>         end do
>       end do
>     end do
>   end function
> 
>   ! reorder the indecies of 4D array
>   function reorder_wp_123x321(array)
>     real(wp), dimension(:,:,:), intent(in) :: array
>     real(wp), dimension(size(array,dim=3),size(array,dim=2),size(array,dim=1)) :: reorder_wp_123x321
>     integer :: i1, i2, i3
>     do i1 = 1, size(array,dim=1)
>       do i2 = 1, size(array,dim=2)
>         do i3 = 1, size(array,dim=3)
>           reorder_wp_123x321(i3,i2,i1) = array(i1,i2,i3)
>         end do
>       end do
>     end do
>   end function
> 
>   ! ----- reorder for 4D arrays -----
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
>   ! reorder the indecies of 4D array
> 
> 
> end module
1,1490c1,3560
< ! Module: mo_gas_optics_specification
< 
< ! This code is part of
< ! RRTM for GCM Applications - Parallel (RRTMGP)
< !
< ! Eli Mlawer and Robert Pincus
< ! Andre Wehe and Jennifer Delamere
< ! email:  rrtmgp@aer.com
< !
< ! Copyright 2015,  Atmospheric and Environmental Research and
< ! Regents of the University of Colorado.  All right reserved.
< !
< ! Use and duplication is permitted under the terms of the
< !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause
< !
< ! Description:  Specifies all properties related to the k-distributions.  This includes each band's spectral properties and
< ! absorbing gases.
< 
< module mo_gas_optics_specification
<   use mo_rrtmgp_kind,        only: wp, wl
<   use mo_rrtmgp_constants,   only: avogad, pi, m_dry, m_h2o, grav
<   use mo_gas_optics_kernels, only: interpolation, gas_optical_depths_major, & 
<                                    gas_optical_depths_continuum, gas_optical_depths_minor, & 
<                                    gas_optical_depths_rayleigh, source
<   use mo_util_string,        only : lower_case, string_in_array, string_loc_in_array
<   use mo_gas_concentrations, only: ty_gas_concs
<   use mo_optical_props,      only: ty_optical_props, ty_optical_props_2str, ty_optical_props_nstr
<   use mo_util_reorder
<   implicit none
<   private
< 
<   ! -----------------------------------------------------------------------------------
<   type, public :: ty_gas_optics_specification
<     private
<     character(32), & 
<               dimension(:),   allocatable :: gas_names  ! gas names
< 
<     integer,  dimension(:,:), allocatable :: flavor        ! major species pair; (2,nflav)
<     integer,  dimension(:,:), allocatable :: gpoint_flavor ! flavor = gpoint_flavor(lower or upper atmosphere, g-point)
< 
<     integer,  dimension(:,:), allocatable :: band2gpt       ! (begin g-point, end g-point) = band2gpt(2,band)
<     integer,  dimension(:),   allocatable :: gpt2band       ! band = gpt2band(g-point)
< 
<     real(wp), dimension(:,:), allocatable :: band_lims_wavenum  ! (upper and lower wavenumber by band) = band_lims_wavenum(2,band)
<     ! -----------------------------------------------------------------------------------
<     ! Temperature and pressure interpolation grids 
<     real(wp), dimension(:),  allocatable :: press_ref,  press_ref_log, temp_ref
<     ! volume mixing ratios for reference atmosphere; vmr_ref(lower or upper atmosphere, gas, temp)
<     real(wp), dimension(:,:,:), allocatable :: vmr_ref
< 
<     real(wp) :: press_ref_min, press_ref_max, &  ! min and max pressure of interpolation grids
<                 temp_ref_min,  temp_ref_max      ! min and max temperature 
<     real(wp) :: press_ref_log_delta, & ! difference in ln pressure between consecutive reference levels
<                 temp_ref_delta,      & ! Temperature difference between consecutive reference levels
<                 press_ref_trop_log     ! log of reference pressure separating the lower and upper atmosphere
<     real(wp) :: stpfac                 ! standard pressure:temperature ratio
<     ! -----------------------------------------------------------------------------------
<     ! Absorption coefficients
<       ! ----- major gas absorption coefficients ; kmajor(g-point,eta,pressure,temperature)
<     real(wp), dimension(:,:,:,:), allocatable :: kmajor
<     ! ----- water vapor continuum
<       ! stored absorption coefficients due to water vapor self continuum; selfrefin(eta,temperature,g-point)
<     real(wp), dimension(:,:,:),   allocatable :: selfrefin, forrefin
<     ! ----- minor species
<       ! stored absorption coefficients due to minor absorbing gases in lower/upper part of atmosphere;
<       ! kminor_lower(minor_gas,g-point,eta,temperature)
<     real(wp), dimension(:,:,:,:), allocatable :: kminor_lower, kminor_upper
<     ! -----------------------------------------------------------------------------------
<     ! ----- Rayleigh scattering
<       ! stored scattering coefficients due to molecules in atmosphere;
<       ! krayl(g-point,eta,temperature,upper/lower atmosphere)
<     real(wp), dimension(:,:,:,:), allocatable :: krayl
<     ! -----------------------------------------------------------------------------------
<     ! Planck function spectral mapping
<     !   Allocated only when gas optics object is internal-source "flavor" 
<     !
<     real(wp), dimension(:,:,:,:), allocatable :: planck_frac   ! input Planck fractions
<                                                                ! planck_frac(eta,temperature,pressure,g-point)
<     real(wp), dimension(:,:),     allocatable :: totplnk       ! integrated Planck function by band; (reference temperatures,band)
<     real(wp)                                  :: totplnk_delta ! temperature steps in totplnk
<     ! -----------------------------------------------------------------------------------
<     ! Solar source function spectral mapping 
<     !   Allocated only when gas optics object is external-source "flavor" 
<     !
<     real(wp), dimension(:), allocatable :: solar_src ! solar source
<     ! -----------------------------------------------------------------------------------
<     ! Ancillary
<     ! computed by fill_kminor_activity(); g-points where minor gases are active; (g-point, minor gas) = kminor_activity(2,:)
<     integer, dimension(:,:), allocatable :: kminor_activity
<     ! -----------------------------------------------------------------------------------
<     ! Index into %gas_names -- is this a key species in any band? 
<     logical, dimension(:), allocatable :: is_key
<     ! -----------------------------------------------------------------------------------
< 
<   contains
<     ! Type-bound procedures
<     ! Public procedures
<     ! public interface
<     generic, public :: init       => init_int,       init_ext
<     generic, public :: gas_optics => gas_optics_int, gas_optics_ext
<     procedure, public :: is_initialized
<     procedure, public :: is_internal_source_present
<     procedure, public :: is_external_source_present
<     procedure, public :: weight_bandvals_by_gpoint
<     procedure, public :: expand
<     procedure, public :: get_ngas
<     procedure, public :: get_gases
<     procedure, public :: get_nband
<     procedure, public :: get_ngpt
<     procedure, public :: get_press_ref_min
<     procedure, public :: get_press_ref_max
<     procedure, public :: get_temp_ref_min
<     procedure, public :: get_temp_ref_max
<     ! The following functions describe the spectral discretization. Probably we want init functions too
<     ! These are associated with three components of the type 
<     procedure, public :: get_band_gpoint_limits
<     procedure, public :: get_gpoint_bands
<     procedure, public :: convert_band2gpt
<     procedure, public :: convert_gpt2band
<     procedure, public :: get_band_lims_wavenumber
<     procedure, public :: get_band_lims_wavelength
<     ! Internal procedures
<     procedure, public :: init_int
<     procedure, public :: init_ext
<     procedure, public :: gas_optics_int
<     procedure, public :: gas_optics_ext
<     procedure, public :: check_key_species_present
<     procedure, public :: get_minor_list
<     procedure, private :: fill_kminor_activity
<     procedure, private :: get_nflav
<     procedure, private :: get_nlay_ref
<     procedure, private :: get_neta
<     procedure, private :: compute_gas_tau_core
<   end type
<   ! -----------------------------------------------------------------------------------
<   public :: get_col_dry ! Utility function, not type-bound
< 
<   interface check_range
<     module procedure check_range_1D, check_range_2D, check_range_3D 
<   end interface check_range
< 
<   interface check_extent
<     module procedure check_extent_1D, check_extent_2D, check_extent_3D 
<   end interface check_extent
< contains
<   ! --------------------------------------------------------------------------------------
<   !
<   ! Public procedures
<   !
<   ! --------------------------------------------------------------------------------------
<   !
<   ! Two functions to define array sizes needed by gas_optics() 
<   !
<   pure function get_ngas(this)
<     ! return the number of gases registered in the spectral configuration
<     class(ty_gas_optics_specification), intent(in) :: this
<     integer                                        :: get_ngas
< 
<     get_ngas = size(this%gas_names)
<   end function get_ngas
<   !--------------------------------------------------------------------------------------------------------------------
<   pure function get_nflav(this)
<     ! return the number of major species pairs
<     class(ty_gas_optics_specification), intent(in) :: this
<     integer                                        :: get_nflav
< 
<     get_nflav = size(this%flavor,dim=2)
<   end function get_nflav
<   !--------------------------------------------------------------------------------------------------------------------
<   ! return the gas names
<   pure function get_gases(this)
<     class(ty_gas_optics_specification), intent(in) :: this
<     character(32), dimension(this%get_ngas())     :: get_gases
< 
<     get_gases = this%gas_names
<   end function get_gases
<   !--------------------------------------------------------------------------------------------------------------------
<   ! return the number of bands
<   pure function get_nband(this)
<     class(ty_gas_optics_specification), intent(in) :: this
<     integer                                        :: get_nband
< 
<     get_nband = size(this%band2gpt,dim=2)
<   end function get_nband
< 
<   !--------------------------------------------------------------------------------------------------------------------
<   ! return the number of g-points
<   pure function get_ngpt(this)
<     class(ty_gas_optics_specification), intent(in) :: this
<     integer                                        :: get_ngpt
< 
<     get_ngpt = size(this%gpoint_flavor,dim=2)
<   end function get_ngpt
<   !--------------------------------------------------------------------------------------------------------------------
< 
< 
<   ! Compute gas optical depth and, optionally, Planck source functions,
<   !  given temperature, pressure, and composition
<   function gas_optics_int(this,                                   &
<                       play, plev, tlay, tsfc, gas_desc,           & ! mandatory inputs
<                       optical_props,                              & ! mandatory outputs
<                       lay_src, lev_src_inc, lev_src_dec, sfc_src, & ! internal-source specific outputs
<                       col_dry, tlev)                              & ! optional inputs
<                       result(error_msg)
<     ! inputs
<     class(ty_gas_optics_specification), intent(in) :: this
<     real(wp), dimension(:,:), intent(in   ) :: play, &   ! layer pressures [hPa, mb]; (ncol,nlay)
<                                                plev, &   ! level pressures [hPa, mb]; (ncol,nlay+1)
<                                                tlay      ! layer temperatures [K]; (ncol,nlay)
<     real(wp), dimension(:),   intent(in   ) :: tsfc      ! surface skin temperatures [K]; (ncol)
<     type(ty_gas_concs),       intent(in   ) :: gas_desc  ! Gas volume mixing ratios
<     ! output
<     class(ty_optical_props),  intent(inout) :: optical_props
<     character(len=128)                      :: error_msg
<     ! source functions (LW only)
<     ! These include spectral weighting that accounts for state-dependent frequency to k-distribution mapping
<     ! [W/m2] 
<     real(wp), dimension(:,:,:), intent(  out) :: lay_src, &  ! source for average layer temperature; (ncol,nlay,ngpt)
<                                                  lev_src_inc, lev_src_dec  
<                                                              ! level source radiances in increasing/decreasing 
<                                                              ! ilay direction (ncol,nlay+1,ngpt)
<     real(wp), dimension(:,:),   intent(  out) :: sfc_src     ! Surface Planck source; (ncol,ngpts)
<     ! Optional inputs
<     real(wp), dimension(:,:),   intent(in   ), &
<                            optional, target :: col_dry, &  ! Column dry amount; dim(ncol,nlay)
<                                                tlev        ! level temperatures [K]l (ncol,nlay+1)
<     ! ----------------------------------------------------------
<     ! Local variables
<     ! Interpolation coefficients to save for use in source function 
<     integer,  dimension(size(play,dim=1), size(play,dim=2)) :: jtemp, jpress
<     logical,  dimension(size(play,dim=1), size(play,dim=2)) :: tropo
<     real(wp), dimension(2,2,2,this%get_nflav(),size(play,dim=1), size(play,dim=2)) :: fmajor
<     integer,  dimension(2,    this%get_nflav(),size(play,dim=1), size(play,dim=2)) :: jeta
<     ! Temporary 
<     real(wp), dimension(this%get_ngpt(),                   size(play,dim=1)) :: sfc_src_t
<     real(wp), dimension(this%get_ngpt(),size(play,dim=2),  size(play,dim=1)) :: lay_src_t
<     real(wp), dimension(this%get_ngpt(),size(play,dim=2)+1,size(play,dim=1)) :: lev_src_inc_t, lev_src_dec_t
<     ! ----------------------------------------------------------
<     ! dimensions - determined from problem size
<     integer :: ncol, nlay ! number of columns, layers
<     ! dimensions - provided by k-distribution
<     integer :: ngpt, nband, ngas, nflav ! Number of g-points, bands, gas, gas "flavors" (major species combinations) 
< 
<     ! index
<     integer :: icol, ilay, igpt, igas
< 
<     ! Variables for temperature at layer edges
<     ! [K] (ncol, nlay+1)
<     real(wp), dimension(size(play,dim=1),size(play,dim=2)+1), target  :: tlev_arr
<     real(wp), dimension(:,:),                                 pointer :: tlev_wk => NULL()
< 
<     ! ----------------------------------------------------------
<     ! Code starts
<     !
<     error_msg = ""
<     error_msg = compute_gas_taus(this,                       &
<                                  play, plev, tlay, gas_desc, & 
<                                  optical_props,              & 
<                                  jtemp, jpress, jeta, tropo, fmajor, & 
<                                  col_dry)    
<     if(error_msg  /= '') return
< 
<     ! init from array dimensions
<     ncol = size(play,dim=1)
<     nlay = size(play,dim=2)
<     ngpt = this%get_ngpt()
<     nband = this%get_nband()
<     ngas = this%get_ngas()
<     nflav = this%get_nflav()
< 
<     !
<     ! Planck source function 
<     !   Check input data sizes and values
<     !
<     error_msg = check_extent(tsfc, ncol, 'tsfc') 
<     if(error_msg  /= '') return
<     error_msg = check_range(tsfc, this%temp_ref_min,  this%temp_ref_max,  'tsfc')
<     if(error_msg  /= '') return
<     if(present(tlev)) then 
<       error_msg = check_extent(tlev, ncol, nlay+1, 'tlev') 
<       if(error_msg  /= '') return
<       error_msg = check_range(tlev, this%temp_ref_min, this%temp_ref_max, 'tlev')
<       if(error_msg  /= '') return
<     end if
<     
<     !
<     !   output extents 
<     !
<     error_msg = check_extent(sfc_src,     ncol,         ngpt, 'sfc_src') 
<     if(error_msg  /= '') return
<     error_msg = check_extent(lay_src,     ncol, nlay,   ngpt, 'lay_src') 
<     if(error_msg  /= '') return
<     error_msg = check_extent(lev_src_inc, ncol, nlay+1, ngpt, 'lev_src_inc') 
<     if(error_msg  /= '') return
<     error_msg = check_extent(lev_src_dec, ncol, nlay+1, ngpt, 'lev_src_dec') 
<     if(error_msg  /= '') return
< 
<     !
<     ! Source function needs temperature at interfaces/levels and at layer centers
<     !
<     if (present(tlev)) then
<       !   Users might have provided these
<       tlev_wk => tlev
<     else
<        tlev_wk => tlev_arr
<        !
<        ! Interpolate temperature to levels if not provided
<        !   Interpolation and extrapolation at boundaries is weighted by pressure
<        !
<        do icol = 1, ncol
<          tlev_arr(icol,1) = tlay(icol,1) &
<                            + (plev(icol,1)-play(icol,1))*(tlay(icol,2)-tlay(icol,1))  &
<               &                                           / (play(icol,2)-play(icol,1))
<        end do
<        do ilay = 2, nlay
<          do icol = 1, ncol
<            tlev_arr(icol,ilay) = (play(icol,ilay-1)*tlay(icol,ilay-1)*(plev(icol,ilay  )-play(icol,ilay)) &
<                                 +  play(icol,ilay  )*tlay(icol,ilay  )*(play(icol,ilay-1)-plev(icol,ilay))) /  &
<                                   (plev(icol,ilay)*(play(icol,ilay-1) - play(icol,ilay)))
<          end do
<        end do
<        do icol = 1, ncol
<          tlev_arr(icol,nlay+1) = tlay(icol,nlay)                                                             &
<                                 + (plev(icol,nlay+1)-play(icol,nlay))*(tlay(icol,nlay)-tlay(icol,nlay-1))  &
<                                                                       / (play(icol,nlay)-play(icol,nlay-1))
<        end do
<      end if
< 
<     call source(ncol, nlay, ngpt, nband, ngas, nflav, &
<                 tlay, tlev_wk, tsfc, merge(1,nlay,play(1,1) > play(1,nlay)), & 
<                 fmajor, jeta, tropo, jtemp, jpress,                    & 
<                 this%band2gpt, this%planck_frac, this%temp_ref_min,    & 
<                 this%totplnk_delta, this%totplnk, this%gpoint_flavor,  &  
<                 sfc_src_t, lay_src_t, lev_src_inc_t, lev_src_dec_t)
<    sfc_src     = reorder12x21  (sfc_src_t)
<    lay_src     = reorder123x321(lay_src_t) 
<    lev_src_inc = reorder123x321(lev_src_inc_t) 
<    lev_src_dec = reorder123x321(lev_src_dec_t) 
<   end function gas_optics_int
<   !------------------------------------------------------------------------------------------
< 
<   ! Compute gas optical depth
<   !  given temperature, pressure, and composition
<   function gas_optics_ext(this,        &
<     play, plev, tlay, gas_desc,        & ! mandatory inputs
<     optical_props, toa_src,            & ! mandatory outputs
<     col_dry) result(error_msg)           ! optional input 
<     
<     class(ty_gas_optics_specification), intent(in) :: this
<     real(wp), dimension(:,:), intent(in   ) :: play, &   ! layer pressures [hPa, mb]; (ncol,nlay)
<                                                plev, &   ! level pressures [hPa, mb]; (ncol,nlay+1)
<                                                tlay      ! layer temperatures [K]; (ncol,nlay)
<     type(ty_gas_concs),       intent(in   ) :: gas_desc  ! Gas volume mixing ratios
<     ! output
<     class(ty_optical_props),  intent(inout) :: optical_props
<     real(wp), dimension(:,:), intent(  out) :: toa_src     ! Top-of-atmosphere flux
<     character(len=128)                      :: error_msg
< 
<     ! Optional inputs
<     real(wp), dimension(:,:), intent(in   ), &
<                            optional, target :: col_dry ! Column dry amount; dim(ncol,nlay)
<     ! ----------------------------------------------------------
<     ! Local variables
<     ! Interpolation coefficients to save for use in source function 
<     integer,  dimension(size(play,dim=1), size(play,dim=2)) :: jtemp, jpress
<     logical,  dimension(size(play,dim=1), size(play,dim=2)) :: tropo
<     real(wp), dimension(2,2,2,this%get_nflav(),size(play,dim=1), size(play,dim=2)) :: fmajor
<     integer,  dimension(2,    this%get_nflav(),size(play,dim=1), size(play,dim=2)) :: jeta
<     ! ----------------------------------------------------------
<     integer :: ncol, ngpt 
< 
<     ! ----------------------------------------------------------
<     ! Code starts
<     !
<     error_msg = ""
<     error_msg = compute_gas_taus(this,                       &
<                                  play, plev, tlay, gas_desc, & 
<                                  optical_props,              & 
<                                  jtemp, jpress, jeta, tropo, fmajor, & 
<                                  col_dry)    
<     if(error_msg  /= '') return
< 
<     ncol = size(play,dim=1)
<     ngpt = this%get_ngpt()
<     error_msg = check_extent(toa_src,     ncol,         ngpt, 'toa_src') 
<     if(error_msg  /= '') return
<     toa_src(:,:) = spread(this%solar_src(:), dim=1, ncopies=ncol) 
<    
<   end function gas_optics_ext
<   !------------------------------------------------------------------------------------------
<   !
<   ! Returns optical properties and interpolation coefficients 
<   !
<   function compute_gas_taus(this,                       &
<                             play, plev, tlay, gas_desc, & 
<                             optical_props,              & 
<                             jtemp, jpress, jeta, tropo, fmajor, & 
<                             col_dry) result(error_msg)    
< 
<     class(ty_gas_optics_specification), & 
<                                       intent(in   ) :: this
<     real(wp), dimension(:,:),         intent(in   ) :: play, &   ! layer pressures [hPa, mb]; (ncol,nlay)
<                                                        plev, &   ! level pressures [hPa, mb]; (ncol,nlay+1)
<                                                        tlay      ! layer temperatures [K]; (ncol,nlay)
<     type(ty_gas_concs),               intent(in   ) :: gas_desc  ! Gas volume mixing ratios
< 
<     class(ty_optical_props),          intent(inout) :: optical_props
<     ! Interpolation coefficients  for use in source function 
<     integer,  dimension(:,:),         intent(  out) :: jtemp, jpress
<     integer,  dimension(:,:,:,:),     intent(  out) :: jeta
<     logical,  dimension(:,:),         intent(  out) :: tropo
<     real(wp), dimension(:,:,:,:,:,:), intent(  out) :: fmajor
<     character(len=128)                            :: error_msg
< 
<     ! Optional inputs
<     real(wp), dimension(:,:), intent(in   ), &
<                            optional, target :: col_dry ! Column dry amount; dim(ncol,nlay)
<     ! ----------------------------------------------------------
<     ! Local variables
<     ! gas amounts
<     real(wp), dimension(size(play,dim=1), size(play,dim=2))                  :: one_vmr ! a single volume mixing ratio, (ncol, nlay)
< 
<     real(wp), dimension(size(optical_props%tau,dim=3), &
<                         size(optical_props%tau,dim=2), &
<                         size(optical_props%tau,dim=1)) :: tau  ! optical depth; (ngpt, nlay, ncol)
<     real(wp), dimension(size(optical_props%tau,dim=3), &
<                         size(optical_props%tau,dim=2), &
<                         size(optical_props%tau,dim=1)) :: tau_rayleigh ! optical depth; (ngpt, nlay, ncol)
<                         
<     logical, dimension(this%get_ngas())              :: gas_is_present  ! Is the concentration of each gas known to the  
<                                                                         !   k-distribution available in the set of concentrations? 
<     integer, dimension(2, this%get_nflav())          :: flavor          ! 2 indices into concentration index per band, referring to 
<                                                                         ! gas-which-are-present
<     logical,           dimension(size(this%kminor_activity, 2)) &       ! For which entries in kminor_activity are 
<                                                      :: minor_entry_is_present ! gas concentrations available? 
<     real(wp),          dimension(:,:,:), allocatable :: vmr             ! volume mixing ratios; (nlay,ncol,ngas)
<     character(len=32), dimension(:),     allocatable :: terse_gas_names ! The gases known to the k-distribution with 
<                                                                         ! concentrations present
<     integer,           dimension(:,:),   allocatable :: kminor_activity ! Describes minor gas contributions; 
<                                                                         ! includes only available gases
<     character(len=32), dimension(:), allocatable     :: minor_gas_list
<     integer                                          :: imnr 
<     ! ----------------------------------------------------------
<     ! dimensions - determined from problem size
<     integer :: ncol, nlay ! number of columns, layers
<     ! dimensions - provided by k-distribution
<     integer :: ngpt, nband, ngas, nflav ! Number of g-points, bands, gas, gas "flavors" (major species combinations) 
<     ! index
<     integer :: igas, iband, idx_h2o
< 
<     ! Number of molecules per cm^2
<     real(wp), dimension(size(play,dim=1), size(play,dim=2)), target  :: col_dry_arr
<     real(wp), dimension(:,:),                                pointer :: col_dry_wk => NULL()
<     ! ----------------------------------------------------------
<     ! Code starts
<     !
<     error_msg = ''
<     ! Check for initialization
<     if (.not. this%is_initialized()) then
<       error_msg = 'ERROR: spectral configuration not loaded'
<       return
<     end if
<     !
<     ! Check for presence of key species in ty_gas_concs; return error if any key species are not present
<     !
<     error_msg = this%check_key_species_present(gas_desc)
<     if (error_msg /= '') return
< 
<     ! init from array dimensions
<     ncol = size(play,dim=1)
<     nlay = size(play,dim=2)
<     ngpt = this%get_ngpt()
<     nband = this%get_nband()
<     ngas = this%get_ngas()
<     nflav = this%get_nflav()
< 
<     !
<     ! Check input data sizes and values
<     !
<     error_msg = check_extent(play, ncol, nlay,   'play') 
<     if(error_msg  /= '') return
<     error_msg = check_extent(plev, ncol, nlay+1, 'plev') 
<     if(error_msg  /= '') return
<     error_msg = check_extent(tlay, ncol, nlay,   'tlay') 
<     if(error_msg  /= '') return
<     error_msg = check_range(play, this%press_ref_min, this%press_ref_max, 'play')
<     if(error_msg  /= '') return
<     error_msg = check_range(plev, this%press_ref_min, this%press_ref_max, 'plev')
<     if(error_msg  /= '') return
<     error_msg = check_range(tlay, this%temp_ref_min,  this%temp_ref_max,  'tlay')
<     if(error_msg  /= '') return
<     if(present(col_dry)) then 
<       error_msg = check_extent(col_dry, ncol, nlay, 'col_dry')
<       if(error_msg  /= '') return
<       error_msg = check_range(col_dry, 0._wp, huge(col_dry), 'col_dry')
<       if(error_msg  /= '') return
<     end if
<  
<     ! 
<     ! Code to be replaced when gas optics calculations are more thoroughly kernel-ized 
<     !
<     allocate(vmr(ncol, nlay, ngas))
<     do igas = 1, ngas
<       ! Get vmr only for gases provided in ty_gas_concs
<       if (any (lower_case(this%gas_names(igas)) == gas_desc%gas_name(:))) then
<          error_msg = gas_desc%get_vmr(this%gas_names(igas),one_vmr)
<          if (error_msg /= '') return
<          vmr(:,:,igas) = one_vmr
<       else
<       ! Temporarily set missing gas amounts to zero; may not be needed when missing
<       ! gases skipped in calculation
<          vmr(:,:,igas) = 0._wp
<       end if
<     end do
< 
<     !
<     ! Construct arrays of mixing ratios using only those gases that are both known to the 
<     !   k-distribution and have concentrations available 
<     !   Revise flavors and minor gases activities 
<     !
<     if(.false.) then 
<       !
<       ! Which gases from the k-distribution are present in the set of gas_concentrations? 
<       !
<       do igas = 1, this%get_ngas()
<         gas_is_present(igas) = string_in_array(this%gas_names(igas), gas_desc%gas_name)
<       end do 
<       ngas = count(gas_is_present)
<       allocate(terse_gas_names(ngas), vmr(ncol,nlay,ngas))
<       terse_gas_names(:) = pack(this%gas_names, mask=gas_is_present)
<       !
<       ! Expand volume mixing ratio of available gases to 3D fields
<       !
<       do igas = 1, ngas
<         error_msg = gas_desc%get_vmr(terse_gas_names(igas), one_vmr)
<         if (error_msg /= '') return
<         vmr(:,:,igas) = one_vmr
<       end do
<       !
<       ! Revise mappings into concentration arrays
<       !
<       do iband = 1, this%get_nflav()
<         flavor(1, iband) = string_loc_in_array(this%gas_names(this%flavor(1, iband)), terse_gas_names)
<         flavor(2, iband) = string_loc_in_array(this%gas_names(this%flavor(2, iband)), terse_gas_names)
<       end do 
<       !
<       ! For each minor gas entry: is the gas name in terse_gas_names? 
<       !
<       minor_entry_is_present(:) =[(string_in_array(this%gas_names(this%kminor_activity(2, imnr)), terse_gas_names),  &
<             imnr = 1, size(this%kminor_activity, 2))]
<       allocate(kminor_activity(2, count(minor_entry_is_present)))
<       !
<       ! A new kminor_activity data structure containing only the entries for which concentrations
<       !   are available
<       !
<       kminor_activity(1, :) = pack(this%kminor_activity(1, :), mask = minor_entry_is_present) 
<       kminor_activity(2, :) = pack(this%kminor_activity(2, :), mask = minor_entry_is_present) 
<       !
<       ! Revise mapping into concentration arrays
<       !
<       do imnr = 1, size(kminor_activity, 2)
<         kminor_activity(2, imnr) = string_loc_in_array(this%gas_names(kminor_activity(2, imnr)), terse_gas_names)
<       end do 
<     end if 
<     !
<     !
<     !
<     
<     ! Compute column amounts (number of molecule per cm^2) if user hasn't provided them
<     if (present(col_dry)) then
<       col_dry_wk => col_dry
<     else
<       idx_h2o = string_loc_in_array('h2o', terse_gas_names)
<       col_dry_arr = get_col_dry(vmr(:,:,idx_h2o), plev, tlay) ! column dry amounts computation
<       col_dry_wk => col_dry_arr
<     end if
< 
<     ! Make list of minor gases that are defined in specification and have available concentrations
<     ! Includes key species that are also considered minor at some g-points 
<     minor_gas_list = this%get_minor_list(gas_desc, ngas, this%gas_names, this%kminor_activity)
<     error_msg = this%compute_gas_tau_core(play, tlay, vmr, col_dry_wk, minor_gas_list, &
<                                      ncol, nlay, ngpt, nband, ngas, nflav, &
<                                      tau, tau_rayleigh, & 
<                                      fmajor, jeta, tropo, jtemp, jpress)
<     if (error_msg /= '') return
< 
<     call combine_and_reorder(tau, tau_rayleigh, allocated(this%krayl), optical_props) 
<    
<   end function compute_gas_taus
<   !------------------------------------------------------------------------------------------
<   function compute_gas_tau_core(this,            &
<     play, tlay, vmr, col_dry, minor_gas_list, & !  inputs
<     ncol, nlay, ngpt, nband, ngas, nflav,   &
<     tau, tau_rayleigh,                      & ! mandatory outputs
<     fmajor_out, jeta_out, tropo_out, jtemp_out, jpress_out) result(error_msg)
<     
<     class(ty_gas_optics_specification), intent(in) :: this
<     ! dimensions
<     integer, intent(in) :: ncol  ! Number of columns
<     integer, intent(in) :: nlay  ! Number of layers
<     integer, intent(in) :: ngpt  ! Number of gpts
<     integer, intent(in) :: nband ! Number of bands
<     integer, intent(in) :: ngas  ! Number of gases
<     integer, intent(in) :: nflav ! Number of gas flavors
< 
<     real(wp), dimension(ncol,nlay  ), intent(in) :: play   ! Layer pressures [hPa, mb]
<     real(wp), dimension(ncol,nlay  ), intent(in) :: tlay   ! Layer temperatures [K]
<     real(wp), dimension(ncol,nlay  ,ngas), &
<                                       intent(in) :: vmr ! volume mixing ratios
<     real(wp), dimension(ncol,nlay  ), intent(in) :: col_dry ! Column amount of dry air
<     ! List of minor gases to be used in gas_optics_ext()
<     character(len=32), dimension(:), intent(in)  :: minor_gas_list
< 
<     ! output
<     real(wp), dimension(ngpt,nlay,ncol), intent(out) :: tau          ! optical depth, will be transposed
<     real(wp), dimension(ngpt,nlay,ncol), intent(out) :: tau_rayleigh ! optical depth, will be transposed
< 
<     real(wp), dimension(2,2,2,nflav,ncol,nlay), optional, intent(out) :: fmajor_out 
<     integer,  dimension(2,    nflav,ncol,nlay), optional, intent(out) :: jeta_out  
<     logical,  dimension(            ncol,nlay), optional, intent(out) :: tropo_out
<     integer,  dimension(            ncol,nlay), optional, intent(out) :: jtemp_out
<     integer,  dimension(            ncol,nlay), optional, intent(out) :: jpress_out
< 
<     ! result
<     character(len=128) :: error_msg
<     ! ----------------------------------------------------------
<     ! Local variables
<     ! index
<     integer :: igas
<     ! Planck fractions
<     ! gas amounts
<     real(wp), dimension(ncol,nlay,ngas) :: col_gas ! column amounts for each gas
<     integer, dimension(ngas)  :: idx_gas_list      ! Index of minor gases to be used in gas_optics_ext()
< 
<     ! temperature variables
<     integer,  dimension(ncol,nlay) :: jtemp ! interpolation index for temperature
<     ! pressure variables
<     integer,  dimension(ncol,nlay) :: jpress ! interpolation index for pressure
<     logical,  dimension(ncol,nlay) :: tropo ! true lower atmosphere; false upper atmosphere
< 
<     integer, dimension(2,     nflav,ncol,nlay) :: jeta ! interpolation index for binary species parameter (eta)
<                                                      ! index(1) : reference temperature level
<                                                      ! index(2) : flavor
<                                                      ! index(3) : layer
< 
<     real(wp), dimension(2,    nflav,ncol,nlay) :: col_mix ! combination of major species's column amounts
<                                                          ! index(1) : reference temperature level
<                                                          ! index(2) : flavor
<                                                          ! index(3) : layer
< 
<     real(wp), dimension(2,2,2,nflav,ncol,nlay) :: fmajor ! interpolation fractions for major species
<                                                             ! index(1) : reference eta level (temperature dependent)
<                                                             ! index(2) : reference pressure level
<                                                             ! index(3) : reference temperature level
<                                                             ! index(4) : flavor
<                                                             ! index(5) : layer
< 
<     real(wp), dimension(2,2,  nflav,ncol,nlay) :: fminor ! interpolation fractions for minor species and continuum
<                                                           ! index(1) : reference eta level (temperature dependent)
<                                                           ! index(2) : reference temperature level
<                                                           ! index(3) : flavor
<                                                           ! index(4) : layer
< 
<     integer :: idx_h2o, idx_o2, idx_n2 ! index of some gases
< 
<     ! ----------------------------------------------------------
<     ! Code starts
<     !
<     error_msg = ''
< 
<     ! special gases
<     idx_h2o = string_loc_in_array('h2o', this%gas_names)
<     idx_o2  = string_loc_in_array('o2' , this%gas_names)
<     idx_n2  = string_loc_in_array('n2' , this%gas_names)
<     do igas = 1, size(minor_gas_list)
<       idx_gas_list(igas) = string_loc_in_array(minor_gas_list(igas), this%gas_names)
<     end do
< 
<     ! vmr and column gas amounts
<     do igas = 1, ngas
<       col_gas(:,:,igas) = vmr(:,:,igas) * col_dry(:,:)
<     end do
< 
<     tau(:,:,:) = 0._wp
<     ! ---- calculate gas optical depths ----
<     call interpolation( &
<       ncol,nlay,nflav,this%get_neta(), & ! dimensions
<       this%flavor,this%press_ref_log,this%temp_ref,this%press_ref_log_delta,this%temp_ref_min, & ! inputs from object
<       this%temp_ref_delta, this%press_ref_trop_log,this%vmr_ref,this%get_nlay_ref(), &
<       play,tlay,col_gas, & ! local input
<       jtemp,fmajor,fminor,col_mix,tropo,jeta,jpress) ! output 
<       
<     call gas_optical_depths_major( &
<       ncol,nlay,ngpt,nflav, & ! dimensions
<       this%gpoint_flavor,this%kmajor, & ! inputs from object
<       col_mix,fmajor,& 
<       jeta,tropo,jtemp,jpress, & ! local input
<       tau)
<       
<     call gas_optical_depths_continuum( &
<       ncol,nlay,ngpt,ngas,nflav, & ! dimensions
<       this%flavor,this%gpoint_flavor,this%selfrefin,this%forrefin,this%stpfac, & ! inputs from object
<       idx_h2o ,play,tlay,vmr,col_gas,& 
<       fminor,jeta,tropo,jtemp, & ! local input
<       tau)
<       
<     call gas_optical_depths_minor( &
<       ncol,nlay,ngpt,ngas,nflav, & ! dimensions
<       this%gpoint_flavor,this%band2gpt,this%kminor_lower,this%kminor_upper,this%kminor_activity, & ! inputs from object
<       idx_h2o,idx_o2,idx_n2,play,tlay,col_dry,col_gas,idx_gas_list, & 
<       fminor,jeta,tropo,jtemp, & ! local input
<       tau)
<       
<     if (allocated(this%krayl)) then
<       call gas_optical_depths_rayleigh( &
<         ncol,nlay,ngpt,ngas,nflav, & ! dimensions
<         this%gpoint_flavor,this%krayl, & ! inputs from object
<         idx_h2o,idx_o2,idx_n2,play,tlay,col_dry,col_gas,& 
<         fminor,jeta,tropo,jtemp, & ! local input
<         tau_rayleigh)
<     end if
< 
<     ! This is an internal function -- we can assume that all or none of these are present 
<     if(present(fmajor_out)) then 
<       fmajor_out = fmajor
<       jeta_out   = jeta 
<       tropo_out  = tropo 
<       jtemp_out  = jtemp 
<       jpress_out = jpress
<     end if 
<      
<   end function compute_gas_tau_core
<   !--------------------------------------------------------------------------------------------------------------------
<   !
<   ! Initialization 
<   !
<   !--------------------------------------------------------------------------------------------------------------------
<   ! Initialize object based on data read from netCDF file however the user desires. 
<   !  Rayleigh scattering tables may or may not be present; this is indicated with allocation status 
<   ! This interface is for the internal-sources object -- includes Plank functions and fractions
<   ! 
<   function init_int(this, gas_names, key_species,        & 
<                     band2gpt, band_lims_wavenum,            & 
<                     press_ref, press_ref_trop, temp_ref, & 
<                     temp_ref_p, temp_ref_t, vmr_ref,     & 
<                     kmajor, selfrefin, forrefin, kminor_lower, kminor_upper, & 
<                     totplnk, planck_frac, rayl_lower, rayl_upper) result(err_message) 
<     class(ty_gas_optics_specification), intent(inout) :: this
<     character(len=*), dimension(:), intent(in) :: gas_names
<     integer,  dimension(:,:,:),   intent(in) :: key_species
<     integer,  dimension(:,:),     intent(in) :: band2gpt 
<     real(wp), dimension(:,:),     intent(in) :: band_lims_wavenum
<     real(wp), dimension(:),       intent(in) :: press_ref, temp_ref
<     real(wp),                     intent(in) :: press_ref_trop, temp_ref_p, temp_ref_t
<     real(wp), dimension(:,:,:),   intent(in) :: vmr_ref
<     real(wp), dimension(:,:,:,:), intent(in) :: kmajor
<     real(wp), dimension(:,:,:),   intent(in) :: selfrefin, forrefin
<     real(wp), dimension(:,:,:,:), intent(in) :: kminor_lower, kminor_upper
<     real(wp), dimension(:,:),     intent(in) :: totplnk
<     real(wp), dimension(:,:,:,:), intent(in) :: planck_frac
<     real(wp), dimension(:,:,:),   intent(in), & 
<                                  allocatable :: rayl_lower, rayl_upper
<     character(len = 128) err_message
<     ! ---- 
<     err_message = init_abs_coeffs(this, & 
<                                   gas_names, key_species,    & 
<                                   band2gpt, band_lims_wavenum, &
<                                   press_ref, temp_ref,       & 
<                                   press_ref_trop, temp_ref_p, temp_ref_t, &
<                                   vmr_ref,                   & 
<                                   kmajor, selfrefin, forrefin, kminor_lower, kminor_upper, & 
<                                   rayl_lower, rayl_upper) 
<     ! Planck function tables 
<     ! 
<     this%totplnk = totplnk
<     this%planck_frac = planck_frac
<     ! Temperature steps for Planck function interpolation 
<     !   Assumes that temperature minimum is the same on both scales and that Planck scale
<     !   is equally spaced 
<     this%totplnk_delta =  (this%temp_ref_max-this%temp_ref_min) / (size(this%totplnk,dim=1)-1)
<   end function init_int
< 
<   !--------------------------------------------------------------------------------------------------------------------
<   ! Initialize object based on data read from netCDF file however the user desires. 
<   !  Rayleigh scattering tables may or may not be present; this is indicated with allocation status 
<   ! This interface is for the external-sources object -- includes TOA source function table 
<   ! 
<   function init_ext(this, gas_names, key_species,        & 
<                     band2gpt, band_lims_wavenum,           & 
<                     press_ref, press_ref_trop, temp_ref, & 
<                     temp_ref_p, temp_ref_t, vmr_ref,     & 
<                     kmajor, selfrefin, forrefin, kminor_lower, kminor_upper, & 
<                     solar_src, rayl_lower, rayl_upper)  result(err_message)
<     class(ty_gas_optics_specification), intent(inout) :: this
<     character(len=*), & 
<               dimension(:),       intent(in) :: gas_names
<     integer,  dimension(:,:,:),   intent(in) :: key_species
<     integer,  dimension(:,:),     intent(in) :: band2gpt 
<     real(wp), dimension(:,:),     intent(in) :: band_lims_wavenum
<     real(wp), dimension(:),       intent(in) :: press_ref, temp_ref
<     real(wp),                     intent(in) :: press_ref_trop, temp_ref_p, temp_ref_t
<     real(wp), dimension(:,:,:),   intent(in) :: vmr_ref
<     real(wp), dimension(:,:,:,:), intent(in) :: kmajor
<     real(wp), dimension(:,:,:),   intent(in) :: selfrefin, forrefin
<     real(wp), dimension(:,:,:,:), intent(in) :: kminor_lower, kminor_upper
<     real(wp), dimension(:),       intent(in), allocatable :: solar_src 
<                                                             ! allocatable status to change when solar source is present in file 
<     real(wp), dimension(:,:,:), intent(in), allocatable :: rayl_lower, rayl_upper
<     character(len = 128) err_message
<     ! ---- 
<     err_message = init_abs_coeffs(this, & 
<                                   gas_names, key_species,    & 
<                                   band2gpt, band_lims_wavenum, &
<                                   press_ref, temp_ref,       & 
<                                   press_ref_trop, temp_ref_p, temp_ref_t, &
<                                   vmr_ref,                   & 
<                                   kmajor, selfrefin, forrefin, kminor_lower, kminor_upper, & 
<                                   rayl_lower, rayl_upper) 
<     !
<     ! Something something solar source table init here 
<     ! 
<     this%solar_src = solar_src
<     
<   end function init_ext
<   !--------------------------------------------------------------------------------------------------------------------
<   ! Initialize absorption coefficient arrays,  
<   !   including Rayleigh scattering tables if provided (allocated) 
<   ! 
<   function init_abs_coeffs(this, & 
<                            gas_names, key_species,    & 
<                            band2gpt, band_lims_wavenum, &
<                            press_ref, temp_ref,       & 
<                            press_ref_trop, temp_ref_p, temp_ref_t, &
<                            vmr_ref,                   & 
<                            kmajor, selfrefin, forrefin, kminor_lower, kminor_upper, & 
<                            rayl_lower, rayl_upper) result(err_message) 
<     class(ty_gas_optics_specification), intent(inout) :: this
<     character(len=*), & 
<               dimension(:),       intent(in) :: gas_names
<     integer,  dimension(:,:,:),   intent(in) :: key_species
<     integer,  dimension(:,:),     intent(in) :: band2gpt 
<     real(wp), dimension(:,:),     intent(in) :: band_lims_wavenum
<     real(wp), dimension(:),       intent(in) :: press_ref, temp_ref
<     real(wp),                     intent(in) :: press_ref_trop, temp_ref_p, temp_ref_t
<     real(wp), dimension(:,:,:),   intent(in) :: vmr_ref
<     real(wp), dimension(:,:,:,:), intent(in) :: kmajor
<     real(wp), dimension(:,:,:),   intent(in) :: selfrefin, forrefin
<     real(wp), dimension(:,:,:,:), intent(in) :: kminor_lower, kminor_upper
<     
<     real(wp), dimension(:,:,:),   intent(in), & 
<                                  allocatable :: rayl_lower, rayl_upper
<     character(len=128)                       :: err_message 
<     ! --------------------------------------
<     err_message = "" 
<     ! Assignment 
<     !   includes allocation 
<     this%gas_names = gas_names
<     this%press_ref = press_ref
<     this%temp_ref  = temp_ref 
<     this%vmr_ref   = vmr_ref
<     this%kmajor       = kmajor
<     this%selfrefin    = selfrefin
<     this%forrefin     = forrefin 
<     this%kminor_lower = kminor_lower
<     this%kminor_upper = kminor_upper
<     this%band2gpt        = band2gpt       
<     this%band_lims_wavenum = band_lims_wavenum
< 
<     if(allocated(rayl_lower) .neqv. allocated(rayl_upper)) then 
<       err_message = "rayl_lower and rayl_upper must have the same allocation status"
<       return 
<     end if 
<     if (allocated(rayl_lower)) then
<       allocate(this%krayl(size(rayl_lower,dim=1),size(rayl_lower,dim=2),size(rayl_lower,dim=3),2))
<       this%krayl(:,:,:,1) = rayl_lower
<       this%krayl(:,:,:,2) = rayl_upper
<     end if
< 
< 
<     ! ---- post processing ----
< 
<     this%press_ref(:) = this%press_ref(:) * 0.01_wp ! convert reference pressure from hPa to Pa
<     ! creates log reference pressure
<     allocate(this%press_ref_log(size(this%press_ref)))
<     this%press_ref_log(:) = log(this%press_ref(:))
< 
<     ! log scale of reference pressure
<     this%press_ref_trop_log = log(press_ref_trop)
<     ! factor needed for continuum optical depth
<     this%stpfac = temp_ref_t/temp_ref_p*100._wp
< 
<     ! create flavor list
<     call create_flavor(key_species, this%flavor)
<     ! create gpt2band
<     call create_gpt2band(this%band2gpt, this%gpt2band)
<     ! create gpoint_flavor list
<     call create_gpoint_flavor(key_species, this%gpt2band, this%flavor, this%gpoint_flavor)
< 
<     ! minimum, maximum reference temperature, pressure -- assumes low-to-high ordering 
<     !   for T, high-to-low ordering for p 
<     this%temp_ref_min  = this%temp_ref (1)
<     this%temp_ref_max  = this%temp_ref (size(this%temp_ref))
<     this%press_ref_min = this%press_ref(size(this%press_ref))
<     this%press_ref_max = this%press_ref(1)
< 
<     ! creates press_ref_log, temp_ref_delta
<     this%press_ref_log_delta = (log(this%press_ref_min)-log(this%press_ref_max))/(size(this%press_ref)-1)
<     this%temp_ref_delta      = (this%temp_ref_max-this%temp_ref_min)/(size(this%temp_ref)-1)
< 
<     ! fills kminor_activity; a list where minor species are active
<     call this%fill_kminor_activity()
< 
<     !
<     ! Which species are key in one or more bands? 
<     !   this%flavor is an index into this%gas_names
<     !
<     if (allocated(this%is_key)) deallocate(this%is_key) ! Shouldn't ever happen... 
<     allocate(this%is_key(this%get_ngas()))
<     this%is_key(:) = .False. 
<     this%is_key(pack(this%flavor(:,:), mask = .true.)) = .true. 
<     
<   end function init_abs_coeffs
< 
<   !------------------------------------------------------------------------------------------
<   !
<   ! Ensure that every key gas required by the k-distribution is 
<   !    present in the gas concentration object
<   !
<   function check_key_species_present(this, gas_desc) result(error_msg)
<     class(ty_gas_optics_specification), intent(in) :: this
<     class(ty_gas_concs),                intent(in) :: gas_desc
<     character(len=128)                             :: error_msg
<  
<     ! Local variables
<     character(len=32), dimension(count(this%is_key(:)  )) :: key_gas_names
<     integer                                               :: igas
<     ! --------------------------------------
<     error_msg = "" 
<     key_gas_names = pack(this%gas_names, mask=this%is_key)
<     do igas = 1, size(key_gas_names)
<       if(.not. string_in_array(key_gas_names(igas), gas_desc%gas_name)) & 
<         error_msg = ' ' // trim(lower_case(key_gas_names(igas))) // trim(error_msg)
<     end do
<     if(len_trim(error_msg) > 0) error_msg = "gas_optics: required gases" // trim(error_msg) // " are not provided" 
< 
<   end function check_key_species_present
< 
<   !--------------------------------------------------------------------------------------------------------------------
<   !
<   ! Function to define names of key and minor gases to be used by gas_optics().
<   ! The final list gases includes those that are defined in gas_optics_specification 
<   ! and are provided in ty_gas_concs.
<   !
<   function get_minor_list(this, gas_desc, ngas, names_spec, kminor_activity)
<     class(ty_gas_optics_specification), intent(in)       :: this
<     class(ty_gas_concs), intent(in)                      :: gas_desc
<     integer, intent(in)                                  :: ngas
<     character(32), dimension(ngas), intent(in)           :: names_spec
<     integer, dimension(:,:), intent(in)                  :: kminor_activity
< 
<     ! List of minor gases to be used in gas_optics()
<     character(len=32), dimension(:), allocatable         :: get_minor_list
<     ! Logical flag for minor species in specification (T = minor; F = not minor)
<     logical, dimension(size(names_spec))                 :: gas_is_present
<     integer                                              :: igas, icnt
< 
<     if (allocated(get_minor_list)) deallocate(get_minor_list)
<     do igas = 1, this%get_ngas()
<       gas_is_present(igas) = string_in_array(names_spec(igas), gas_desc%gas_name)
<     end do 
<     icnt = count(gas_is_present)
<     allocate(get_minor_list(icnt))
<     get_minor_list(:) = pack(this%gas_names, mask=gas_is_present)
< 
< 
<   end function get_minor_list
< 
<   !--------------------------------------------------------------------------------------------------------------------
<   !
<   ! Inquiry functions 
<   !
<   !--------------------------------------------------------------------------------------------------------------------
<   ! return true if initialized, false otherwise
<   pure function is_initialized(this)
<     class(ty_gas_optics_specification), intent(in) :: this
<     logical                                        :: is_initialized
<     is_initialized = allocated(this%gas_names)
<   end function is_initialized
<   !--------------------------------------------------------------------------------------------------------------------
< 
<   ! return true if initialized for internal sources, false otherwise
<   pure function is_internal_source_present(this)
<     class(ty_gas_optics_specification), intent(in) :: this
<     logical                                        :: is_internal_source_present
<     is_internal_source_present = allocated(this%totplnk).and.allocated(this%planck_frac)
<   end function is_internal_source_present
<   !--------------------------------------------------------------------------------------------------------------------
< 
<   ! return true if initialized for external sources, false otherwise
<   pure function is_external_source_present(this)
<     class(ty_gas_optics_specification), intent(in) :: this
<     logical                                        :: is_external_source_present
<     is_external_source_present = allocated(this%solar_src)
<   end function is_external_source_present
< 
<   !--------------------------------------------------------------------------------------------------------------------
<   ! return the minimum pressure on the interpolation grids
<   pure function get_press_ref_min(this)
<     class(ty_gas_optics_specification), intent(in) :: this
<     real(wp)                                       :: get_press_ref_min
< 
<     get_press_ref_min = this%press_ref_min
<   end function get_press_ref_min
< 
<   !--------------------------------------------------------------------------------------------------------------------
<   ! return the maximum pressure on the interpolation grids
<   pure function get_press_ref_max(this)
<     class(ty_gas_optics_specification), intent(in) :: this
<     real(wp)                                       :: get_press_ref_max
< 
<     get_press_ref_max = this%press_ref_max
<   end function get_press_ref_max
< 
<   !--------------------------------------------------------------------------------------------------------------------
<   ! return the minimum temparature on the interpolation grids
<   pure function get_temp_ref_min(this)
<     class(ty_gas_optics_specification), intent(in) :: this
<     real(wp)                                       :: get_temp_ref_min
< 
<     get_temp_ref_min = this%temp_ref_min
<   end function get_temp_ref_min
< 
<   !--------------------------------------------------------------------------------------------------------------------
<   ! return the maximum temparature on the interpolation grids
<   pure function get_temp_ref_max(this)
<     class(ty_gas_optics_specification), intent(in) :: this
<     real(wp)                                       :: get_temp_ref_max
< 
<     get_temp_ref_max = this%temp_ref_max
<   end function get_temp_ref_max
< 
<   !--------------------------------------------------------------------------------------------------------------------
<   ! return the first and last g-point of all the bands at once
<   ! dimension (2, nbands) 
<   ! 
<   pure function get_band_gpoint_limits(this)
<     class(ty_gas_optics_specification), intent(in) :: this
<     integer, dimension(size(this%band2gpt,dim=1), size(this%band2gpt,dim=2)) & 
<                                                    :: get_band_gpoint_limits
< 
<     get_band_gpoint_limits = this%band2gpt
<   end function get_band_gpoint_limits
< 
<   !--------------------------------------------------------------------------------------------------------------------
<   ! return the first and last g-point of a band
<   pure function convert_band2gpt(this, band)
<     class(ty_gas_optics_specification), intent(in) :: this
<     integer,                            intent(in) :: band
<     integer, dimension(2)                         :: convert_band2gpt
< 
<     convert_band2gpt(:) = this%band2gpt(:,band)
<   end function convert_band2gpt
< 
<   !--------------------------------------------------------------------------------------------------------------------
<   ! return the lower and upper wavenumber of a band
<   ! (upper and lower wavenumber by band) = band_lims_wavenum(2,band)
<   pure function get_band_lims_wavenumber(this)
<     class(ty_gas_optics_specification), intent(in) :: this
<     real(wp), dimension(size(this%band_lims_wavenum,1), size(this%band_lims_wavenum,2)) & 
<                                                    :: get_band_lims_wavenumber
< 
<     get_band_lims_wavenumber(:,:) = this%band_lims_wavenum(:,:)
<   end function get_band_lims_wavenumber
< 
<   !--------------------------------------------------------------------------------------------------------------------
<   ! return the lower and upper wavelength of a band
<   pure function get_band_lims_wavelength(this)
<     class(ty_gas_optics_specification), intent(in) :: this
<     real(wp), dimension(size(this%band_lims_wavenum,1), size(this%band_lims_wavenum,2)) & 
<                                                    :: get_band_lims_wavelength
< 
<     get_band_lims_wavelength(:,:) = 1._wp/this%band_lims_wavenum(:,:)
<   end function get_band_lims_wavelength
< 
<   !--------------------------------------------------------------------------------------------------------------------
<   ! return the bands of all the g-points at once
<   ! dimension (ngpt) 
<   ! 
<   pure function get_gpoint_bands(this)
<     class(ty_gas_optics_specification), intent(in) :: this
<     integer, dimension(size(this%gpt2band,dim=1)) & 
<                                                    :: get_gpoint_bands
< 
<     get_gpoint_bands(:) = this%gpt2band(:)
<   end function get_gpoint_bands
< 
<   !--------------------------------------------------------------------------------------------------------------------
<   ! return the band of a g-point
<   pure function convert_gpt2band(this, gpt)
<     class(ty_gas_optics_specification), intent(in) :: this
<     integer,                            intent(in) :: gpt
<     integer                                        :: convert_gpt2band
< 
<     convert_gpt2band = this%gpt2band(gpt)
<   end function convert_gpt2band
< 
<   !--------------------------------------------------------------------------------------------------------------------
<   ! The result is the band_value multiplied by the corresponding g-point weight.
<   ! We use knowledge of the starting and ending g-point for each band to know the values of i and j in
<   ! weight_bandvals_by_gpoint(j) = gpt_weights(j) * band_vals(i)
<   pure function weight_bandvals_by_gpoint(this, gpt_weights)
<     class(ty_gas_optics_specification),     intent(in) :: this
<     real(wp), dimension(:),                 intent(in) :: gpt_weights ! dim(# of g-points)
<     real(wp), dimension(size(this%gpoint_flavor,dim=2)) :: weight_bandvals_by_gpoint
< 
<     integer :: iband, igpt
< 
<     do iband=1,this%get_nband()
<       do igpt=this%band2gpt(1,iband), this%band2gpt(2,iband)
<         weight_bandvals_by_gpoint = gpt_weights(igpt) * iband
<       end do
<     end do
<   end function weight_bandvals_by_gpoint
< 
<   !--------------------------------------------------------------------------------------------------------------------
<   ! expands an array of dimension arr_in(nband) to dimension arr_out(ngpt)
<   pure function expand(this, arr_in) result(arr_out)
<     class(ty_gas_optics_specification), intent(in) :: this
<     real(wp), dimension(:), intent(in) :: arr_in ! (nband)
<     real(wp), dimension(size(this%gpoint_flavor,dim=2)) :: arr_out
<     integer :: iband
<     do iband=1,this%get_nband()
<       arr_out(this%band2gpt(1,iband):this%band2gpt(2,iband)) = arr_in(iband)
<     end do
<   end function expand
< 
< 
<   !--------------------------------------------------------------------------------------------------------------------
<   ! --- gas optical depth calculations
<   !--------------------------------------------------------------------------------------------------------------------
<   ! Utility function, provided for user convenience
<   ! computes column amounts of dry air using hydrostatic equation
<   function get_col_dry(vmr_h2o, plev, tlay, latitude) result(col_dry)
<     ! input
<     real(wp), dimension(:,:), intent(in) :: vmr_h2o  ! volume mixing ratio of all gases excluding water; (ncol,nlay)
<     real(wp), dimension(:,:), intent(in) :: plev     ! Layer boundary pressures [hPa, mb] (ncol,nlay+1)
<     real(wp), dimension(:,:), intent(in) :: tlay     ! Layer temperatures [K] (ncol,nlay)
<     real(wp), dimension(:),   optional, &
<                               intent(in) :: latitude ! Latitude [degrees] (ncol)
<     ! output
<     real(wp), dimension(size(tlay,dim=1),size(tlay,dim=2)) :: col_dry ! Column dry amount (ncol,nlay)
<     ! ------------------------------------------------
<     ! first and second term of Helmert formula
<     real(wp), parameter :: helmert1 = 9.80665_wp
<     real(wp), parameter :: helmert2 = 0.02586_wp
<     ! local variables
<     real(wp), dimension(size(tlay,dim=1)                 ) :: g0 ! (ncol)
<     real(wp), dimension(size(tlay,dim=1),size(tlay,dim=2)) :: delta_plev ! (ncol,nlay)
<     real(wp), dimension(size(tlay,dim=1),size(tlay,dim=2)) :: m_air ! average mass of air; (ncol,nlay)
<     integer :: nlev, nlay
<     ! ------------------------------------------------
<     nlay = size(tlay, dim=2)
<     nlev = size(plev, dim=2)
< 
<     if(present(latitude)) then
<       g0(:) = helmert1 - helmert2 * cos(2.0_wp * pi * latitude(:) / 180.0_wp) ! acceleration due to gravity [m/s^2]
<     else
<       g0(:) = grav
<     end if
<     delta_plev(:,:) = plev(:,1:nlev-1) - plev(:,2:nlev)
< 
<     ! Get average mass of air
<     m_air(:,:) = (m_dry+m_h2o*vmr_h2o(:,:))/(1.+vmr_h2o(:,:))
< 
<     ! Hydrostatic equation
<     col_dry(:,:) = 1000._wp*delta_plev(:,:)*avogad/(1000._wp*m_air(:,:)*100._wp*spread(g0(:),dim=2,ncopies=nlay))
<     col_dry(:,:) = col_dry(:,:)/(1._wp+vmr_h2o(:,:))
<   end function get_col_dry
<   !--------------------------------------------------------------------------------------------------------------------
<   !
<   ! Internal procedures 
<   ! 
<   !--------------------------------------------------------------------------------------------------------------------
<   pure function rewrite_key_species_pair(key_species_pair)
<     ! (x,0) becomes (x,x)
<     ! (0,0) becomes (2,2) -- because absorption coefficients for these g-points will be 0. 
<     integer, dimension(2) :: rewrite_key_species_pair
<     integer, dimension(2), intent(in) :: key_species_pair
<     rewrite_key_species_pair = key_species_pair
<     if (key_species_pair(2).eq.0) then
<       rewrite_key_species_pair(2) = key_species_pair(1)
<     end if
<     if (all(key_species_pair(:).eq.(/0,0/))) then
<       rewrite_key_species_pair(:) = (/2,2/)
<     end if
<   end function
< 
<   ! ---------------------------------------------------------------------------------------
<   ! true is key_species_pair exists in key_species_list
<   pure function key_species_pair_exists(key_species_list, key_species_pair)
<     logical :: key_species_pair_exists
<     integer, dimension(:,:), intent(in) :: key_species_list
<     integer, dimension(2), intent(in) :: key_species_pair
<     integer :: i
<     do i=1,size(key_species_list,dim=2)
<       if (all(key_species_list(:,i).eq.key_species_pair(:))) then
<         key_species_pair_exists = .true.
<         return
<       end if
<     end do
<     key_species_pair_exists = .false.
<   end function key_species_pair_exists
< 
<   ! ---------------------------------------------------------------------------------------
<   ! create flavor list -- 
<   !   an unordered array of extent (2,:) containing all possible pairs of key species 
<   !   used in either upper or lower atmos
<   !
<   subroutine create_flavor(key_species, flavor)
<     integer, dimension(:,:,:), intent(in) :: key_species
<     integer, dimension(:,:), allocatable, intent(out) :: flavor
<     integer, dimension(2,size(key_species,3)*2) :: key_species_list
< 
<     integer :: ibnd, iatm, i, iflavor
<     ! prepare list of key_species
<     i = 1
<     do ibnd=1,size(key_species,3)
<       do iatm=1,size(key_species,1)
<         key_species_list(:,i) = key_species(:,iatm,ibnd)
<         i = i + 1
<       end do
<     end do
<     ! rewrite single key_species pairs
<     do i=1,size(key_species_list,2)
<         key_species_list(:,i) = rewrite_key_species_pair(key_species_list(:,i))
<     end do
<     ! count unique key species pairs
<     iflavor = 0
<     do i=1,size(key_species_list,2)
<       if (.not.key_species_pair_exists(key_species_list(:,1:i-1),key_species_list(:,i))) then
<         iflavor = iflavor + 1
<       end if
<     end do
<     ! fill flavors
<     allocate(flavor(2,iflavor))
<     iflavor = 0
<     do i=1,size(key_species_list,2)
<       if (.not.key_species_pair_exists(key_species_list(:,1:i-1),key_species_list(:,i))) then
<         iflavor = iflavor + 1
<         flavor(:,iflavor) = key_species_list(:,i)
<       end if
<     end do
<   end subroutine create_flavor
< ! ---------------------------------------------------------------------------------------
< 
<   ! returns flavor index; -1 if not found
<   pure function key_species_pair2flavor(flavor, key_species_pair)
<     integer :: key_species_pair2flavor
<     integer, dimension(:,:), intent(in) :: flavor
<     integer, dimension(2), intent(in) :: key_species_pair
<     integer :: iflav
<     do iflav=1,size(flavor,2)
<       if (all(key_species_pair(:).eq.flavor(:,iflav))) then
<         key_species_pair2flavor = iflav
<         return
<       end if
<     end do
<     key_species_pair2flavor = -1
<   end function key_species_pair2flavor
< 
<   ! ---------------------------------------------------------------------------------------
<   ! create gpoint_flavor list
<   !   a map pointing from each g-point to the corresponding entry in the "flavor list" 
<   !
<   subroutine create_gpoint_flavor(key_species, gpt2band, flavor, gpoint_flavor)
<     integer, dimension(:,:,:), intent(in) :: key_species
<     integer, dimension(:), intent(in) :: gpt2band
<     integer, dimension(:,:), intent(in) :: flavor
<     integer, dimension(:,:), intent(out), allocatable :: gpoint_flavor
<     integer :: ngpt, igpt, iatm
<     ngpt = size(gpt2band)
<     allocate(gpoint_flavor(2,ngpt))
<     do igpt=1,ngpt
<       do iatm=1,2
<         gpoint_flavor(iatm,igpt) = key_species_pair2flavor( &
<           flavor, &
<           rewrite_key_species_pair(key_species(:,iatm,gpt2band(igpt))) &
<         )
<       end do
<     end do
<   end subroutine create_gpoint_flavor
< 
<   !--------------------------------------------------------------------------------------------------------------------
<   ! create gpt2band -- a map from g-points to bands 
<   !   includes allocating the result 
<   ! 
<   subroutine create_gpt2band(band2gpt, gpt2band)
<     integer, dimension(:,:), intent(in) :: band2gpt
<     integer, dimension(:), allocatable, intent(out) :: gpt2band
<     integer :: iband, ngpt
<     ngpt = maxval(band2gpt)
<     allocate(gpt2band(ngpt))
<     do iband=1,size(band2gpt,dim=2)
<       gpt2band(band2gpt(1,iband):band2gpt(2,iband)) = iband
<     end do
<   end subroutine create_gpt2band
< 
<  !--------------------------------------------------------------------------------------------------------------------
<  !
<  ! Utility function to combine optical properties for absorption and Rayleigh scattering 
<  !   (and reorder them for convenience, while we're at it) 
<  !
<  subroutine combine_and_reorder(tau, tau_rayleigh, has_rayleigh, optical_props) 
<     real(wp), dimension(:,:,:), intent(in) :: tau
<     real(wp), dimension(:,:,:), intent(in) :: tau_rayleigh
<     logical,                    intent(in) :: has_rayleigh
<     class(ty_optical_props),    intent(inout) :: optical_props
<     
<     integer :: icol, ilay, igpt, ncol, nlay, ngpt
<     
<     ncol = size(tau, 3) 
<     nlay = size(tau, 2) 
<     ngpt = size(tau, 1)
<      
<     if (.not. has_rayleigh) then
<       ! index reorder (ngpt, nlay, ncol) -> (ncol,nlay,gpt)
<       optical_props%tau = reorder123x321(tau)
<     else
<       ! combine optical depth and rayleigh scattering
<       select type(optical_props)
<         type is (ty_optical_props)
<           ! User is asking for absorption optical depth 
<           optical_props%tau = reorder123x321(tau)
<         type is (ty_optical_props_2str) 
<           do icol = 1, ncol
<             do ilay = 1, nlay
<               do igpt = 1, ngpt 
<                 optical_props%tau(icol,ilay,igpt) = tau(igpt,ilay,icol) + tau_rayleigh(igpt,ilay,icol)
<                 optical_props%ssa(icol,ilay,igpt) = tau_rayleigh(igpt,ilay,icol) / optical_props%tau(icol,ilay,igpt)
<               end do 
<             end do 
<           end do 
<           optical_props%g = 0._wp 
<         type is (ty_optical_props_nstr) ! We ought to be able to combine this with above
<           do icol = 1, ncol
<             do ilay = 1, nlay
<               do igpt = 1, ngpt 
<                 optical_props%tau(icol,ilay,igpt) = tau(igpt,ilay,icol) + tau_rayleigh(igpt,ilay,icol)
<                 optical_props%ssa(icol,ilay,igpt) = tau_rayleigh(igpt,ilay,icol) / optical_props%tau(icol,ilay,igpt)
<               end do 
<             end do 
<           end do 
<           optical_props%p = 0._wp
<           optical_props%p(2,:,:,:) = 0.1_wp 
<       end select
<       
<     end if
<   end subroutine combine_and_reorder
< 
<   !--------------------------------------------------------------------------------------------------------------------
<   ! return the number of reference pressure layers
<   pure function get_nlay_ref(this)
<     class(ty_gas_optics_specification), intent(in) :: this
<     integer                                        :: get_nlay_ref
< 
<     get_nlay_ref = size(this%kmajor,dim=3)
<   end function get_nlay_ref
< 
<   !--------------------------------------------------------------------------------------------------------------------
<   ! return eta dimension
<   pure function get_neta(this)
<     class(ty_gas_optics_specification), intent(in) :: this
<     integer                                        :: get_neta
< 
<     get_neta = size(this%selfrefin,dim=2)
<   end function
< 
<   !--------------------------------------------------------------------------------------------------------------------
<   ! fills kminor_activity; a list where minor species are active
<   !   looks to see for which entires the absorption coefficients are zero at all p, eta
<   !   compiles a list of extent (2, N) where each entry is (gpt, minor_gas_index) 
<   ! 
<   subroutine fill_kminor_activity(this)
<     class(ty_gas_optics_specification) :: this
< 
<     integer :: igpt, imnr, ilist, ngpt, nmnr, nlist
< 
<     ngpt = this%get_ngpt()
<     nmnr = size(this%kminor_lower, dim=1)
<     nlist = 0
<     ! determine array length
<     do igpt = 1, ngpt
<       do imnr = 1, nmnr
<         if (sum(this%kminor_lower(imnr,igpt,:,:))+sum(this%kminor_upper(imnr,igpt,:,:)) .gt. 1.E-40_wp) then
<           nlist = nlist + 1
<         end if
<       end do
<     end do
<     ! fill an array with (g-point, minor-gas) tuples
<     ilist = 0
<     if (allocated(this%kminor_activity)) deallocate(this%kminor_activity)
<     allocate(this%kminor_activity(2,nlist))
<     do igpt = 1, ngpt
<       do imnr = 1, nmnr
<         if (sum(this%kminor_lower(imnr,igpt,:,:))+sum(this%kminor_upper(imnr,igpt,:,:)) .gt. 1.E-40_wp) then
<           ilist = ilist + 1
<           this%kminor_activity(:,ilist) = (/ igpt,imnr /)
<         end if
<       end do
<     end do
<   end subroutine fill_kminor_activity
<   !--------------------------------------------------------------------------------------------------------------------
<   ! Generic procedures for checking sizes, limits
<   !--------------------------------------------------------------------------------------------------------------------
<   !
<   ! Extents 
<   !
<   function check_extent_1d(array, nx, label) 
<     real(wp), dimension(:),     intent(in) :: array
<     integer,                    intent(in) :: nx
<     character(len=*),           intent(in) :: label 
<     character(len=128)                     :: check_extent_1d
<   
<     check_extent_1d = "" 
<     if(size(array,1) /= nx) & 
<       check_extent_1d = trim(label) // ' has incorrect size.' 
<   end function check_extent_1d
<   ! --------------------------------------------------------------------------------------
<   function check_extent_2d(array, nx, ny, label) 
<     real(wp), dimension(:,:),   intent(in) :: array
<     integer,                    intent(in) :: nx, ny 
<     character(len=*),           intent(in) :: label 
<     character(len=128)                     :: check_extent_2d
<   
<     check_extent_2d = "" 
<     if(size(array,1) /= nx .or. size(array,2) /= ny) & 
<       check_extent_2d = trim(label) // ' has incorrect size.' 
<   end function check_extent_2d
<   ! --------------------------------------------------------------------------------------
<   function check_extent_3d(array, nx, ny, nz, label) 
<     real(wp), dimension(:,:,:), intent(in) :: array
<     integer,                    intent(in) :: nx, ny, nz
<     character(len=*),           intent(in) :: label 
<     character(len=128)                     :: check_extent_3d
<   
<     check_extent_3d = "" 
<     if(size(array,1) /= nx .or. size(array,2) /= ny .or. size(array,3) /= nz) & 
<       check_extent_3d = trim(label) // ' has incorrect size.' 
<   end function check_extent_3d
<   ! --------------------------------------------------------------------------------------
<   !
<   ! Values 
<   !
<   ! --------------------------------------------------------------------------------------
<   function check_range_1D(val, minV, maxV, label)
<     real(wp), dimension(:),     intent(in) :: val
<     real(wp),                   intent(in) :: minV, maxV
<     character(len=*),           intent(in) :: label 
<     character(len=128)                     :: check_range_1D
<     
<     check_range_1D = ""
<     if(any(val < minV) .or. any(val > maxV)) & 
<       check_range_1D = trim(label) // ' values out of range.' 
<   end function check_range_1D
<   ! --------------------------------------------------------------------------------------
<   function check_range_2D(val, minV, maxV, label)
<     real(wp), dimension(:,:),   intent(in) :: val
<     real(wp),                   intent(in) :: minV, maxV
<     character(len=*),           intent(in) :: label 
<     character(len=128)                     :: check_range_2D
<     
<     check_range_2D = ""
<     if(any(val < minV) .or. any(val > maxV)) & 
<       check_range_2D = trim(label) // ' values out of range.' 
<   end function check_range_2D
<   ! --------------------------------------------------------------------------------------
<   function check_range_3D(val, minV, maxV, label)
<     real(wp), dimension(:,:,:), intent(in) :: val
<     real(wp),                   intent(in) :: minV, maxV
<     character(len=*),           intent(in) :: label 
<     character(len=128)                     :: check_range_3D
<     
<     check_range_3D = ""
<     if(any(val < minV) .or. any(val > maxV)) & 
<       check_range_3D = trim(label) // ' values out of range.' 
<   end function check_range_3D
<   !------------------------------------------------------------------------------------------
< 
< 
< end module mo_gas_optics_specification
---
> !KGEN-generated Fortran source file 
>   
> !Generated at : 2017-06-01 10:39:46 
> !KGEN version : 0.7.3 
>   
> ! Module: mo_gas_optics_specification
> 
> ! This code is part of
> ! RRTM for GCM Applications - Parallel (RRTMGP)
> !
> ! Eli Mlawer and Robert Pincus
> ! Andre Wehe and Jennifer Delamere
> ! email:  rrtmgp@aer.com
> !
> ! Copyright 2015,  Atmospheric and Environmental Research and
> ! Regents of the University of Colorado.  All right reserved.
> !
> ! Use and duplication is permitted under the terms of the
> !    BSD 3-clause license, see http://opensource.org/licenses/BSD-3-Clause
> !
> ! Description:  Specifies all properties related to the k-distributions.  This includes each band's spectral properties and
> ! absorbing gases.
> 
> module mo_gas_optics_specification
>     USE mo_rrtmgp_kind, ONLY: wp 
>     USE mo_rrtmgp_constants, ONLY: avogad, pi, m_dry, m_h2o, grav 
>     USE mo_gas_optics_kernels, ONLY: interpolation, gas_optical_depths_major, gas_optical_depths_continuum, &
>     &gas_optical_depths_minor, gas_optical_depths_rayleigh, source 
>     USE mo_util_string, ONLY: lower_case, string_in_array, string_loc_in_array 
>     USE mo_gas_concentrations, ONLY: ty_gas_concs 
>     USE mo_optical_props, ONLY: ty_optical_props, ty_optical_props_2str, ty_optical_props_nstr 
>     USE mo_util_reorder 
>     USE kgen_utils_mod, ONLY: kgen_dp, kgen_array_sumcheck 
>     USE tprof_mod, ONLY: tstart, tstop, tnull, tprnt 
>     USE mo_gas_concentrations, ONLY: kr_mo_gas_concentrations_ty_gas_concs 
>     USE mo_optical_props, ONLY: kr_mo_optical_props_ty_optical_props 
>     USE mo_optical_props, ONLY: kr_mo_optical_props_ty_optical_props_2str 
>     USE mo_optical_props, ONLY: kr_mo_optical_props_ty_optical_props_nstr 
>     USE mo_gas_concentrations, ONLY: kv_mo_gas_concentrations_ty_gas_concs 
>     USE mo_optical_props, ONLY: kv_mo_optical_props_ty_optical_props 
>     USE mo_optical_props, ONLY: kv_mo_optical_props_ty_optical_props_2str 
>     USE mo_optical_props, ONLY: kv_mo_optical_props_ty_optical_props_nstr 
>     USE kgen_utils_mod, ONLY: check_t, kgen_init_check, kgen_tolerance, kgen_minvalue, CHECK_IDENTICAL, CHECK_IN_TOL, &
>     &CHECK_OUT_TOL 
>     IMPLICIT NONE 
>     PRIVATE 
> 
>   ! -----------------------------------------------------------------------------------
>   type, public :: ty_gas_optics_specification
>     private
>     character(32), & 
>               dimension(:),   allocatable :: gas_names  ! gas names
> 
>     integer,  dimension(:,:), allocatable :: flavor        ! major species pair; (2,nflav)
>     integer,  dimension(:,:), allocatable :: gpoint_flavor ! flavor = gpoint_flavor(lower or upper atmosphere, g-point)
> 
>     integer,  dimension(:,:), allocatable :: band2gpt       ! (begin g-point, end g-point) = band2gpt(2,band)
>     integer,  dimension(:),   allocatable :: gpt2band       ! band = gpt2band(g-point)
> 
>     real(wp), dimension(:,:), allocatable :: band_lims_wavenum  ! (upper and lower wavenumber by band) = band_lims_wavenum(2,band)
>     ! -----------------------------------------------------------------------------------
>     ! Temperature and pressure interpolation grids 
>     real(wp), dimension(:),  allocatable :: press_ref,  press_ref_log, temp_ref
>     ! volume mixing ratios for reference atmosphere; vmr_ref(lower or upper atmosphere, gas, temp)
>     real(wp), dimension(:,:,:), allocatable :: vmr_ref
> 
>     real(wp) :: press_ref_min, press_ref_max, &  ! min and max pressure of interpolation grids
>                 temp_ref_min,  temp_ref_max      ! min and max temperature 
>     real(wp) :: press_ref_log_delta, & ! difference in ln pressure between consecutive reference levels
>                 temp_ref_delta,      & ! Temperature difference between consecutive reference levels
>                 press_ref_trop_log     ! log of reference pressure separating the lower and upper atmosphere
>     real(wp) :: stpfac                 ! standard pressure:temperature ratio
>     ! -----------------------------------------------------------------------------------
>     ! Absorption coefficients
>       ! ----- major gas absorption coefficients ; kmajor(g-point,eta,pressure,temperature)
>     real(wp), dimension(:,:,:,:), allocatable :: kmajor
>     ! ----- water vapor continuum
>       ! stored absorption coefficients due to water vapor self continuum; selfrefin(eta,temperature,g-point)
>     real(wp), dimension(:,:,:),   allocatable :: selfrefin, forrefin
>     ! ----- minor species
>       ! stored absorption coefficients due to minor absorbing gases in lower/upper part of atmosphere;
>       ! kminor_lower(minor_gas,g-point,eta,temperature)
>     real(wp), dimension(:,:,:,:), allocatable :: kminor_lower, kminor_upper
>     ! -----------------------------------------------------------------------------------
>     ! ----- Rayleigh scattering
>       ! stored scattering coefficients due to molecules in atmosphere;
>       ! krayl(g-point,eta,temperature,upper/lower atmosphere)
>     real(wp), dimension(:,:,:,:), allocatable :: krayl
>     ! -----------------------------------------------------------------------------------
>     ! Planck function spectral mapping
>     !   Allocated only when gas optics object is internal-source "flavor" 
>     !
>     real(wp), dimension(:,:,:,:), allocatable :: planck_frac   ! input Planck fractions
>                                                                ! planck_frac(eta,temperature,pressure,g-point)
>     real(wp), dimension(:,:),     allocatable :: totplnk       ! integrated Planck function by band; (reference temperatures,band)
>     real(wp)                                  :: totplnk_delta ! temperature steps in totplnk
>     ! -----------------------------------------------------------------------------------
>     ! Solar source function spectral mapping 
>     !   Allocated only when gas optics object is external-source "flavor" 
>     !
>     real(wp), dimension(:), allocatable :: solar_src ! solar source
>     ! -----------------------------------------------------------------------------------
>     ! Ancillary
>     ! computed by fill_kminor_activity(); g-points where minor gases are active; (g-point, minor gas) = kminor_activity(2,:)
>     integer, dimension(:,:), allocatable :: kminor_activity
>     ! -----------------------------------------------------------------------------------
>     ! Index into %gas_names -- is this a key species in any band? 
>     logical, dimension(:), allocatable :: is_key
>     ! -----------------------------------------------------------------------------------
> 
>   contains
>     ! Type-bound procedures
>     ! Public procedures
>     ! public interface
>     generic, public :: init       => init_int,       init_ext
>     generic, public :: gas_optics => gas_optics_int, gas_optics_ext
>     procedure, public :: is_initialized
>     procedure, public :: is_internal_source_present
>     procedure, public :: is_external_source_present
>     procedure, public :: weight_bandvals_by_gpoint
>     procedure, public :: expand
>     procedure, public :: get_ngas
>     procedure, public :: get_gases
>     procedure, public :: get_nband
>     procedure, public :: get_ngpt
>     procedure, public :: get_press_ref_min
>     procedure, public :: get_press_ref_max
>     procedure, public :: get_temp_ref_min
>     procedure, public :: get_temp_ref_max
>     ! The following functions describe the spectral discretization. Probably we want init functions too
>     ! These are associated with three components of the type 
>     procedure, public :: get_band_gpoint_limits
>     procedure, public :: get_gpoint_bands
>     procedure, public :: convert_band2gpt
>     procedure, public :: convert_gpt2band
>     procedure, public :: get_band_lims_wavenumber
>     procedure, public :: get_band_lims_wavelength
>     ! Internal procedures
>     procedure, public :: init_int
>     procedure, public :: init_ext
>     procedure, public :: gas_optics_int
>     procedure, public :: gas_optics_ext
>     procedure, public :: check_key_species_present
>     procedure, public :: get_minor_list
>     procedure, private :: fill_kminor_activity
>     procedure, private :: get_nflav
>     procedure, private :: get_nlay_ref
>     procedure, private :: get_neta
>     procedure, private :: compute_gas_tau_core
>   end type
>   ! -----------------------------------------------------------------------------------
>   PUBLIC get_col_dry 
> 
>   interface check_range
>     module procedure check_range_1D, check_range_2D, check_range_3D 
>   end interface check_range
> 
>   interface check_extent
>     module procedure check_extent_1D, check_extent_2D, check_extent_3D 
>   end interface check_extent
>   PUBLIC kr_mo_gas_concentrations_ty_gas_concs 
>   PUBLIC kr_mo_optical_props_ty_optical_props 
>   PUBLIC kr_mo_optical_props_ty_optical_props_2str 
>   PUBLIC kr_mo_optical_props_ty_optical_props_nstr 
>   PUBLIC kr_kgen_mo_gas_optics_specification_typesubp0 
>   PUBLIC kv_mo_gas_concentrations_ty_gas_concs 
>   PUBLIC kv_mo_optical_props_ty_optical_props 
>   PUBLIC kv_mo_optical_props_ty_optical_props_2str 
>   PUBLIC kv_mo_optical_props_ty_optical_props_nstr 
>   PUBLIC kv_kgen_mo_gas_optics_specification_typesubp0 
> contains
>   ! --------------------------------------------------------------------------------------
>   !
>   ! Public procedures
>   !
>   ! --------------------------------------------------------------------------------------
>   !
>   ! Two functions to define array sizes needed by gas_optics() 
>   !
>   pure function get_ngas(this)
>     ! return the number of gases registered in the spectral configuration
>     class(ty_gas_optics_specification), intent(in) :: this
>     integer                                        :: get_ngas
> 
>     get_ngas = size(this%gas_names)
>   end function get_ngas
>   !--------------------------------------------------------------------------------------------------------------------
>   pure function get_nflav(this)
>     ! return the number of major species pairs
>     class(ty_gas_optics_specification), intent(in) :: this
>     integer                                        :: get_nflav
> 
>     get_nflav = size(this%flavor,dim=2)
>   end function get_nflav
>   !--------------------------------------------------------------------------------------------------------------------
>   ! return the gas names
>   pure function get_gases(this)
>     class(ty_gas_optics_specification), intent(in) :: this
>     character(32), dimension(this%get_ngas())     :: get_gases
> 
>     get_gases = this%gas_names
>   end function get_gases
>   !--------------------------------------------------------------------------------------------------------------------
>   ! return the number of bands
>   pure function get_nband(this)
>     class(ty_gas_optics_specification), intent(in) :: this
>     integer                                        :: get_nband
> 
>     get_nband = size(this%band2gpt,dim=2)
>   end function get_nband
> 
>   !--------------------------------------------------------------------------------------------------------------------
>   ! return the number of g-points
>   pure function get_ngpt(this)
>     class(ty_gas_optics_specification), intent(in) :: this
>     integer                                        :: get_ngpt
> 
>     get_ngpt = size(this%gpoint_flavor,dim=2)
>   end function get_ngpt
>   !--------------------------------------------------------------------------------------------------------------------
> 
> 
>   ! Compute gas optical depth and, optionally, Planck source functions,
>   !  given temperature, pressure, and composition
>   function gas_optics_int(this,                                   &
>                       play, plev, tlay, tsfc, gas_desc,           & ! mandatory inputs
>                       optical_props,                              & ! mandatory outputs
>                       lay_src, lev_src_inc, lev_src_dec, sfc_src, & ! internal-source specific outputs
>                       col_dry, tlev)                              & ! optional inputs
>                       result(error_msg)
>     ! inputs
>     class(ty_gas_optics_specification), intent(in) :: this
>     real(wp), dimension(:,:), intent(in   ) :: play, &   ! layer pressures [hPa, mb]; (ncol,nlay)
>                                                plev, &   ! level pressures [hPa, mb]; (ncol,nlay+1)
>                                                tlay      ! layer temperatures [K]; (ncol,nlay)
>     real(wp), dimension(:),   intent(in   ) :: tsfc      ! surface skin temperatures [K]; (ncol)
>     type(ty_gas_concs),       intent(in   ) :: gas_desc  ! Gas volume mixing ratios
>     ! output
>     class(ty_optical_props),  intent(inout) :: optical_props
>     character(len=128)                      :: error_msg
>     ! source functions (LW only)
>     ! These include spectral weighting that accounts for state-dependent frequency to k-distribution mapping
>     ! [W/m2] 
>     real(wp), dimension(:,:,:), intent(  out) :: lay_src, &  ! source for average layer temperature; (ncol,nlay,ngpt)
>                                                  lev_src_inc, lev_src_dec  
>                                                              ! level source radiances in increasing/decreasing 
>                                                              ! ilay direction (ncol,nlay+1,ngpt)
>     real(wp), dimension(:,:),   intent(  out) :: sfc_src     ! Surface Planck source; (ncol,ngpts)
>     ! Optional inputs
>     real(wp), dimension(:,:),   intent(in   ), &
>                            optional, target :: col_dry, &  ! Column dry amount; dim(ncol,nlay)
>                                                tlev        ! level temperatures [K]l (ncol,nlay+1)
>     ! ----------------------------------------------------------
>     ! Local variables
>     ! Interpolation coefficients to save for use in source function 
>     integer,  dimension(size(play,dim=1), size(play,dim=2)) :: jtemp, jpress
>     logical,  dimension(size(play,dim=1), size(play,dim=2)) :: tropo
>     real(wp), dimension(2,2,2,this%get_nflav(),size(play,dim=1), size(play,dim=2)) :: fmajor
>     integer,  dimension(2,    this%get_nflav(),size(play,dim=1), size(play,dim=2)) :: jeta
>     ! Temporary 
>     real(wp), dimension(this%get_ngpt(),                   size(play,dim=1)) :: sfc_src_t
>     real(wp), dimension(this%get_ngpt(),size(play,dim=2),  size(play,dim=1)) :: lay_src_t
>     real(wp), dimension(this%get_ngpt(),size(play,dim=2)+1,size(play,dim=1)) :: lev_src_inc_t, lev_src_dec_t
>     ! ----------------------------------------------------------
>     ! dimensions - determined from problem size
>     integer :: ncol, nlay ! number of columns, layers
>     ! dimensions - provided by k-distribution
>     integer :: ngpt, nband, ngas, nflav ! Number of g-points, bands, gas, gas "flavors" (major species combinations) 
> 
>     ! index
>     integer :: icol, ilay, igpt, igas
> 
>     ! Variables for temperature at layer edges
>     ! [K] (ncol, nlay+1)
>     real(wp), dimension(size(play,dim=1),size(play,dim=2)+1), target  :: tlev_arr
>     real(wp), dimension(:,:),                                 pointer :: tlev_wk => NULL()
> 
>     ! ----------------------------------------------------------
>     ! Code starts
>     !
>     error_msg = ""
>     error_msg = compute_gas_taus(this,                       &
>                                  play, plev, tlay, gas_desc, & 
>                                  optical_props,              & 
>                                  jtemp, jpress, jeta, tropo, fmajor, & 
>                                  col_dry)    
>     if(error_msg  /= '') return
> 
>     ! init from array dimensions
>     ncol = size(play,dim=1)
>     nlay = size(play,dim=2)
>     ngpt = this%get_ngpt()
>     nband = this%get_nband()
>     ngas = this%get_ngas()
>     nflav = this%get_nflav()
> 
>     !
>     ! Planck source function 
>     !   Check input data sizes and values
>     !
>     error_msg = check_extent(tsfc, ncol, 'tsfc') 
>     if(error_msg  /= '') return
>     error_msg = check_range(tsfc, this%temp_ref_min,  this%temp_ref_max,  'tsfc')
>     if(error_msg  /= '') return
>     if(present(tlev)) then 
>       error_msg = check_extent(tlev, ncol, nlay+1, 'tlev') 
>       if(error_msg  /= '') return
>       error_msg = check_range(tlev, this%temp_ref_min, this%temp_ref_max, 'tlev')
>       if(error_msg  /= '') return
>     end if
>     
>     !
>     !   output extents 
>     !
>     error_msg = check_extent(sfc_src,     ncol,         ngpt, 'sfc_src') 
>     if(error_msg  /= '') return
>     error_msg = check_extent(lay_src,     ncol, nlay,   ngpt, 'lay_src') 
>     if(error_msg  /= '') return
>     error_msg = check_extent(lev_src_inc, ncol, nlay+1, ngpt, 'lev_src_inc') 
>     if(error_msg  /= '') return
>     error_msg = check_extent(lev_src_dec, ncol, nlay+1, ngpt, 'lev_src_dec') 
>     if(error_msg  /= '') return
> 
>     !
>     ! Source function needs temperature at interfaces/levels and at layer centers
>     !
>     if (present(tlev)) then
>       !   Users might have provided these
>       tlev_wk => tlev
>     else
>        tlev_wk => tlev_arr
>        !
>        ! Interpolate temperature to levels if not provided
>        !   Interpolation and extrapolation at boundaries is weighted by pressure
>        !
>        do icol = 1, ncol
>          tlev_arr(icol,1) = tlay(icol,1) &
>                            + (plev(icol,1)-play(icol,1))*(tlay(icol,2)-tlay(icol,1))  &
>               &                                           / (play(icol,2)-play(icol,1))
>        end do
>        do ilay = 2, nlay
>          do icol = 1, ncol
>            tlev_arr(icol,ilay) = (play(icol,ilay-1)*tlay(icol,ilay-1)*(plev(icol,ilay  )-play(icol,ilay)) &
>                                 +  play(icol,ilay  )*tlay(icol,ilay  )*(play(icol,ilay-1)-plev(icol,ilay))) /  &
>                                   (plev(icol,ilay)*(play(icol,ilay-1) - play(icol,ilay)))
>          end do
>        end do
>        do icol = 1, ncol
>          tlev_arr(icol,nlay+1) = tlay(icol,nlay)                                                             &
>                                 + (plev(icol,nlay+1)-play(icol,nlay))*(tlay(icol,nlay)-tlay(icol,nlay-1))  &
>                                                                       / (play(icol,nlay)-play(icol,nlay-1))
>        end do
>      end if
> 
>     call source(ncol, nlay, ngpt, nband, ngas, nflav, &
>                 tlay, tlev_wk, tsfc, merge(1,nlay,play(1,1) > play(1,nlay)), & 
>                 fmajor, jeta, tropo, jtemp, jpress,                    & 
>                 this%band2gpt, this%planck_frac, this%temp_ref_min,    & 
>                 this%totplnk_delta, this%totplnk, this%gpoint_flavor,  &  
>                 sfc_src_t, lay_src_t, lev_src_inc_t, lev_src_dec_t)
>    sfc_src     = reorder12x21  (sfc_src_t)
>    lay_src     = reorder123x321(lay_src_t) 
>    lev_src_inc = reorder123x321(lev_src_inc_t) 
>    lev_src_dec = reorder123x321(lev_src_dec_t) 
>   end function gas_optics_int
>   !------------------------------------------------------------------------------------------
> 
>   ! Compute gas optical depth
>   !  given temperature, pressure, and composition
>   function gas_optics_ext(this,        &
>     play, plev, tlay, gas_desc,        & ! mandatory inputs
>     optical_props, toa_src,            & ! mandatory outputs
>     col_dry) result(error_msg)           ! optional input 
>     
>     class(ty_gas_optics_specification), intent(in) :: this
>     real(wp), dimension(:,:), intent(in   ) :: play, &   ! layer pressures [hPa, mb]; (ncol,nlay)
>                                                plev, &   ! level pressures [hPa, mb]; (ncol,nlay+1)
>                                                tlay      ! layer temperatures [K]; (ncol,nlay)
>     type(ty_gas_concs),       intent(in   ) :: gas_desc  ! Gas volume mixing ratios
>     ! output
>     class(ty_optical_props),  intent(inout) :: optical_props
>     real(wp), dimension(:,:), intent(  out) :: toa_src     ! Top-of-atmosphere flux
>     character(len=128)                      :: error_msg
> 
>     ! Optional inputs
>     real(wp), dimension(:,:), intent(in   ), &
>                            optional, target :: col_dry ! Column dry amount; dim(ncol,nlay)
>     ! ----------------------------------------------------------
>     ! Local variables
>     ! Interpolation coefficients to save for use in source function 
>     integer,  dimension(size(play,dim=1), size(play,dim=2)) :: jtemp, jpress
>     logical,  dimension(size(play,dim=1), size(play,dim=2)) :: tropo
>     real(wp), dimension(2,2,2,this%get_nflav(),size(play,dim=1), size(play,dim=2)) :: fmajor
>     integer,  dimension(2,    this%get_nflav(),size(play,dim=1), size(play,dim=2)) :: jeta
>     ! ----------------------------------------------------------
>     integer :: ncol, ngpt 
> 
>     ! ----------------------------------------------------------
>     ! Code starts
>     !
>     error_msg = ""
>     error_msg = compute_gas_taus(this,                       &
>                                  play, plev, tlay, gas_desc, & 
>                                  optical_props,              & 
>                                  jtemp, jpress, jeta, tropo, fmajor, & 
>                                  col_dry)    
>     if(error_msg  /= '') return
> 
>     ncol = size(play,dim=1)
>     ngpt = this%get_ngpt()
>     error_msg = check_extent(toa_src,     ncol,         ngpt, 'toa_src') 
>     if(error_msg  /= '') return
>     toa_src(:,:) = spread(this%solar_src(:), dim=1, ncopies=ncol) 
>    
>   end function gas_optics_ext
>   !------------------------------------------------------------------------------------------
>   !
>   ! Returns optical properties and interpolation coefficients 
>   !
>   function compute_gas_taus(this,                       &
>                             play, plev, tlay, gas_desc, & 
>                             optical_props,              & 
>                             jtemp, jpress, jeta, tropo, fmajor, & 
>                             col_dry) result(error_msg)    
> 
>     class(ty_gas_optics_specification), & 
>                                       intent(in   ) :: this
>     real(wp), dimension(:,:),         intent(in   ) :: play, &   ! layer pressures [hPa, mb]; (ncol,nlay)
>                                                        plev, &   ! level pressures [hPa, mb]; (ncol,nlay+1)
>                                                        tlay      ! layer temperatures [K]; (ncol,nlay)
>     type(ty_gas_concs),               intent(in   ) :: gas_desc  ! Gas volume mixing ratios
> 
>     class(ty_optical_props),          intent(inout) :: optical_props
>     ! Interpolation coefficients  for use in source function 
>     integer,  dimension(:,:),         intent(  out) :: jtemp, jpress
>     integer,  dimension(:,:,:,:),     intent(  out) :: jeta
>     logical,  dimension(:,:),         intent(  out) :: tropo
>     real(wp), dimension(:,:,:,:,:,:), intent(  out) :: fmajor
>     character(len=128)                            :: error_msg
> 
>     ! Optional inputs
>     real(wp), dimension(:,:), intent(in   ), &
>                            optional, target :: col_dry ! Column dry amount; dim(ncol,nlay)
>     ! ----------------------------------------------------------
>     ! Local variables
>     ! gas amounts
>     real(wp), dimension(size(play,dim=1), size(play,dim=2))                  :: one_vmr ! a single volume mixing ratio, (ncol, nlay)
> 
>     real(wp), dimension(size(optical_props%tau,dim=3), &
>                         size(optical_props%tau,dim=2), &
>                         size(optical_props%tau,dim=1)) :: tau  ! optical depth; (ngpt, nlay, ncol)
>     real(wp), dimension(size(optical_props%tau,dim=3), &
>                         size(optical_props%tau,dim=2), &
>                         size(optical_props%tau,dim=1)) :: tau_rayleigh ! optical depth; (ngpt, nlay, ncol)
>                         
>     logical, dimension(this%get_ngas())              :: gas_is_present  ! Is the concentration of each gas known to the  
>                                                                         !   k-distribution available in the set of concentrations? 
>     integer, dimension(2, this%get_nflav())          :: flavor          ! 2 indices into concentration index per band, referring to 
>                                                                         ! gas-which-are-present
>     logical,           dimension(size(this%kminor_activity, 2)) &       ! For which entries in kminor_activity are 
>                                                      :: minor_entry_is_present ! gas concentrations available? 
>     real(wp),          dimension(:,:,:), allocatable :: vmr             ! volume mixing ratios; (nlay,ncol,ngas)
>     character(len=32), dimension(:),     allocatable :: terse_gas_names ! The gases known to the k-distribution with 
>                                                                         ! concentrations present
>     integer,           dimension(:,:),   allocatable :: kminor_activity ! Describes minor gas contributions; 
>                                                                         ! includes only available gases
>     character(len=32), dimension(:), allocatable     :: minor_gas_list
>     integer                                          :: imnr 
>     ! ----------------------------------------------------------
>     ! dimensions - determined from problem size
>     integer :: ncol, nlay ! number of columns, layers
>     ! dimensions - provided by k-distribution
>     integer :: ngpt, nband, ngas, nflav ! Number of g-points, bands, gas, gas "flavors" (major species combinations) 
>     ! index
>     integer :: igas, iband, idx_h2o
> 
>     ! Number of molecules per cm^2
>     real(wp), dimension(size(play,dim=1), size(play,dim=2)), target  :: col_dry_arr
>     real(wp), dimension(:,:),                                pointer :: col_dry_wk => NULL()
>     ! ----------------------------------------------------------
>     ! Code starts
>     !
>     error_msg = ''
>     ! Check for initialization
>     if (.not. this%is_initialized()) then
>       error_msg = 'ERROR: spectral configuration not loaded'
>       return
>     end if
>     !
>     ! Check for presence of key species in ty_gas_concs; return error if any key species are not present
>     !
>     error_msg = this%check_key_species_present(gas_desc)
>     if (error_msg /= '') return
> 
>     ! init from array dimensions
>     ncol = size(play,dim=1)
>     nlay = size(play,dim=2)
>     ngpt = this%get_ngpt()
>     nband = this%get_nband()
>     ngas = this%get_ngas()
>     nflav = this%get_nflav()
> 
>     !
>     ! Check input data sizes and values
>     !
>     error_msg = check_extent(play, ncol, nlay,   'play') 
>     if(error_msg  /= '') return
>     error_msg = check_extent(plev, ncol, nlay+1, 'plev') 
>     if(error_msg  /= '') return
>     error_msg = check_extent(tlay, ncol, nlay,   'tlay') 
>     if(error_msg  /= '') return
>     error_msg = check_range(play, this%press_ref_min, this%press_ref_max, 'play')
>     if(error_msg  /= '') return
>     error_msg = check_range(plev, this%press_ref_min, this%press_ref_max, 'plev')
>     if(error_msg  /= '') return
>     error_msg = check_range(tlay, this%temp_ref_min,  this%temp_ref_max,  'tlay')
>     if(error_msg  /= '') return
>     if(present(col_dry)) then 
>       error_msg = check_extent(col_dry, ncol, nlay, 'col_dry')
>       if(error_msg  /= '') return
>       error_msg = check_range(col_dry, 0._wp, huge(col_dry), 'col_dry')
>       if(error_msg  /= '') return
>     end if
>  
>     ! 
>     ! Code to be replaced when gas optics calculations are more thoroughly kernel-ized 
>     !
>     allocate(vmr(ncol, nlay, ngas))
>     do igas = 1, ngas
>       ! Get vmr only for gases provided in ty_gas_concs
>       if (any (lower_case(this%gas_names(igas)) == gas_desc%gas_name(:))) then
>          error_msg = gas_desc%get_vmr(this%gas_names(igas),one_vmr)
>          if (error_msg /= '') return
>          vmr(:,:,igas) = one_vmr
>       else
>       ! Temporarily set missing gas amounts to zero; may not be needed when missing
>       ! gases skipped in calculation
>          vmr(:,:,igas) = 0._wp
>       end if
>     end do
> 
>     !
>     ! Construct arrays of mixing ratios using only those gases that are both known to the 
>     !   k-distribution and have concentrations available 
>     !   Revise flavors and minor gases activities 
>     !
>     if(.false.) then 
>       !
>       ! Which gases from the k-distribution are present in the set of gas_concentrations? 
>       !
>       do igas = 1, this%get_ngas()
>         gas_is_present(igas) = string_in_array(this%gas_names(igas), gas_desc%gas_name)
>       end do 
>       ngas = count(gas_is_present)
>       allocate(terse_gas_names(ngas), vmr(ncol,nlay,ngas))
>       terse_gas_names(:) = pack(this%gas_names, mask=gas_is_present)
>       !
>       ! Expand volume mixing ratio of available gases to 3D fields
>       !
>       do igas = 1, ngas
>         error_msg = gas_desc%get_vmr(terse_gas_names(igas), one_vmr)
>         if (error_msg /= '') return
>         vmr(:,:,igas) = one_vmr
>       end do
>       !
>       ! Revise mappings into concentration arrays
>       !
>       do iband = 1, this%get_nflav()
>         flavor(1, iband) = string_loc_in_array(this%gas_names(this%flavor(1, iband)), terse_gas_names)
>         flavor(2, iband) = string_loc_in_array(this%gas_names(this%flavor(2, iband)), terse_gas_names)
>       end do 
>       !
>       ! For each minor gas entry: is the gas name in terse_gas_names? 
>       !
>       minor_entry_is_present(:) =[(string_in_array(this%gas_names(this%kminor_activity(2, imnr)), terse_gas_names),  &
>             imnr = 1, size(this%kminor_activity, 2))]
>       allocate(kminor_activity(2, count(minor_entry_is_present)))
>       !
>       ! A new kminor_activity data structure containing only the entries for which concentrations
>       !   are available
>       !
>       kminor_activity(1, :) = pack(this%kminor_activity(1, :), mask = minor_entry_is_present) 
>       kminor_activity(2, :) = pack(this%kminor_activity(2, :), mask = minor_entry_is_present) 
>       !
>       ! Revise mapping into concentration arrays
>       !
>       do imnr = 1, size(kminor_activity, 2)
>         kminor_activity(2, imnr) = string_loc_in_array(this%gas_names(kminor_activity(2, imnr)), terse_gas_names)
>       end do 
>     end if 
>     !
>     !
>     !
>     
>     ! Compute column amounts (number of molecule per cm^2) if user hasn't provided them
>     if (present(col_dry)) then
>       col_dry_wk => col_dry
>     else
>       idx_h2o = string_loc_in_array('h2o', terse_gas_names)
>       col_dry_arr = get_col_dry(vmr(:,:,idx_h2o), plev, tlay) ! column dry amounts computation
>       col_dry_wk => col_dry_arr
>     end if
> 
>     ! Make list of minor gases that are defined in specification and have available concentrations
>     ! Includes key species that are also considered minor at some g-points 
>     minor_gas_list = this%get_minor_list(gas_desc, ngas, this%gas_names, this%kminor_activity)
>     error_msg = this%compute_gas_tau_core(play, tlay, vmr, col_dry_wk, minor_gas_list, &
>                                      ncol, nlay, ngpt, nband, ngas, nflav, &
>                                      tau, tau_rayleigh, & 
>                                      fmajor, jeta, tropo, jtemp, jpress)
>     if (error_msg /= '') return
> 
>     call combine_and_reorder(tau, tau_rayleigh, allocated(this%krayl), optical_props) 
>    
>   end function compute_gas_taus
>   !------------------------------------------------------------------------------------------
>   function compute_gas_tau_core(this,            &
>     play, tlay, vmr, col_dry, minor_gas_list, & !  inputs
>     ncol, nlay, ngpt, nband, ngas, nflav,   &
>     tau, tau_rayleigh,                      & ! mandatory outputs
>     fmajor_out, jeta_out, tropo_out, jtemp_out, jpress_out) result(error_msg)
>     
>     class(ty_gas_optics_specification), intent(in) :: this
>     ! dimensions
>     integer, intent(in) :: ncol  ! Number of columns
>     integer, intent(in) :: nlay  ! Number of layers
>     integer, intent(in) :: ngpt  ! Number of gpts
>     integer, intent(in) :: nband ! Number of bands
>     integer, intent(in) :: ngas  ! Number of gases
>     integer, intent(in) :: nflav ! Number of gas flavors
> 
>     real(wp), dimension(ncol,nlay  ), intent(in) :: play   ! Layer pressures [hPa, mb]
>     real(wp), dimension(ncol,nlay  ), intent(in) :: tlay   ! Layer temperatures [K]
>     real(wp), dimension(ncol,nlay  ,ngas), &
>                                       intent(in) :: vmr ! volume mixing ratios
>     real(wp), dimension(ncol,nlay  ), intent(in) :: col_dry ! Column amount of dry air
>     ! List of minor gases to be used in gas_optics_ext()
>     character(len=32), dimension(:), intent(in)  :: minor_gas_list
> 
>     ! output
>     real(wp), dimension(ngpt,nlay,ncol), intent(out) :: tau          ! optical depth, will be transposed
>     real(wp), dimension(ngpt,nlay,ncol), intent(out) :: tau_rayleigh ! optical depth, will be transposed
> 
>     real(wp), dimension(2,2,2,nflav,ncol,nlay), optional, intent(out) :: fmajor_out 
>     integer,  dimension(2,    nflav,ncol,nlay), optional, intent(out) :: jeta_out  
>     logical,  dimension(            ncol,nlay), optional, intent(out) :: tropo_out
>     integer,  dimension(            ncol,nlay), optional, intent(out) :: jtemp_out
>     integer,  dimension(            ncol,nlay), optional, intent(out) :: jpress_out
> 
>     ! result
>     character(len=128) :: error_msg
>     ! ----------------------------------------------------------
>     ! Local variables
>     ! index
>     integer :: igas
>     ! Planck fractions
>     ! gas amounts
>     real(wp), dimension(ncol,nlay,ngas) :: col_gas ! column amounts for each gas
>     integer, dimension(ngas)  :: idx_gas_list      ! Index of minor gases to be used in gas_optics_ext()
> 
>     ! temperature variables
>     integer,  dimension(ncol,nlay) :: jtemp ! interpolation index for temperature
>     ! pressure variables
>     integer,  dimension(ncol,nlay) :: jpress ! interpolation index for pressure
>     logical,  dimension(ncol,nlay) :: tropo ! true lower atmosphere; false upper atmosphere
> 
>     integer, dimension(2,     nflav,ncol,nlay) :: jeta ! interpolation index for binary species parameter (eta)
>                                                      ! index(1) : reference temperature level
>                                                      ! index(2) : flavor
>                                                      ! index(3) : layer
> 
>     real(wp), dimension(2,    nflav,ncol,nlay) :: col_mix ! combination of major species's column amounts
>                                                          ! index(1) : reference temperature level
>                                                          ! index(2) : flavor
>                                                          ! index(3) : layer
> 
>     real(wp), dimension(2,2,2,nflav,ncol,nlay) :: fmajor ! interpolation fractions for major species
>                                                             ! index(1) : reference eta level (temperature dependent)
>                                                             ! index(2) : reference pressure level
>                                                             ! index(3) : reference temperature level
>                                                             ! index(4) : flavor
>                                                             ! index(5) : layer
> 
>     real(wp), dimension(2,2,  nflav,ncol,nlay) :: fminor ! interpolation fractions for minor species and continuum
>                                                           ! index(1) : reference eta level (temperature dependent)
>                                                           ! index(2) : reference temperature level
>                                                           ! index(3) : flavor
>                                                           ! index(4) : layer
> 
>     integer :: idx_h2o, idx_o2, idx_n2 ! index of some gases
> 
>     ! ----------------------------------------------------------
>     ! Code starts
>     !
>     error_msg = ''
> 
>     ! special gases
>     idx_h2o = string_loc_in_array('h2o', this%gas_names)
>     idx_o2  = string_loc_in_array('o2' , this%gas_names)
>     idx_n2  = string_loc_in_array('n2' , this%gas_names)
>     do igas = 1, size(minor_gas_list)
>       idx_gas_list(igas) = string_loc_in_array(minor_gas_list(igas), this%gas_names)
>     end do
> 
>     ! vmr and column gas amounts
>     do igas = 1, ngas
>       col_gas(:,:,igas) = vmr(:,:,igas) * col_dry(:,:)
>     end do
> 
>     tau(:,:,:) = 0._wp
>     ! ---- calculate gas optical depths ----
>     call interpolation( &
>       ncol,nlay,nflav,this%get_neta(), & ! dimensions
>       this%flavor,this%press_ref_log,this%temp_ref,this%press_ref_log_delta,this%temp_ref_min, & ! inputs from object
>       this%temp_ref_delta, this%press_ref_trop_log,this%vmr_ref,this%get_nlay_ref(), &
>       play,tlay,col_gas, & ! local input
>       jtemp,fmajor,fminor,col_mix,tropo,jeta,jpress) ! output 
>       
>     call gas_optical_depths_major( &
>       ncol,nlay,ngpt,nflav, & ! dimensions
>       this%gpoint_flavor,this%kmajor, & ! inputs from object
>       col_mix,fmajor,& 
>       jeta,tropo,jtemp,jpress, & ! local input
>       tau)
>       
>     call gas_optical_depths_continuum( &
>       ncol,nlay,ngpt,ngas,nflav, & ! dimensions
>       this%flavor,this%gpoint_flavor,this%selfrefin,this%forrefin,this%stpfac, & ! inputs from object
>       idx_h2o ,play,tlay,vmr,col_gas,& 
>       fminor,jeta,tropo,jtemp, & ! local input
>       tau)
>       
>     call gas_optical_depths_minor( &
>       ncol,nlay,ngpt,ngas,nflav, & ! dimensions
>       this%gpoint_flavor,this%band2gpt,this%kminor_lower,this%kminor_upper,this%kminor_activity, & ! inputs from object
>       idx_h2o,idx_o2,idx_n2,play,tlay,col_dry,col_gas,idx_gas_list, & 
>       fminor,jeta,tropo,jtemp, & ! local input
>       tau)
>       
>     if (allocated(this%krayl)) then
>       call gas_optical_depths_rayleigh( &
>         ncol,nlay,ngpt,ngas,nflav, & ! dimensions
>         this%gpoint_flavor,this%krayl, & ! inputs from object
>         idx_h2o,idx_o2,idx_n2,play,tlay,col_dry,col_gas,& 
>         fminor,jeta,tropo,jtemp, & ! local input
>         tau_rayleigh)
>     end if
> 
>     ! This is an internal function -- we can assume that all or none of these are present 
>     if(present(fmajor_out)) then 
>       fmajor_out = fmajor
>       jeta_out   = jeta 
>       tropo_out  = tropo 
>       jtemp_out  = jtemp 
>       jpress_out = jpress
>     end if 
>      
>   end function compute_gas_tau_core
>   !--------------------------------------------------------------------------------------------------------------------
>   !
>   ! Initialization 
>   !
>   !--------------------------------------------------------------------------------------------------------------------
>   ! Initialize object based on data read from netCDF file however the user desires. 
>   !  Rayleigh scattering tables may or may not be present; this is indicated with allocation status 
>   ! This interface is for the internal-sources object -- includes Plank functions and fractions
>   ! 
>   function init_int(this, gas_names, key_species,        & 
>                     band2gpt, band_lims_wavenum,            & 
>                     press_ref, press_ref_trop, temp_ref, & 
>                     temp_ref_p, temp_ref_t, vmr_ref,     & 
>                     kmajor, selfrefin, forrefin, kminor_lower, kminor_upper, & 
>                     totplnk, planck_frac, rayl_lower, rayl_upper) result(err_message) 
>     class(ty_gas_optics_specification), intent(inout) :: this
>     character(len=*), dimension(:), intent(in) :: gas_names
>     integer,  dimension(:,:,:),   intent(in) :: key_species
>     integer,  dimension(:,:),     intent(in) :: band2gpt 
>     real(wp), dimension(:,:),     intent(in) :: band_lims_wavenum
>     real(wp), dimension(:),       intent(in) :: press_ref, temp_ref
>     real(wp),                     intent(in) :: press_ref_trop, temp_ref_p, temp_ref_t
>     real(wp), dimension(:,:,:),   intent(in) :: vmr_ref
>     real(wp), dimension(:,:,:,:), intent(in) :: kmajor
>     real(wp), dimension(:,:,:),   intent(in) :: selfrefin, forrefin
>     real(wp), dimension(:,:,:,:), intent(in) :: kminor_lower, kminor_upper
>     real(wp), dimension(:,:),     intent(in) :: totplnk
>     real(wp), dimension(:,:,:,:), intent(in) :: planck_frac
>     real(wp), dimension(:,:,:),   intent(in), & 
>                                  allocatable :: rayl_lower, rayl_upper
>     character(len = 128) err_message
>     ! ---- 
>     err_message = init_abs_coeffs(this, & 
>                                   gas_names, key_species,    & 
>                                   band2gpt, band_lims_wavenum, &
>                                   press_ref, temp_ref,       & 
>                                   press_ref_trop, temp_ref_p, temp_ref_t, &
>                                   vmr_ref,                   & 
>                                   kmajor, selfrefin, forrefin, kminor_lower, kminor_upper, & 
>                                   rayl_lower, rayl_upper) 
>     ! Planck function tables 
>     ! 
>     this%totplnk = totplnk
>     this%planck_frac = planck_frac
>     ! Temperature steps for Planck function interpolation 
>     !   Assumes that temperature minimum is the same on both scales and that Planck scale
>     !   is equally spaced 
>     this%totplnk_delta =  (this%temp_ref_max-this%temp_ref_min) / (size(this%totplnk,dim=1)-1)
>   end function init_int
> 
>   !--------------------------------------------------------------------------------------------------------------------
>   ! Initialize object based on data read from netCDF file however the user desires. 
>   !  Rayleigh scattering tables may or may not be present; this is indicated with allocation status 
>   ! This interface is for the external-sources object -- includes TOA source function table 
>   ! 
>   function init_ext(this, gas_names, key_species,        & 
>                     band2gpt, band_lims_wavenum,           & 
>                     press_ref, press_ref_trop, temp_ref, & 
>                     temp_ref_p, temp_ref_t, vmr_ref,     & 
>                     kmajor, selfrefin, forrefin, kminor_lower, kminor_upper, & 
>                     solar_src, rayl_lower, rayl_upper)  result(err_message)
>     class(ty_gas_optics_specification), intent(inout) :: this
>     character(len=*), & 
>               dimension(:),       intent(in) :: gas_names
>     integer,  dimension(:,:,:),   intent(in) :: key_species
>     integer,  dimension(:,:),     intent(in) :: band2gpt 
>     real(wp), dimension(:,:),     intent(in) :: band_lims_wavenum
>     real(wp), dimension(:),       intent(in) :: press_ref, temp_ref
>     real(wp),                     intent(in) :: press_ref_trop, temp_ref_p, temp_ref_t
>     real(wp), dimension(:,:,:),   intent(in) :: vmr_ref
>     real(wp), dimension(:,:,:,:), intent(in) :: kmajor
>     real(wp), dimension(:,:,:),   intent(in) :: selfrefin, forrefin
>     real(wp), dimension(:,:,:,:), intent(in) :: kminor_lower, kminor_upper
>     real(wp), dimension(:),       intent(in), allocatable :: solar_src 
>                                                             ! allocatable status to change when solar source is present in file 
>     real(wp), dimension(:,:,:), intent(in), allocatable :: rayl_lower, rayl_upper
>     character(len = 128) err_message
>     ! ---- 
>     err_message = init_abs_coeffs(this, & 
>                                   gas_names, key_species,    & 
>                                   band2gpt, band_lims_wavenum, &
>                                   press_ref, temp_ref,       & 
>                                   press_ref_trop, temp_ref_p, temp_ref_t, &
>                                   vmr_ref,                   & 
>                                   kmajor, selfrefin, forrefin, kminor_lower, kminor_upper, & 
>                                   rayl_lower, rayl_upper) 
>     !
>     ! Something something solar source table init here 
>     ! 
>     this%solar_src = solar_src
>     
>   end function init_ext
>   !--------------------------------------------------------------------------------------------------------------------
>   ! Initialize absorption coefficient arrays,  
>   !   including Rayleigh scattering tables if provided (allocated) 
>   ! 
>   function init_abs_coeffs(this, & 
>                            gas_names, key_species,    & 
>                            band2gpt, band_lims_wavenum, &
>                            press_ref, temp_ref,       & 
>                            press_ref_trop, temp_ref_p, temp_ref_t, &
>                            vmr_ref,                   & 
>                            kmajor, selfrefin, forrefin, kminor_lower, kminor_upper, & 
>                            rayl_lower, rayl_upper) result(err_message) 
>     class(ty_gas_optics_specification), intent(inout) :: this
>     character(len=*), & 
>               dimension(:),       intent(in) :: gas_names
>     integer,  dimension(:,:,:),   intent(in) :: key_species
>     integer,  dimension(:,:),     intent(in) :: band2gpt 
>     real(wp), dimension(:,:),     intent(in) :: band_lims_wavenum
>     real(wp), dimension(:),       intent(in) :: press_ref, temp_ref
>     real(wp),                     intent(in) :: press_ref_trop, temp_ref_p, temp_ref_t
>     real(wp), dimension(:,:,:),   intent(in) :: vmr_ref
>     real(wp), dimension(:,:,:,:), intent(in) :: kmajor
>     real(wp), dimension(:,:,:),   intent(in) :: selfrefin, forrefin
>     real(wp), dimension(:,:,:,:), intent(in) :: kminor_lower, kminor_upper
>     
>     real(wp), dimension(:,:,:),   intent(in), & 
>                                  allocatable :: rayl_lower, rayl_upper
>     character(len=128)                       :: err_message 
>     ! --------------------------------------
>     err_message = "" 
>     ! Assignment 
>     !   includes allocation 
>     this%gas_names = gas_names
>     this%press_ref = press_ref
>     this%temp_ref  = temp_ref 
>     this%vmr_ref   = vmr_ref
>     this%kmajor       = kmajor
>     this%selfrefin    = selfrefin
>     this%forrefin     = forrefin 
>     this%kminor_lower = kminor_lower
>     this%kminor_upper = kminor_upper
>     this%band2gpt        = band2gpt       
>     this%band_lims_wavenum = band_lims_wavenum
> 
>     if(allocated(rayl_lower) .neqv. allocated(rayl_upper)) then 
>       err_message = "rayl_lower and rayl_upper must have the same allocation status"
>       return 
>     end if 
>     if (allocated(rayl_lower)) then
>       allocate(this%krayl(size(rayl_lower,dim=1),size(rayl_lower,dim=2),size(rayl_lower,dim=3),2))
>       this%krayl(:,:,:,1) = rayl_lower
>       this%krayl(:,:,:,2) = rayl_upper
>     end if
> 
> 
>     ! ---- post processing ----
> 
>     this%press_ref(:) = this%press_ref(:) * 0.01_wp ! convert reference pressure from hPa to Pa
>     ! creates log reference pressure
>     allocate(this%press_ref_log(size(this%press_ref)))
>     this%press_ref_log(:) = log(this%press_ref(:))
> 
>     ! log scale of reference pressure
>     this%press_ref_trop_log = log(press_ref_trop)
>     ! factor needed for continuum optical depth
>     this%stpfac = temp_ref_t/temp_ref_p*100._wp
> 
>     ! create flavor list
>     call create_flavor(key_species, this%flavor)
>     ! create gpt2band
>     call create_gpt2band(this%band2gpt, this%gpt2band)
>     ! create gpoint_flavor list
>     call create_gpoint_flavor(key_species, this%gpt2band, this%flavor, this%gpoint_flavor)
> 
>     ! minimum, maximum reference temperature, pressure -- assumes low-to-high ordering 
>     !   for T, high-to-low ordering for p 
>     this%temp_ref_min  = this%temp_ref (1)
>     this%temp_ref_max  = this%temp_ref (size(this%temp_ref))
>     this%press_ref_min = this%press_ref(size(this%press_ref))
>     this%press_ref_max = this%press_ref(1)
> 
>     ! creates press_ref_log, temp_ref_delta
>     this%press_ref_log_delta = (log(this%press_ref_min)-log(this%press_ref_max))/(size(this%press_ref)-1)
>     this%temp_ref_delta      = (this%temp_ref_max-this%temp_ref_min)/(size(this%temp_ref)-1)
> 
>     ! fills kminor_activity; a list where minor species are active
>     call this%fill_kminor_activity()
> 
>     !
>     ! Which species are key in one or more bands? 
>     !   this%flavor is an index into this%gas_names
>     !
>     if (allocated(this%is_key)) deallocate(this%is_key) ! Shouldn't ever happen... 
>     allocate(this%is_key(this%get_ngas()))
>     this%is_key(:) = .False. 
>     this%is_key(pack(this%flavor(:,:), mask = .true.)) = .true. 
>     
>   end function init_abs_coeffs
> 
>   !------------------------------------------------------------------------------------------
>   !
>   ! Ensure that every key gas required by the k-distribution is 
>   !    present in the gas concentration object
>   !
>   function check_key_species_present(this, gas_desc) result(error_msg)
>     class(ty_gas_optics_specification), intent(in) :: this
>     class(ty_gas_concs),                intent(in) :: gas_desc
>     character(len=128)                             :: error_msg
>  
>     ! Local variables
>     character(len=32), dimension(count(this%is_key(:)  )) :: key_gas_names
>     integer                                               :: igas
>     ! --------------------------------------
>     error_msg = "" 
>     key_gas_names = pack(this%gas_names, mask=this%is_key)
>     do igas = 1, size(key_gas_names)
>       if(.not. string_in_array(key_gas_names(igas), gas_desc%gas_name)) & 
>         error_msg = ' ' // trim(lower_case(key_gas_names(igas))) // trim(error_msg)
>     end do
>     if(len_trim(error_msg) > 0) error_msg = "gas_optics: required gases" // trim(error_msg) // " are not provided" 
> 
>   end function check_key_species_present
> 
>   !--------------------------------------------------------------------------------------------------------------------
>   !
>   ! Function to define names of key and minor gases to be used by gas_optics().
>   ! The final list gases includes those that are defined in gas_optics_specification 
>   ! and are provided in ty_gas_concs.
>   !
>   function get_minor_list(this, gas_desc, ngas, names_spec, kminor_activity)
>     class(ty_gas_optics_specification), intent(in)       :: this
>     class(ty_gas_concs), intent(in)                      :: gas_desc
>     integer, intent(in)                                  :: ngas
>     character(32), dimension(ngas), intent(in)           :: names_spec
>     integer, dimension(:,:), intent(in)                  :: kminor_activity
> 
>     ! List of minor gases to be used in gas_optics()
>     character(len=32), dimension(:), allocatable         :: get_minor_list
>     ! Logical flag for minor species in specification (T = minor; F = not minor)
>     logical, dimension(size(names_spec))                 :: gas_is_present
>     integer                                              :: igas, icnt
> 
>     if (allocated(get_minor_list)) deallocate(get_minor_list)
>     do igas = 1, this%get_ngas()
>       gas_is_present(igas) = string_in_array(names_spec(igas), gas_desc%gas_name)
>     end do 
>     icnt = count(gas_is_present)
>     allocate(get_minor_list(icnt))
>     get_minor_list(:) = pack(this%gas_names, mask=gas_is_present)
> 
> 
>   end function get_minor_list
> 
>   !--------------------------------------------------------------------------------------------------------------------
>   !
>   ! Inquiry functions 
>   !
>   !--------------------------------------------------------------------------------------------------------------------
>   ! return true if initialized, false otherwise
>   pure function is_initialized(this)
>     class(ty_gas_optics_specification), intent(in) :: this
>     logical                                        :: is_initialized
>     is_initialized = allocated(this%gas_names)
>   end function is_initialized
>   !--------------------------------------------------------------------------------------------------------------------
> 
>   ! return true if initialized for internal sources, false otherwise
>   pure function is_internal_source_present(this)
>     class(ty_gas_optics_specification), intent(in) :: this
>     logical                                        :: is_internal_source_present
>     is_internal_source_present = allocated(this%totplnk).and.allocated(this%planck_frac)
>   end function is_internal_source_present
>   !--------------------------------------------------------------------------------------------------------------------
> 
>   ! return true if initialized for external sources, false otherwise
>   pure function is_external_source_present(this)
>     class(ty_gas_optics_specification), intent(in) :: this
>     logical                                        :: is_external_source_present
>     is_external_source_present = allocated(this%solar_src)
>   end function is_external_source_present
> 
>   !--------------------------------------------------------------------------------------------------------------------
>   ! return the minimum pressure on the interpolation grids
>   pure function get_press_ref_min(this)
>     class(ty_gas_optics_specification), intent(in) :: this
>     real(wp)                                       :: get_press_ref_min
> 
>     get_press_ref_min = this%press_ref_min
>   end function get_press_ref_min
> 
>   !--------------------------------------------------------------------------------------------------------------------
>   ! return the maximum pressure on the interpolation grids
>   pure function get_press_ref_max(this)
>     class(ty_gas_optics_specification), intent(in) :: this
>     real(wp)                                       :: get_press_ref_max
> 
>     get_press_ref_max = this%press_ref_max
>   end function get_press_ref_max
> 
>   !--------------------------------------------------------------------------------------------------------------------
>   ! return the minimum temparature on the interpolation grids
>   pure function get_temp_ref_min(this)
>     class(ty_gas_optics_specification), intent(in) :: this
>     real(wp)                                       :: get_temp_ref_min
> 
>     get_temp_ref_min = this%temp_ref_min
>   end function get_temp_ref_min
> 
>   !--------------------------------------------------------------------------------------------------------------------
>   ! return the maximum temparature on the interpolation grids
>   pure function get_temp_ref_max(this)
>     class(ty_gas_optics_specification), intent(in) :: this
>     real(wp)                                       :: get_temp_ref_max
> 
>     get_temp_ref_max = this%temp_ref_max
>   end function get_temp_ref_max
> 
>   !--------------------------------------------------------------------------------------------------------------------
>   ! return the first and last g-point of all the bands at once
>   ! dimension (2, nbands) 
>   ! 
>   pure function get_band_gpoint_limits(this)
>     class(ty_gas_optics_specification), intent(in) :: this
>     integer, dimension(size(this%band2gpt,dim=1), size(this%band2gpt,dim=2)) & 
>                                                    :: get_band_gpoint_limits
> 
>     get_band_gpoint_limits = this%band2gpt
>   end function get_band_gpoint_limits
> 
>   !--------------------------------------------------------------------------------------------------------------------
>   ! return the first and last g-point of a band
>   pure function convert_band2gpt(this, band)
>     class(ty_gas_optics_specification), intent(in) :: this
>     integer,                            intent(in) :: band
>     integer, dimension(2)                         :: convert_band2gpt
> 
>     convert_band2gpt(:) = this%band2gpt(:,band)
>   end function convert_band2gpt
> 
>   !--------------------------------------------------------------------------------------------------------------------
>   ! return the lower and upper wavenumber of a band
>   ! (upper and lower wavenumber by band) = band_lims_wavenum(2,band)
>   pure function get_band_lims_wavenumber(this)
>     class(ty_gas_optics_specification), intent(in) :: this
>     real(wp), dimension(size(this%band_lims_wavenum,1), size(this%band_lims_wavenum,2)) & 
>                                                    :: get_band_lims_wavenumber
> 
>     get_band_lims_wavenumber(:,:) = this%band_lims_wavenum(:,:)
>   end function get_band_lims_wavenumber
> 
>   !--------------------------------------------------------------------------------------------------------------------
>   ! return the lower and upper wavelength of a band
>   pure function get_band_lims_wavelength(this)
>     class(ty_gas_optics_specification), intent(in) :: this
>     real(wp), dimension(size(this%band_lims_wavenum,1), size(this%band_lims_wavenum,2)) & 
>                                                    :: get_band_lims_wavelength
> 
>     get_band_lims_wavelength(:,:) = 1._wp/this%band_lims_wavenum(:,:)
>   end function get_band_lims_wavelength
> 
>   !--------------------------------------------------------------------------------------------------------------------
>   ! return the bands of all the g-points at once
>   ! dimension (ngpt) 
>   ! 
>   pure function get_gpoint_bands(this)
>     class(ty_gas_optics_specification), intent(in) :: this
>     integer, dimension(size(this%gpt2band,dim=1)) & 
>                                                    :: get_gpoint_bands
> 
>     get_gpoint_bands(:) = this%gpt2band(:)
>   end function get_gpoint_bands
> 
>   !--------------------------------------------------------------------------------------------------------------------
>   ! return the band of a g-point
>   pure function convert_gpt2band(this, gpt)
>     class(ty_gas_optics_specification), intent(in) :: this
>     integer,                            intent(in) :: gpt
>     integer                                        :: convert_gpt2band
> 
>     convert_gpt2band = this%gpt2band(gpt)
>   end function convert_gpt2band
> 
>   !--------------------------------------------------------------------------------------------------------------------
>   ! The result is the band_value multiplied by the corresponding g-point weight.
>   ! We use knowledge of the starting and ending g-point for each band to know the values of i and j in
>   ! weight_bandvals_by_gpoint(j) = gpt_weights(j) * band_vals(i)
>   pure function weight_bandvals_by_gpoint(this, gpt_weights)
>     class(ty_gas_optics_specification),     intent(in) :: this
>     real(wp), dimension(:),                 intent(in) :: gpt_weights ! dim(# of g-points)
>     real(wp), dimension(size(this%gpoint_flavor,dim=2)) :: weight_bandvals_by_gpoint
> 
>     integer :: iband, igpt
> 
>     do iband=1,this%get_nband()
>       do igpt=this%band2gpt(1,iband), this%band2gpt(2,iband)
>         weight_bandvals_by_gpoint = gpt_weights(igpt) * iband
>       end do
>     end do
>   end function weight_bandvals_by_gpoint
> 
>   !--------------------------------------------------------------------------------------------------------------------
>   ! expands an array of dimension arr_in(nband) to dimension arr_out(ngpt)
>   pure function expand(this, arr_in) result(arr_out)
>     class(ty_gas_optics_specification), intent(in) :: this
>     real(wp), dimension(:), intent(in) :: arr_in ! (nband)
>     real(wp), dimension(size(this%gpoint_flavor,dim=2)) :: arr_out
>     integer :: iband
>     do iband=1,this%get_nband()
>       arr_out(this%band2gpt(1,iband):this%band2gpt(2,iband)) = arr_in(iband)
>     end do
>   end function expand
> 
> 
>   !--------------------------------------------------------------------------------------------------------------------
>   ! --- gas optical depth calculations
>   !--------------------------------------------------------------------------------------------------------------------
>   ! Utility function, provided for user convenience
>   ! computes column amounts of dry air using hydrostatic equation
>   function get_col_dry(vmr_h2o, plev, tlay, latitude) result(col_dry)
>     ! input
>     real(wp), dimension(:,:), intent(in) :: vmr_h2o  ! volume mixing ratio of all gases excluding water; (ncol,nlay)
>     real(wp), dimension(:,:), intent(in) :: plev     ! Layer boundary pressures [hPa, mb] (ncol,nlay+1)
>     real(wp), dimension(:,:), intent(in) :: tlay     ! Layer temperatures [K] (ncol,nlay)
>     real(wp), dimension(:),   optional, &
>                               intent(in) :: latitude ! Latitude [degrees] (ncol)
>     ! output
>     real(wp), dimension(size(tlay,dim=1),size(tlay,dim=2)) :: col_dry ! Column dry amount (ncol,nlay)
>     ! ------------------------------------------------
>     ! first and second term of Helmert formula
>     real(wp), parameter :: helmert1 = 9.80665_wp
>     real(wp), parameter :: helmert2 = 0.02586_wp
>     ! local variables
>     real(wp), dimension(size(tlay,dim=1)                 ) :: g0 ! (ncol)
>     real(wp), dimension(size(tlay,dim=1),size(tlay,dim=2)) :: delta_plev ! (ncol,nlay)
>     real(wp), dimension(size(tlay,dim=1),size(tlay,dim=2)) :: m_air ! average mass of air; (ncol,nlay)
>     integer :: nlev, nlay
>     ! ------------------------------------------------
>     nlay = size(tlay, dim=2)
>     nlev = size(plev, dim=2)
> 
>     if(present(latitude)) then
>       g0(:) = helmert1 - helmert2 * cos(2.0_wp * pi * latitude(:) / 180.0_wp) ! acceleration due to gravity [m/s^2]
>     else
>       g0(:) = grav
>     end if
>     delta_plev(:,:) = plev(:,1:nlev-1) - plev(:,2:nlev)
> 
>     ! Get average mass of air
>     m_air(:,:) = (m_dry+m_h2o*vmr_h2o(:,:))/(1.+vmr_h2o(:,:))
> 
>     ! Hydrostatic equation
>     col_dry(:,:) = 1000._wp*delta_plev(:,:)*avogad/(1000._wp*m_air(:,:)*100._wp*spread(g0(:),dim=2,ncopies=nlay))
>     col_dry(:,:) = col_dry(:,:)/(1._wp+vmr_h2o(:,:))
>   end function get_col_dry
>   !--------------------------------------------------------------------------------------------------------------------
>   !
>   ! Internal procedures 
>   ! 
>   !--------------------------------------------------------------------------------------------------------------------
>   pure function rewrite_key_species_pair(key_species_pair)
>     ! (x,0) becomes (x,x)
>     ! (0,0) becomes (2,2) -- because absorption coefficients for these g-points will be 0. 
>     integer, dimension(2) :: rewrite_key_species_pair
>     integer, dimension(2), intent(in) :: key_species_pair
>     rewrite_key_species_pair = key_species_pair
>     if (key_species_pair(2).eq.0) then
>       rewrite_key_species_pair(2) = key_species_pair(1)
>     end if
>     if (all(key_species_pair(:).eq.(/0,0/))) then
>       rewrite_key_species_pair(:) = (/2,2/)
>     end if
>   end function
> 
>   ! ---------------------------------------------------------------------------------------
>   ! true is key_species_pair exists in key_species_list
>   pure function key_species_pair_exists(key_species_list, key_species_pair)
>     logical :: key_species_pair_exists
>     integer, dimension(:,:), intent(in) :: key_species_list
>     integer, dimension(2), intent(in) :: key_species_pair
>     integer :: i
>     do i=1,size(key_species_list,dim=2)
>       if (all(key_species_list(:,i).eq.key_species_pair(:))) then
>         key_species_pair_exists = .true.
>         return
>       end if
>     end do
>     key_species_pair_exists = .false.
>   end function key_species_pair_exists
> 
>   ! ---------------------------------------------------------------------------------------
>   ! create flavor list -- 
>   !   an unordered array of extent (2,:) containing all possible pairs of key species 
>   !   used in either upper or lower atmos
>   !
>   subroutine create_flavor(key_species, flavor)
>     integer, dimension(:,:,:), intent(in) :: key_species
>     integer, dimension(:,:), allocatable, intent(out) :: flavor
>     integer, dimension(2,size(key_species,3)*2) :: key_species_list
> 
>     integer :: ibnd, iatm, i, iflavor
>     ! prepare list of key_species
>     i = 1
>     do ibnd=1,size(key_species,3)
>       do iatm=1,size(key_species,1)
>         key_species_list(:,i) = key_species(:,iatm,ibnd)
>         i = i + 1
>       end do
>     end do
>     ! rewrite single key_species pairs
>     do i=1,size(key_species_list,2)
>         key_species_list(:,i) = rewrite_key_species_pair(key_species_list(:,i))
>     end do
>     ! count unique key species pairs
>     iflavor = 0
>     do i=1,size(key_species_list,2)
>       if (.not.key_species_pair_exists(key_species_list(:,1:i-1),key_species_list(:,i))) then
>         iflavor = iflavor + 1
>       end if
>     end do
>     ! fill flavors
>     allocate(flavor(2,iflavor))
>     iflavor = 0
>     do i=1,size(key_species_list,2)
>       if (.not.key_species_pair_exists(key_species_list(:,1:i-1),key_species_list(:,i))) then
>         iflavor = iflavor + 1
>         flavor(:,iflavor) = key_species_list(:,i)
>       end if
>     end do
>   end subroutine create_flavor
> ! ---------------------------------------------------------------------------------------
> 
>   ! returns flavor index; -1 if not found
>   pure function key_species_pair2flavor(flavor, key_species_pair)
>     integer :: key_species_pair2flavor
>     integer, dimension(:,:), intent(in) :: flavor
>     integer, dimension(2), intent(in) :: key_species_pair
>     integer :: iflav
>     do iflav=1,size(flavor,2)
>       if (all(key_species_pair(:).eq.flavor(:,iflav))) then
>         key_species_pair2flavor = iflav
>         return
>       end if
>     end do
>     key_species_pair2flavor = -1
>   end function key_species_pair2flavor
> 
>   ! ---------------------------------------------------------------------------------------
>   ! create gpoint_flavor list
>   !   a map pointing from each g-point to the corresponding entry in the "flavor list" 
>   !
>   subroutine create_gpoint_flavor(key_species, gpt2band, flavor, gpoint_flavor)
>     integer, dimension(:,:,:), intent(in) :: key_species
>     integer, dimension(:), intent(in) :: gpt2band
>     integer, dimension(:,:), intent(in) :: flavor
>     integer, dimension(:,:), intent(out), allocatable :: gpoint_flavor
>     integer :: ngpt, igpt, iatm
>     ngpt = size(gpt2band)
>     allocate(gpoint_flavor(2,ngpt))
>     do igpt=1,ngpt
>       do iatm=1,2
>         gpoint_flavor(iatm,igpt) = key_species_pair2flavor( &
>           flavor, &
>           rewrite_key_species_pair(key_species(:,iatm,gpt2band(igpt))) &
>         )
>       end do
>     end do
>   end subroutine create_gpoint_flavor
> 
>   !--------------------------------------------------------------------------------------------------------------------
>   ! create gpt2band -- a map from g-points to bands 
>   !   includes allocating the result 
>   ! 
>   subroutine create_gpt2band(band2gpt, gpt2band)
>     integer, dimension(:,:), intent(in) :: band2gpt
>     integer, dimension(:), allocatable, intent(out) :: gpt2band
>     integer :: iband, ngpt
>     ngpt = maxval(band2gpt)
>     allocate(gpt2band(ngpt))
>     do iband=1,size(band2gpt,dim=2)
>       gpt2band(band2gpt(1,iband):band2gpt(2,iband)) = iband
>     end do
>   end subroutine create_gpt2band
> 
>  !--------------------------------------------------------------------------------------------------------------------
>  !
>  ! Utility function to combine optical properties for absorption and Rayleigh scattering 
>  !   (and reorder them for convenience, while we're at it) 
>  !
>  subroutine combine_and_reorder(tau, tau_rayleigh, has_rayleigh, optical_props) 
>     real(wp), dimension(:,:,:), intent(in) :: tau
>     real(wp), dimension(:,:,:), intent(in) :: tau_rayleigh
>     logical,                    intent(in) :: has_rayleigh
>     class(ty_optical_props),    intent(inout) :: optical_props
>     
>     integer :: icol, ilay, igpt, ncol, nlay, ngpt
>     
>     ncol = size(tau, 3) 
>     nlay = size(tau, 2) 
>     ngpt = size(tau, 1)
>      
>     if (.not. has_rayleigh) then
>       ! index reorder (ngpt, nlay, ncol) -> (ncol,nlay,gpt)
>       optical_props%tau = reorder123x321(tau)
>     else
>       ! combine optical depth and rayleigh scattering
>       select type(optical_props)
>         type is (ty_optical_props)
>           ! User is asking for absorption optical depth 
>           optical_props%tau = reorder123x321(tau)
>         type is (ty_optical_props_2str) 
>           do icol = 1, ncol
>             do ilay = 1, nlay
>               do igpt = 1, ngpt 
>                 optical_props%tau(icol,ilay,igpt) = tau(igpt,ilay,icol) + tau_rayleigh(igpt,ilay,icol)
>                 optical_props%ssa(icol,ilay,igpt) = tau_rayleigh(igpt,ilay,icol) / optical_props%tau(icol,ilay,igpt)
>               end do 
>             end do 
>           end do 
>           optical_props%g = 0._wp 
>         type is (ty_optical_props_nstr) ! We ought to be able to combine this with above
>           do icol = 1, ncol
>             do ilay = 1, nlay
>               do igpt = 1, ngpt 
>                 optical_props%tau(icol,ilay,igpt) = tau(igpt,ilay,icol) + tau_rayleigh(igpt,ilay,icol)
>                 optical_props%ssa(icol,ilay,igpt) = tau_rayleigh(igpt,ilay,icol) / optical_props%tau(icol,ilay,igpt)
>               end do 
>             end do 
>           end do 
>           optical_props%p = 0._wp
>           optical_props%p(2,:,:,:) = 0.1_wp 
>       end select
>       
>     end if
>   end subroutine combine_and_reorder
> 
>   !--------------------------------------------------------------------------------------------------------------------
>   ! return the number of reference pressure layers
>   pure function get_nlay_ref(this)
>     class(ty_gas_optics_specification), intent(in) :: this
>     integer                                        :: get_nlay_ref
> 
>     get_nlay_ref = size(this%kmajor,dim=3)
>   end function get_nlay_ref
> 
>   !--------------------------------------------------------------------------------------------------------------------
>   ! return eta dimension
>   pure function get_neta(this)
>     class(ty_gas_optics_specification), intent(in) :: this
>     integer                                        :: get_neta
> 
>     get_neta = size(this%selfrefin,dim=2)
>   end function
> 
>   !--------------------------------------------------------------------------------------------------------------------
>   ! fills kminor_activity; a list where minor species are active
>   !   looks to see for which entires the absorption coefficients are zero at all p, eta
>   !   compiles a list of extent (2, N) where each entry is (gpt, minor_gas_index) 
>   ! 
>   subroutine fill_kminor_activity(this)
>     class(ty_gas_optics_specification) :: this
> 
>     integer :: igpt, imnr, ilist, ngpt, nmnr, nlist
> 
>     ngpt = this%get_ngpt()
>     nmnr = size(this%kminor_lower, dim=1)
>     nlist = 0
>     ! determine array length
>     do igpt = 1, ngpt
>       do imnr = 1, nmnr
>         if (sum(this%kminor_lower(imnr,igpt,:,:))+sum(this%kminor_upper(imnr,igpt,:,:)) .gt. 1.E-40_wp) then
>           nlist = nlist + 1
>         end if
>       end do
>     end do
>     ! fill an array with (g-point, minor-gas) tuples
>     ilist = 0
>     if (allocated(this%kminor_activity)) deallocate(this%kminor_activity)
>     allocate(this%kminor_activity(2,nlist))
>     do igpt = 1, ngpt
>       do imnr = 1, nmnr
>         if (sum(this%kminor_lower(imnr,igpt,:,:))+sum(this%kminor_upper(imnr,igpt,:,:)) .gt. 1.E-40_wp) then
>           ilist = ilist + 1
>           this%kminor_activity(:,ilist) = (/ igpt,imnr /)
>         end if
>       end do
>     end do
>   end subroutine fill_kminor_activity
>   !--------------------------------------------------------------------------------------------------------------------
>   ! Generic procedures for checking sizes, limits
>   !--------------------------------------------------------------------------------------------------------------------
>   !
>   ! Extents 
>   !
>   function check_extent_1d(array, nx, label) 
>     real(wp), dimension(:),     intent(in) :: array
>     integer,                    intent(in) :: nx
>     character(len=*),           intent(in) :: label 
>     character(len=128)                     :: check_extent_1d
>   
>     check_extent_1d = "" 
>     if(size(array,1) /= nx) & 
>       check_extent_1d = trim(label) // ' has incorrect size.' 
>   end function check_extent_1d
>   ! --------------------------------------------------------------------------------------
>   function check_extent_2d(array, nx, ny, label) 
>     real(wp), dimension(:,:),   intent(in) :: array
>     integer,                    intent(in) :: nx, ny 
>     character(len=*),           intent(in) :: label 
>     character(len=128)                     :: check_extent_2d
>   
>     check_extent_2d = "" 
>     if(size(array,1) /= nx .or. size(array,2) /= ny) & 
>       check_extent_2d = trim(label) // ' has incorrect size.' 
>   end function check_extent_2d
>   ! --------------------------------------------------------------------------------------
>   function check_extent_3d(array, nx, ny, nz, label) 
>     real(wp), dimension(:,:,:), intent(in) :: array
>     integer,                    intent(in) :: nx, ny, nz
>     character(len=*),           intent(in) :: label 
>     character(len=128)                     :: check_extent_3d
>   
>     check_extent_3d = "" 
>     if(size(array,1) /= nx .or. size(array,2) /= ny .or. size(array,3) /= nz) & 
>       check_extent_3d = trim(label) // ' has incorrect size.' 
>   end function check_extent_3d
>   ! --------------------------------------------------------------------------------------
>   !
>   ! Values 
>   !
>   ! --------------------------------------------------------------------------------------
>   function check_range_1D(val, minV, maxV, label)
>     real(wp), dimension(:),     intent(in) :: val
>     real(wp),                   intent(in) :: minV, maxV
>     character(len=*),           intent(in) :: label 
>     character(len=128)                     :: check_range_1D
>     
>     check_range_1D = ""
>     if(any(val < minV) .or. any(val > maxV)) & 
>       check_range_1D = trim(label) // ' values out of range.' 
>   end function check_range_1D
>   ! --------------------------------------------------------------------------------------
>   function check_range_2D(val, minV, maxV, label)
>     real(wp), dimension(:,:),   intent(in) :: val
>     real(wp),                   intent(in) :: minV, maxV
>     character(len=*),           intent(in) :: label 
>     character(len=128)                     :: check_range_2D
>     
>     check_range_2D = ""
>     if(any(val < minV) .or. any(val > maxV)) & 
>       check_range_2D = trim(label) // ' values out of range.' 
>   end function check_range_2D
>   ! --------------------------------------------------------------------------------------
>   function check_range_3D(val, minV, maxV, label)
>     real(wp), dimension(:,:,:), intent(in) :: val
>     real(wp),                   intent(in) :: minV, maxV
>     character(len=*),           intent(in) :: label 
>     character(len=128)                     :: check_range_3D
>     
>     check_range_3D = ""
>     if(any(val < minV) .or. any(val > maxV)) & 
>       check_range_3D = trim(label) // ' values out of range.' 
>   end function check_range_3D
>   !------------------------------------------------------------------------------------------
> 
> 
>   !read state subroutine for kr_kgen_mo_gas_optics_specification_typesubp0 
>   RECURSIVE SUBROUTINE kr_kgen_mo_gas_optics_specification_typesubp0(var, kgen_unit, printname, printvar) 
>       TYPE(ty_gas_optics_specification), INTENT(INOUT) :: var 
>       INTEGER, INTENT(IN) :: kgen_unit 
>       CHARACTER(LEN=*), INTENT(IN) :: printname 
>       LOGICAL, INTENT(IN), OPTIONAL :: printvar 
>       LOGICAL :: kgen_istrue 
>       REAL(KIND=8) :: kgen_array_sum 
>         
>       IF (PRESENT( printvar ) .AND. printvar) THEN 
>           CALL kr_kgen_ty_gas_optics_specification_subp4(var%gas_names, kgen_unit, printname // "%gas_names", .TRUE.) 
>       ELSE 
>           CALL kr_kgen_ty_gas_optics_specification_subp4(var%gas_names, kgen_unit, printname // "%gas_names", .FALSE.) 
>       END IF   
>         
>       IF (PRESENT( printvar ) .AND. printvar) THEN 
>           CALL kr_kgen_ty_gas_optics_specification_subp5(var%flavor, kgen_unit, printname // "%flavor", .TRUE.) 
>       ELSE 
>           CALL kr_kgen_ty_gas_optics_specification_subp5(var%flavor, kgen_unit, printname // "%flavor", .FALSE.) 
>       END IF   
>         
>       IF (PRESENT( printvar ) .AND. printvar) THEN 
>           CALL kr_kgen_ty_gas_optics_specification_subp5(var%gpoint_flavor, kgen_unit, printname // "%gpoint_flavor", .TRUE.) 
>       ELSE 
>           CALL kr_kgen_ty_gas_optics_specification_subp5(var%gpoint_flavor, kgen_unit, printname // "%gpoint_flavor", .FALSE.) 
>       END IF   
>         
>       IF (PRESENT( printvar ) .AND. printvar) THEN 
>           CALL kr_kgen_ty_gas_optics_specification_subp5(var%band2gpt, kgen_unit, printname // "%band2gpt", .TRUE.) 
>       ELSE 
>           CALL kr_kgen_ty_gas_optics_specification_subp5(var%band2gpt, kgen_unit, printname // "%band2gpt", .FALSE.) 
>       END IF   
>         
>       IF (PRESENT( printvar ) .AND. printvar) THEN 
>           CALL kr_kgen_ty_gas_optics_specification_subp6(var%gpt2band, kgen_unit, printname // "%gpt2band", .TRUE.) 
>       ELSE 
>           CALL kr_kgen_ty_gas_optics_specification_subp6(var%gpt2band, kgen_unit, printname // "%gpt2band", .FALSE.) 
>       END IF   
>         
>       IF (PRESENT( printvar ) .AND. printvar) THEN 
>           CALL kr_kgen_ty_gas_optics_specification_subp7(var%band_lims_wavenum, kgen_unit, printname // "%band_lims_wavenum", &
>           &.TRUE.) 
>       ELSE 
>           CALL kr_kgen_ty_gas_optics_specification_subp7(var%band_lims_wavenum, kgen_unit, printname // "%band_lims_wavenum", &
>           &.FALSE.) 
>       END IF   
>         
>       IF (PRESENT( printvar ) .AND. printvar) THEN 
>           CALL kr_kgen_ty_gas_optics_specification_subp8(var%press_ref, kgen_unit, printname // "%press_ref", .TRUE.) 
>       ELSE 
>           CALL kr_kgen_ty_gas_optics_specification_subp8(var%press_ref, kgen_unit, printname // "%press_ref", .FALSE.) 
>       END IF   
>       IF (PRESENT( printvar ) .AND. printvar) THEN 
>           CALL kr_kgen_ty_gas_optics_specification_subp8(var%press_ref_log, kgen_unit, printname // "%press_ref_log", .TRUE.) 
>       ELSE 
>           CALL kr_kgen_ty_gas_optics_specification_subp8(var%press_ref_log, kgen_unit, printname // "%press_ref_log", .FALSE.) 
>       END IF   
>       IF (PRESENT( printvar ) .AND. printvar) THEN 
>           CALL kr_kgen_ty_gas_optics_specification_subp8(var%temp_ref, kgen_unit, printname // "%temp_ref", .TRUE.) 
>       ELSE 
>           CALL kr_kgen_ty_gas_optics_specification_subp8(var%temp_ref, kgen_unit, printname // "%temp_ref", .FALSE.) 
>       END IF   
>         
>       IF (PRESENT( printvar ) .AND. printvar) THEN 
>           CALL kr_kgen_ty_gas_optics_specification_subp9(var%vmr_ref, kgen_unit, printname // "%vmr_ref", .TRUE.) 
>       ELSE 
>           CALL kr_kgen_ty_gas_optics_specification_subp9(var%vmr_ref, kgen_unit, printname // "%vmr_ref", .FALSE.) 
>       END IF   
>         
>       READ (UNIT = kgen_unit) var%press_ref_min 
>       IF (PRESENT( printvar ) .AND. printvar) THEN 
>           WRITE (*, *) "KGEN DEBUG: " // printname // "%press_ref_min = ", var%press_ref_min 
>       END IF   
>       READ (UNIT = kgen_unit) var%press_ref_max 
>       IF (PRESENT( printvar ) .AND. printvar) THEN 
>           WRITE (*, *) "KGEN DEBUG: " // printname // "%press_ref_max = ", var%press_ref_max 
>       END IF   
>       READ (UNIT = kgen_unit) var%temp_ref_min 
>       IF (PRESENT( printvar ) .AND. printvar) THEN 
>           WRITE (*, *) "KGEN DEBUG: " // printname // "%temp_ref_min = ", var%temp_ref_min 
>       END IF   
>       READ (UNIT = kgen_unit) var%temp_ref_max 
>       IF (PRESENT( printvar ) .AND. printvar) THEN 
>           WRITE (*, *) "KGEN DEBUG: " // printname // "%temp_ref_max = ", var%temp_ref_max 
>       END IF   
>         
>       READ (UNIT = kgen_unit) var%press_ref_log_delta 
>       IF (PRESENT( printvar ) .AND. printvar) THEN 
>           WRITE (*, *) "KGEN DEBUG: " // printname // "%press_ref_log_delta = ", var%press_ref_log_delta 
>       END IF   
>       READ (UNIT = kgen_unit) var%temp_ref_delta 
>       IF (PRESENT( printvar ) .AND. printvar) THEN 
>           WRITE (*, *) "KGEN DEBUG: " // printname // "%temp_ref_delta = ", var%temp_ref_delta 
>       END IF   
>       READ (UNIT = kgen_unit) var%press_ref_trop_log 
>       IF (PRESENT( printvar ) .AND. printvar) THEN 
>           WRITE (*, *) "KGEN DEBUG: " // printname // "%press_ref_trop_log = ", var%press_ref_trop_log 
>       END IF   
>         
>       READ (UNIT = kgen_unit) var%stpfac 
>       IF (PRESENT( printvar ) .AND. printvar) THEN 
>           WRITE (*, *) "KGEN DEBUG: " // printname // "%stpfac = ", var%stpfac 
>       END IF   
>         
>       IF (PRESENT( printvar ) .AND. printvar) THEN 
>           CALL kr_kgen_ty_gas_optics_specification_subp10(var%kmajor, kgen_unit, printname // "%kmajor", .TRUE.) 
>       ELSE 
>           CALL kr_kgen_ty_gas_optics_specification_subp10(var%kmajor, kgen_unit, printname // "%kmajor", .FALSE.) 
>       END IF   
>         
>       IF (PRESENT( printvar ) .AND. printvar) THEN 
>           CALL kr_kgen_ty_gas_optics_specification_subp9(var%selfrefin, kgen_unit, printname // "%selfrefin", .TRUE.) 
>       ELSE 
>           CALL kr_kgen_ty_gas_optics_specification_subp9(var%selfrefin, kgen_unit, printname // "%selfrefin", .FALSE.) 
>       END IF   
>       IF (PRESENT( printvar ) .AND. printvar) THEN 
>           CALL kr_kgen_ty_gas_optics_specification_subp9(var%forrefin, kgen_unit, printname // "%forrefin", .TRUE.) 
>       ELSE 
>           CALL kr_kgen_ty_gas_optics_specification_subp9(var%forrefin, kgen_unit, printname // "%forrefin", .FALSE.) 
>       END IF   
>         
>       IF (PRESENT( printvar ) .AND. printvar) THEN 
>           CALL kr_kgen_ty_gas_optics_specification_subp10(var%kminor_lower, kgen_unit, printname // "%kminor_lower", .TRUE.) 
>       ELSE 
>           CALL kr_kgen_ty_gas_optics_specification_subp10(var%kminor_lower, kgen_unit, printname // "%kminor_lower", .FALSE.) 
>       END IF   
>       IF (PRESENT( printvar ) .AND. printvar) THEN 
>           CALL kr_kgen_ty_gas_optics_specification_subp10(var%kminor_upper, kgen_unit, printname // "%kminor_upper", .TRUE.) 
>       ELSE 
>           CALL kr_kgen_ty_gas_optics_specification_subp10(var%kminor_upper, kgen_unit, printname // "%kminor_upper", .FALSE.) 
>       END IF   
>         
>       IF (PRESENT( printvar ) .AND. printvar) THEN 
>           CALL kr_kgen_ty_gas_optics_specification_subp10(var%krayl, kgen_unit, printname // "%krayl", .TRUE.) 
>       ELSE 
>           CALL kr_kgen_ty_gas_optics_specification_subp10(var%krayl, kgen_unit, printname // "%krayl", .FALSE.) 
>       END IF   
>         
>       IF (PRESENT( printvar ) .AND. printvar) THEN 
>           CALL kr_kgen_ty_gas_optics_specification_subp10(var%planck_frac, kgen_unit, printname // "%planck_frac", .TRUE.) 
>       ELSE 
>           CALL kr_kgen_ty_gas_optics_specification_subp10(var%planck_frac, kgen_unit, printname // "%planck_frac", .FALSE.) 
>       END IF   
>         
>       IF (PRESENT( printvar ) .AND. printvar) THEN 
>           CALL kr_kgen_ty_gas_optics_specification_subp7(var%totplnk, kgen_unit, printname // "%totplnk", .TRUE.) 
>       ELSE 
>           CALL kr_kgen_ty_gas_optics_specification_subp7(var%totplnk, kgen_unit, printname // "%totplnk", .FALSE.) 
>       END IF   
>         
>       READ (UNIT = kgen_unit) var%totplnk_delta 
>       IF (PRESENT( printvar ) .AND. printvar) THEN 
>           WRITE (*, *) "KGEN DEBUG: " // printname // "%totplnk_delta = ", var%totplnk_delta 
>       END IF   
>         
>       IF (PRESENT( printvar ) .AND. printvar) THEN 
>           CALL kr_kgen_ty_gas_optics_specification_subp8(var%solar_src, kgen_unit, printname // "%solar_src", .TRUE.) 
>       ELSE 
>           CALL kr_kgen_ty_gas_optics_specification_subp8(var%solar_src, kgen_unit, printname // "%solar_src", .FALSE.) 
>       END IF   
>         
>       IF (PRESENT( printvar ) .AND. printvar) THEN 
>           CALL kr_kgen_ty_gas_optics_specification_subp5(var%kminor_activity, kgen_unit, printname // "%kminor_activity", .TRUE.) 
>       ELSE 
>           CALL kr_kgen_ty_gas_optics_specification_subp5(var%kminor_activity, kgen_unit, printname // "%kminor_activity", &
>           &.FALSE.) 
>       END IF   
>         
>       IF (PRESENT( printvar ) .AND. printvar) THEN 
>           CALL kr_kgen_ty_gas_optics_specification_subp11(var%is_key, kgen_unit, printname // "%is_key", .TRUE.) 
>       ELSE 
>           CALL kr_kgen_ty_gas_optics_specification_subp11(var%is_key, kgen_unit, printname // "%is_key", .FALSE.) 
>       END IF   
>         
>   END SUBROUTINE kr_kgen_mo_gas_optics_specification_typesubp0 
>     
>   !write state subroutine for kr_kgen_ty_gas_optics_specification_subp4 
>   SUBROUTINE kr_kgen_ty_gas_optics_specification_subp4(var, kgen_unit, printname, printvar) 
>       CHARACTER(LEN=32), INTENT(INOUT), ALLOCATABLE, DIMENSION(:) :: var 
>       INTEGER, INTENT(IN) :: kgen_unit 
>       CHARACTER(LEN=*), INTENT(IN) :: printname 
>       LOGICAL, INTENT(IN), OPTIONAL :: printvar 
>       LOGICAL :: kgen_istrue 
>       REAL(KIND=8) :: kgen_array_sum 
>       INTEGER :: idx1 
>       INTEGER, DIMENSION(2,1) :: kgen_bound 
>         
>       READ (UNIT = kgen_unit) kgen_istrue 
>       IF (kgen_istrue) THEN 
>           IF (ALLOCATED( var )) THEN 
>               DEALLOCATE (var) 
>           END IF   
>           READ (UNIT = kgen_unit) kgen_bound(1, 1) 
>           READ (UNIT = kgen_unit) kgen_bound(2, 1) 
>           ALLOCATE (var(kgen_bound(1,1):kgen_bound(2,1))) 
>           READ (UNIT = kgen_unit) var 
>           IF (PRESENT( printvar ) .AND. printvar) THEN 
>               WRITE (*, *) "KGEN DEBUG: " // printname // " = ", var 
>           END IF   
>       END IF   
>         
>   END SUBROUTINE kr_kgen_ty_gas_optics_specification_subp4 
>     
>   !write state subroutine for kr_kgen_ty_gas_optics_specification_subp5 
>   SUBROUTINE kr_kgen_ty_gas_optics_specification_subp5(var, kgen_unit, printname, printvar) 
>       INTEGER, INTENT(INOUT), ALLOCATABLE, DIMENSION(:,:) :: var 
>       INTEGER, INTENT(IN) :: kgen_unit 
>       CHARACTER(LEN=*), INTENT(IN) :: printname 
>       LOGICAL, INTENT(IN), OPTIONAL :: printvar 
>       LOGICAL :: kgen_istrue 
>       REAL(KIND=8) :: kgen_array_sum 
>       INTEGER :: idx1, idx2 
>       INTEGER, DIMENSION(2,2) :: kgen_bound 
>         
>       READ (UNIT = kgen_unit) kgen_istrue 
>       IF (kgen_istrue) THEN 
>           IF (ALLOCATED( var )) THEN 
>               DEALLOCATE (var) 
>           END IF   
>           READ (UNIT = kgen_unit) kgen_array_sum 
>           READ (UNIT = kgen_unit) kgen_bound(1, 1) 
>           READ (UNIT = kgen_unit) kgen_bound(2, 1) 
>           READ (UNIT = kgen_unit) kgen_bound(1, 2) 
>           READ (UNIT = kgen_unit) kgen_bound(2, 2) 
>           ALLOCATE (var(kgen_bound(1,1):kgen_bound(2,1), kgen_bound(1,2):kgen_bound(2,2))) 
>           READ (UNIT = kgen_unit) var 
>           CALL kgen_array_sumcheck(printname, kgen_array_sum, REAL(SUM(var, mask=(var .eq. var)), 8), .TRUE.) 
>           IF (PRESENT( printvar ) .AND. printvar) THEN 
>               WRITE (*, *) "KGEN DEBUG: REAL(SUM(" // printname // "), 8) = ", REAL(SUM(var, mask=(var .eq. var)), 8) 
>           END IF   
>       END IF   
>         
>   END SUBROUTINE kr_kgen_ty_gas_optics_specification_subp5 
>     
>   !write state subroutine for kr_kgen_ty_gas_optics_specification_subp6 
>   SUBROUTINE kr_kgen_ty_gas_optics_specification_subp6(var, kgen_unit, printname, printvar) 
>       INTEGER, INTENT(INOUT), ALLOCATABLE, DIMENSION(:) :: var 
>       INTEGER, INTENT(IN) :: kgen_unit 
>       CHARACTER(LEN=*), INTENT(IN) :: printname 
>       LOGICAL, INTENT(IN), OPTIONAL :: printvar 
>       LOGICAL :: kgen_istrue 
>       REAL(KIND=8) :: kgen_array_sum 
>       INTEGER :: idx1 
>       INTEGER, DIMENSION(2,1) :: kgen_bound 
>         
>       READ (UNIT = kgen_unit) kgen_istrue 
>       IF (kgen_istrue) THEN 
>           IF (ALLOCATED( var )) THEN 
>               DEALLOCATE (var) 
>           END IF   
>           READ (UNIT = kgen_unit) kgen_array_sum 
>           READ (UNIT = kgen_unit) kgen_bound(1, 1) 
>           READ (UNIT = kgen_unit) kgen_bound(2, 1) 
>           ALLOCATE (var(kgen_bound(1,1):kgen_bound(2,1))) 
>           READ (UNIT = kgen_unit) var 
>           CALL kgen_array_sumcheck(printname, kgen_array_sum, REAL(SUM(var, mask=(var .eq. var)), 8), .TRUE.) 
>           IF (PRESENT( printvar ) .AND. printvar) THEN 
>               WRITE (*, *) "KGEN DEBUG: REAL(SUM(" // printname // "), 8) = ", REAL(SUM(var, mask=(var .eq. var)), 8) 
>           END IF   
>       END IF   
>         
>   END SUBROUTINE kr_kgen_ty_gas_optics_specification_subp6 
>     
>   !write state subroutine for kr_kgen_ty_gas_optics_specification_subp7 
>   SUBROUTINE kr_kgen_ty_gas_optics_specification_subp7(var, kgen_unit, printname, printvar) 
>       REAL(KIND=wp), INTENT(INOUT), ALLOCATABLE, DIMENSION(:,:) :: var 
>       INTEGER, INTENT(IN) :: kgen_unit 
>       CHARACTER(LEN=*), INTENT(IN) :: printname 
>       LOGICAL, INTENT(IN), OPTIONAL :: printvar 
>       LOGICAL :: kgen_istrue 
>       REAL(KIND=8) :: kgen_array_sum 
>       INTEGER :: idx1, idx2 
>       INTEGER, DIMENSION(2,2) :: kgen_bound 
>         
>       READ (UNIT = kgen_unit) kgen_istrue 
>       IF (kgen_istrue) THEN 
>           IF (ALLOCATED( var )) THEN 
>               DEALLOCATE (var) 
>           END IF   
>           READ (UNIT = kgen_unit) kgen_array_sum 
>           READ (UNIT = kgen_unit) kgen_bound(1, 1) 
>           READ (UNIT = kgen_unit) kgen_bound(2, 1) 
>           READ (UNIT = kgen_unit) kgen_bound(1, 2) 
>           READ (UNIT = kgen_unit) kgen_bound(2, 2) 
>           ALLOCATE (var(kgen_bound(1,1):kgen_bound(2,1), kgen_bound(1,2):kgen_bound(2,2))) 
>           READ (UNIT = kgen_unit) var 
>           CALL kgen_array_sumcheck(printname, kgen_array_sum, REAL(SUM(var, mask=(var .eq. var)), 8), .TRUE.) 
>           IF (PRESENT( printvar ) .AND. printvar) THEN 
>               WRITE (*, *) "KGEN DEBUG: REAL(SUM(" // printname // "), 8) = ", REAL(SUM(var, mask=(var .eq. var)), 8) 
>           END IF   
>       END IF   
>         
>   END SUBROUTINE kr_kgen_ty_gas_optics_specification_subp7 
>     
>   !write state subroutine for kr_kgen_ty_gas_optics_specification_subp8 
>   SUBROUTINE kr_kgen_ty_gas_optics_specification_subp8(var, kgen_unit, printname, printvar) 
>       REAL(KIND=wp), INTENT(INOUT), ALLOCATABLE, DIMENSION(:) :: var 
>       INTEGER, INTENT(IN) :: kgen_unit 
>       CHARACTER(LEN=*), INTENT(IN) :: printname 
>       LOGICAL, INTENT(IN), OPTIONAL :: printvar 
>       LOGICAL :: kgen_istrue 
>       REAL(KIND=8) :: kgen_array_sum 
>       INTEGER :: idx1 
>       INTEGER, DIMENSION(2,1) :: kgen_bound 
>         
>       READ (UNIT = kgen_unit) kgen_istrue 
>       IF (kgen_istrue) THEN 
>           IF (ALLOCATED( var )) THEN 
>               DEALLOCATE (var) 
>           END IF   
>           READ (UNIT = kgen_unit) kgen_array_sum 
>           READ (UNIT = kgen_unit) kgen_bound(1, 1) 
>           READ (UNIT = kgen_unit) kgen_bound(2, 1) 
>           ALLOCATE (var(kgen_bound(1,1):kgen_bound(2,1))) 
>           READ (UNIT = kgen_unit) var 
>           CALL kgen_array_sumcheck(printname, kgen_array_sum, REAL(SUM(var, mask=(var .eq. var)), 8), .TRUE.) 
>           IF (PRESENT( printvar ) .AND. printvar) THEN 
>               WRITE (*, *) "KGEN DEBUG: REAL(SUM(" // printname // "), 8) = ", REAL(SUM(var, mask=(var .eq. var)), 8) 
>           END IF   
>       END IF   
>         
>   END SUBROUTINE kr_kgen_ty_gas_optics_specification_subp8 
>     
>   !write state subroutine for kr_kgen_ty_gas_optics_specification_subp9 
>   SUBROUTINE kr_kgen_ty_gas_optics_specification_subp9(var, kgen_unit, printname, printvar) 
>       REAL(KIND=wp), INTENT(INOUT), ALLOCATABLE, DIMENSION(:,:,:) :: var 
>       INTEGER, INTENT(IN) :: kgen_unit 
>       CHARACTER(LEN=*), INTENT(IN) :: printname 
>       LOGICAL, INTENT(IN), OPTIONAL :: printvar 
>       LOGICAL :: kgen_istrue 
>       REAL(KIND=8) :: kgen_array_sum 
>       INTEGER :: idx1, idx2, idx3 
>       INTEGER, DIMENSION(2,3) :: kgen_bound 
>         
>       READ (UNIT = kgen_unit) kgen_istrue 
>       IF (kgen_istrue) THEN 
>           IF (ALLOCATED( var )) THEN 
>               DEALLOCATE (var) 
>           END IF   
>           READ (UNIT = kgen_unit) kgen_array_sum 
>           READ (UNIT = kgen_unit) kgen_bound(1, 1) 
>           READ (UNIT = kgen_unit) kgen_bound(2, 1) 
>           READ (UNIT = kgen_unit) kgen_bound(1, 2) 
>           READ (UNIT = kgen_unit) kgen_bound(2, 2) 
>           READ (UNIT = kgen_unit) kgen_bound(1, 3) 
>           READ (UNIT = kgen_unit) kgen_bound(2, 3) 
>           ALLOCATE (var(kgen_bound(1,1):kgen_bound(2,1), kgen_bound(1,2):kgen_bound(2,2), kgen_bound(1,3):kgen_bound(2,3))) 
>           READ (UNIT = kgen_unit) var 
>           CALL kgen_array_sumcheck(printname, kgen_array_sum, REAL(SUM(var, mask=(var .eq. var)), 8), .TRUE.) 
>           IF (PRESENT( printvar ) .AND. printvar) THEN 
>               WRITE (*, *) "KGEN DEBUG: REAL(SUM(" // printname // "), 8) = ", REAL(SUM(var, mask=(var .eq. var)), 8) 
>           END IF   
>       END IF   
>         
>   END SUBROUTINE kr_kgen_ty_gas_optics_specification_subp9 
>     
>   !write state subroutine for kr_kgen_ty_gas_optics_specification_subp10 
>   SUBROUTINE kr_kgen_ty_gas_optics_specification_subp10(var, kgen_unit, printname, printvar) 
>       REAL(KIND=wp), INTENT(INOUT), ALLOCATABLE, DIMENSION(:,:,:,:) :: var 
>       INTEGER, INTENT(IN) :: kgen_unit 
>       CHARACTER(LEN=*), INTENT(IN) :: printname 
>       LOGICAL, INTENT(IN), OPTIONAL :: printvar 
>       LOGICAL :: kgen_istrue 
>       REAL(KIND=8) :: kgen_array_sum 
>       INTEGER :: idx1, idx2, idx3, idx4 
>       INTEGER, DIMENSION(2,4) :: kgen_bound 
>         
>       READ (UNIT = kgen_unit) kgen_istrue 
>       IF (kgen_istrue) THEN 
>           IF (ALLOCATED( var )) THEN 
>               DEALLOCATE (var) 
>           END IF   
>           READ (UNIT = kgen_unit) kgen_array_sum 
>           READ (UNIT = kgen_unit) kgen_bound(1, 1) 
>           READ (UNIT = kgen_unit) kgen_bound(2, 1) 
>           READ (UNIT = kgen_unit) kgen_bound(1, 2) 
>           READ (UNIT = kgen_unit) kgen_bound(2, 2) 
>           READ (UNIT = kgen_unit) kgen_bound(1, 3) 
>           READ (UNIT = kgen_unit) kgen_bound(2, 3) 
>           READ (UNIT = kgen_unit) kgen_bound(1, 4) 
>           READ (UNIT = kgen_unit) kgen_bound(2, 4) 
>           ALLOCATE (var(kgen_bound(1,1):kgen_bound(2,1), kgen_bound(1,2):kgen_bound(2,2), kgen_bound(1,3):kgen_bound(2,3), &
>           &kgen_bound(1,4):kgen_bound(2,4))) 
>           READ (UNIT = kgen_unit) var 
>           CALL kgen_array_sumcheck(printname, kgen_array_sum, REAL(SUM(var, mask=(var .eq. var)), 8), .TRUE.) 
>           IF (PRESENT( printvar ) .AND. printvar) THEN 
>               WRITE (*, *) "KGEN DEBUG: REAL(SUM(" // printname // "), 8) = ", REAL(SUM(var, mask=(var .eq. var)), 8) 
>           END IF   
>       END IF   
>         
>   END SUBROUTINE kr_kgen_ty_gas_optics_specification_subp10 
>     
>   !write state subroutine for kr_kgen_ty_gas_optics_specification_subp11 
>   SUBROUTINE kr_kgen_ty_gas_optics_specification_subp11(var, kgen_unit, printname, printvar) 
>       LOGICAL, INTENT(INOUT), ALLOCATABLE, DIMENSION(:) :: var 
>       INTEGER, INTENT(IN) :: kgen_unit 
>       CHARACTER(LEN=*), INTENT(IN) :: printname 
>       LOGICAL, INTENT(IN), OPTIONAL :: printvar 
>       LOGICAL :: kgen_istrue 
>       REAL(KIND=8) :: kgen_array_sum 
>       INTEGER :: idx1 
>       INTEGER, DIMENSION(2,1) :: kgen_bound 
>         
>       READ (UNIT = kgen_unit) kgen_istrue 
>       IF (kgen_istrue) THEN 
>           IF (ALLOCATED( var )) THEN 
>               DEALLOCATE (var) 
>           END IF   
>           READ (UNIT = kgen_unit) kgen_bound(1, 1) 
>           READ (UNIT = kgen_unit) kgen_bound(2, 1) 
>           ALLOCATE (var(kgen_bound(1,1):kgen_bound(2,1))) 
>           READ (UNIT = kgen_unit) var 
>           IF (PRESENT( printvar ) .AND. printvar) THEN 
>               WRITE (*, *) "KGEN DEBUG: " // printname // " = ", var 
>           END IF   
>       END IF   
>         
>   END SUBROUTINE kr_kgen_ty_gas_optics_specification_subp11 
>     
>   !verify state subroutine for kv_kgen_mo_gas_optics_specification_typesubp0 
>   RECURSIVE SUBROUTINE kv_kgen_mo_gas_optics_specification_typesubp0(varname, check_status, var, kgenref_var) 
>       CHARACTER(LEN=*), INTENT(IN) :: varname 
>       TYPE(check_t), INTENT(INOUT) :: check_status 
>       TYPE(ty_gas_optics_specification), INTENT(IN) :: var, kgenref_var 
>       TYPE(check_t) :: dtype_check_status, comp_check_status 
>       INTEGER :: check_result 
>       LOGICAL :: is_print = .FALSE. 
>         
>       INTEGER :: n_gas_names 
>       INTEGER :: n_flavor 
>       integer :: nrmsdiff_flavor, rmsdiff_flavor 
>       integer, ALLOCATABLE :: buf1_flavor(:,:), buf2_flavor(:,:) 
>       INTEGER :: n_gpoint_flavor 
>       integer :: nrmsdiff_gpoint_flavor, rmsdiff_gpoint_flavor 
>       integer, ALLOCATABLE :: buf1_gpoint_flavor(:,:), buf2_gpoint_flavor(:,:) 
>       INTEGER :: n_band2gpt 
>       integer :: nrmsdiff_band2gpt, rmsdiff_band2gpt 
>       integer, ALLOCATABLE :: buf1_band2gpt(:,:), buf2_band2gpt(:,:) 
>       INTEGER :: n_gpt2band 
>       integer :: nrmsdiff_gpt2band, rmsdiff_gpt2band 
>       integer, ALLOCATABLE :: buf1_gpt2band(:), buf2_gpt2band(:) 
>       INTEGER :: n_band_lims_wavenum 
>       real(KIND=wp) :: nrmsdiff_band_lims_wavenum, rmsdiff_band_lims_wavenum 
>       real(KIND=wp), ALLOCATABLE :: buf1_band_lims_wavenum(:,:), buf2_band_lims_wavenum(:,:) 
>       INTEGER :: n_press_ref 
>       real(KIND=wp) :: nrmsdiff_press_ref, rmsdiff_press_ref 
>       real(KIND=wp), ALLOCATABLE :: buf1_press_ref(:), buf2_press_ref(:) 
>       INTEGER :: n_press_ref_log 
>       real(KIND=wp) :: nrmsdiff_press_ref_log, rmsdiff_press_ref_log 
>       real(KIND=wp), ALLOCATABLE :: buf1_press_ref_log(:), buf2_press_ref_log(:) 
>       INTEGER :: n_temp_ref 
>       real(KIND=wp) :: nrmsdiff_temp_ref, rmsdiff_temp_ref 
>       real(KIND=wp), ALLOCATABLE :: buf1_temp_ref(:), buf2_temp_ref(:) 
>       INTEGER :: n_vmr_ref 
>       real(KIND=wp) :: nrmsdiff_vmr_ref, rmsdiff_vmr_ref 
>       real(KIND=wp), ALLOCATABLE :: buf1_vmr_ref(:,:,:), buf2_vmr_ref(:,:,:) 
>       real(KIND=wp) :: diff_press_ref_min 
>       real(KIND=wp) :: diff_press_ref_max 
>       real(KIND=wp) :: diff_temp_ref_min 
>       real(KIND=wp) :: diff_temp_ref_max 
>       real(KIND=wp) :: diff_press_ref_log_delta 
>       real(KIND=wp) :: diff_temp_ref_delta 
>       real(KIND=wp) :: diff_press_ref_trop_log 
>       real(KIND=wp) :: diff_stpfac 
>       INTEGER :: n_kmajor 
>       real(KIND=wp) :: nrmsdiff_kmajor, rmsdiff_kmajor 
>       real(KIND=wp), ALLOCATABLE :: buf1_kmajor(:,:,:,:), buf2_kmajor(:,:,:,:) 
>       INTEGER :: n_selfrefin 
>       real(KIND=wp) :: nrmsdiff_selfrefin, rmsdiff_selfrefin 
>       real(KIND=wp), ALLOCATABLE :: buf1_selfrefin(:,:,:), buf2_selfrefin(:,:,:) 
>       INTEGER :: n_forrefin 
>       real(KIND=wp) :: nrmsdiff_forrefin, rmsdiff_forrefin 
>       real(KIND=wp), ALLOCATABLE :: buf1_forrefin(:,:,:), buf2_forrefin(:,:,:) 
>       INTEGER :: n_kminor_lower 
>       real(KIND=wp) :: nrmsdiff_kminor_lower, rmsdiff_kminor_lower 
>       real(KIND=wp), ALLOCATABLE :: buf1_kminor_lower(:,:,:,:), buf2_kminor_lower(:,:,:,:) 
>       INTEGER :: n_kminor_upper 
>       real(KIND=wp) :: nrmsdiff_kminor_upper, rmsdiff_kminor_upper 
>       real(KIND=wp), ALLOCATABLE :: buf1_kminor_upper(:,:,:,:), buf2_kminor_upper(:,:,:,:) 
>       INTEGER :: n_krayl 
>       real(KIND=wp) :: nrmsdiff_krayl, rmsdiff_krayl 
>       real(KIND=wp), ALLOCATABLE :: buf1_krayl(:,:,:,:), buf2_krayl(:,:,:,:) 
>       INTEGER :: n_planck_frac 
>       real(KIND=wp) :: nrmsdiff_planck_frac, rmsdiff_planck_frac 
>       real(KIND=wp), ALLOCATABLE :: buf1_planck_frac(:,:,:,:), buf2_planck_frac(:,:,:,:) 
>       INTEGER :: n_totplnk 
>       real(KIND=wp) :: nrmsdiff_totplnk, rmsdiff_totplnk 
>       real(KIND=wp), ALLOCATABLE :: buf1_totplnk(:,:), buf2_totplnk(:,:) 
>       real(KIND=wp) :: diff_totplnk_delta 
>       INTEGER :: n_solar_src 
>       real(KIND=wp) :: nrmsdiff_solar_src, rmsdiff_solar_src 
>       real(KIND=wp), ALLOCATABLE :: buf1_solar_src(:), buf2_solar_src(:) 
>       INTEGER :: n_kminor_activity 
>       integer :: nrmsdiff_kminor_activity, rmsdiff_kminor_activity 
>       integer, ALLOCATABLE :: buf1_kminor_activity(:,:), buf2_kminor_activity(:,:) 
>       INTEGER :: n_is_key 
>         
>       check_status%numTotal = check_status%numTotal + 1 
>         
>       CALL kgen_init_check(dtype_check_status, verboseLevel=check_status%verboseLevel) 
>       IF (ALLOCATED(var%gas_names)) THEN 
>           dtype_check_status%numTotal = dtype_check_status%numTotal + 1 
>           IF (ALL(var%gas_names == kgenref_var%gas_names)) THEN 
>               dtype_check_status%numIdentical = dtype_check_status%numIdentical + 1 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%gas_names is IDENTICAL." 
>               END IF   
>               check_result = CHECK_IDENTICAL 
>           ELSE 
>               n_gas_names = COUNT(var%gas_names /= kgenref_var%gas_names) 
>               dtype_check_status%numOutTol = dtype_check_status%numOutTol + 1 
>               IF (check_status%verboseLevel > 1) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%gas_names is NOT IDENTICAL(out of tolerance)." 
>               END IF   
>               check_result = CHECK_OUT_TOL 
>           END IF   
>           IF (check_result == CHECK_IDENTICAL) THEN 
>               CONTINUE 
>           ELSE IF (check_result == CHECK_OUT_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) "NOT IMPLEMENTED YET" 
>                   WRITE (*, *) "" 
>               END IF   
>           ELSE IF (check_result == CHECK_IN_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) "NOT IMPLEMENTED YET" 
>                   WRITE (*, *) "" 
>               END IF   
>           END IF   
>             
>       END IF   
>       IF (ALLOCATED(var%flavor)) THEN 
>           dtype_check_status%numTotal = dtype_check_status%numTotal + 1 
>           IF (ALL(var%flavor == kgenref_var%flavor)) THEN 
>               dtype_check_status%numIdentical = dtype_check_status%numIdentical + 1 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%flavor is IDENTICAL." 
>               END IF   
>               check_result = CHECK_IDENTICAL 
>           ELSE 
>               ALLOCATE (buf1_flavor(SIZE(var%flavor,dim=1),SIZE(var%flavor,dim=2))) 
>               ALLOCATE (buf2_flavor(SIZE(var%flavor,dim=1),SIZE(var%flavor,dim=2))) 
>               n_flavor = COUNT(var%flavor /= kgenref_var%flavor) 
>               WHERE ( ABS(kgenref_var%flavor) > kgen_minvalue ) 
>                   buf1_flavor = ((var%flavor-kgenref_var%flavor)/kgenref_var%flavor)**2 
>                   buf2_flavor = (var%flavor-kgenref_var%flavor)**2 
>               ELSEWHERE 
>                   buf1_flavor = (var%flavor-kgenref_var%flavor)**2 
>                   buf2_flavor = buf1_flavor 
>               END WHERE   
>               nrmsdiff_flavor = SQRT(SUM(buf1_flavor)/REAL(n_flavor)) 
>               rmsdiff_flavor = SQRT(SUM(buf2_flavor)/REAL(n_flavor)) 
>               IF (nrmsdiff_flavor > kgen_tolerance) THEN 
>                   dtype_check_status%numOutTol = dtype_check_status%numOutTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%flavor is NOT IDENTICAL(out of tolerance)." 
>                   END IF   
>                   check_result = CHECK_OUT_TOL 
>               ELSE 
>                   dtype_check_status%numInTol = dtype_check_status%numInTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%flavor is NOT IDENTICAL(within tolerance)." 
>                   END IF   
>                   check_result = CHECK_IN_TOL 
>               END IF   
>           END IF   
>           IF (check_result == CHECK_IDENTICAL) THEN 
>               CONTINUE 
>           ELSE IF (check_result == CHECK_OUT_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%flavor /= kgenref_var%flavor), " of ", size( var%flavor ), " elements are different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%flavor)/real(size(var%flavor)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%flavor)/real(size(kgenref_var%flavor)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_flavor 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_flavor 
>                   WRITE (*, *) "" 
>               END IF   
>           ELSE IF (check_result == CHECK_IN_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%flavor /= kgenref_var%flavor), " of ", size( var%flavor ), " elements are different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%flavor)/real(size(var%flavor)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%flavor)/real(size(kgenref_var%flavor)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_flavor 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_flavor 
>                   WRITE (*, *) "" 
>               END IF   
>           END IF   
>             
>       END IF   
>       IF (ALLOCATED(var%gpoint_flavor)) THEN 
>           dtype_check_status%numTotal = dtype_check_status%numTotal + 1 
>           IF (ALL(var%gpoint_flavor == kgenref_var%gpoint_flavor)) THEN 
>               dtype_check_status%numIdentical = dtype_check_status%numIdentical + 1 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%gpoint_flavor is IDENTICAL." 
>               END IF   
>               check_result = CHECK_IDENTICAL 
>           ELSE 
>               ALLOCATE (buf1_gpoint_flavor(SIZE(var%gpoint_flavor,dim=1),SIZE(var%gpoint_flavor,dim=2))) 
>               ALLOCATE (buf2_gpoint_flavor(SIZE(var%gpoint_flavor,dim=1),SIZE(var%gpoint_flavor,dim=2))) 
>               n_gpoint_flavor = COUNT(var%gpoint_flavor /= kgenref_var%gpoint_flavor) 
>               WHERE ( ABS(kgenref_var%gpoint_flavor) > kgen_minvalue ) 
>                   buf1_gpoint_flavor = ((var%gpoint_flavor-kgenref_var%gpoint_flavor)/kgenref_var%gpoint_flavor)**2 
>                   buf2_gpoint_flavor = (var%gpoint_flavor-kgenref_var%gpoint_flavor)**2 
>               ELSEWHERE 
>                   buf1_gpoint_flavor = (var%gpoint_flavor-kgenref_var%gpoint_flavor)**2 
>                   buf2_gpoint_flavor = buf1_gpoint_flavor 
>               END WHERE   
>               nrmsdiff_gpoint_flavor = SQRT(SUM(buf1_gpoint_flavor)/REAL(n_gpoint_flavor)) 
>               rmsdiff_gpoint_flavor = SQRT(SUM(buf2_gpoint_flavor)/REAL(n_gpoint_flavor)) 
>               IF (nrmsdiff_gpoint_flavor > kgen_tolerance) THEN 
>                   dtype_check_status%numOutTol = dtype_check_status%numOutTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%gpoint_flavor is NOT IDENTICAL(out of tolerance)." 
>                   END IF   
>                   check_result = CHECK_OUT_TOL 
>               ELSE 
>                   dtype_check_status%numInTol = dtype_check_status%numInTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%gpoint_flavor is NOT IDENTICAL(within tolerance)." 
>                   END IF   
>                   check_result = CHECK_IN_TOL 
>               END IF   
>           END IF   
>           IF (check_result == CHECK_IDENTICAL) THEN 
>               CONTINUE 
>           ELSE IF (check_result == CHECK_OUT_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%gpoint_flavor /= kgenref_var%gpoint_flavor), " of ", size( var%gpoint_flavor ), " &
>                   &elements are different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%gpoint_flavor)/real(size(var%gpoint_flavor)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%gpoint_flavor)/real(size(kgenref_var%gpoint_flavor)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_gpoint_flavor 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_gpoint_flavor 
>                   WRITE (*, *) "" 
>               END IF   
>           ELSE IF (check_result == CHECK_IN_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%gpoint_flavor /= kgenref_var%gpoint_flavor), " of ", size( var%gpoint_flavor ), " &
>                   &elements are different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%gpoint_flavor)/real(size(var%gpoint_flavor)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%gpoint_flavor)/real(size(kgenref_var%gpoint_flavor)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_gpoint_flavor 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_gpoint_flavor 
>                   WRITE (*, *) "" 
>               END IF   
>           END IF   
>             
>       END IF   
>       IF (ALLOCATED(var%band2gpt)) THEN 
>           dtype_check_status%numTotal = dtype_check_status%numTotal + 1 
>           IF (ALL(var%band2gpt == kgenref_var%band2gpt)) THEN 
>               dtype_check_status%numIdentical = dtype_check_status%numIdentical + 1 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%band2gpt is IDENTICAL." 
>               END IF   
>               check_result = CHECK_IDENTICAL 
>           ELSE 
>               ALLOCATE (buf1_band2gpt(SIZE(var%band2gpt,dim=1),SIZE(var%band2gpt,dim=2))) 
>               ALLOCATE (buf2_band2gpt(SIZE(var%band2gpt,dim=1),SIZE(var%band2gpt,dim=2))) 
>               n_band2gpt = COUNT(var%band2gpt /= kgenref_var%band2gpt) 
>               WHERE ( ABS(kgenref_var%band2gpt) > kgen_minvalue ) 
>                   buf1_band2gpt = ((var%band2gpt-kgenref_var%band2gpt)/kgenref_var%band2gpt)**2 
>                   buf2_band2gpt = (var%band2gpt-kgenref_var%band2gpt)**2 
>               ELSEWHERE 
>                   buf1_band2gpt = (var%band2gpt-kgenref_var%band2gpt)**2 
>                   buf2_band2gpt = buf1_band2gpt 
>               END WHERE   
>               nrmsdiff_band2gpt = SQRT(SUM(buf1_band2gpt)/REAL(n_band2gpt)) 
>               rmsdiff_band2gpt = SQRT(SUM(buf2_band2gpt)/REAL(n_band2gpt)) 
>               IF (nrmsdiff_band2gpt > kgen_tolerance) THEN 
>                   dtype_check_status%numOutTol = dtype_check_status%numOutTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%band2gpt is NOT IDENTICAL(out of tolerance)." 
>                   END IF   
>                   check_result = CHECK_OUT_TOL 
>               ELSE 
>                   dtype_check_status%numInTol = dtype_check_status%numInTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%band2gpt is NOT IDENTICAL(within tolerance)." 
>                   END IF   
>                   check_result = CHECK_IN_TOL 
>               END IF   
>           END IF   
>           IF (check_result == CHECK_IDENTICAL) THEN 
>               CONTINUE 
>           ELSE IF (check_result == CHECK_OUT_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%band2gpt /= kgenref_var%band2gpt), " of ", size( var%band2gpt ), " elements are &
>                   &different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%band2gpt)/real(size(var%band2gpt)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%band2gpt)/real(size(kgenref_var%band2gpt)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_band2gpt 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_band2gpt 
>                   WRITE (*, *) "" 
>               END IF   
>           ELSE IF (check_result == CHECK_IN_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%band2gpt /= kgenref_var%band2gpt), " of ", size( var%band2gpt ), " elements are &
>                   &different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%band2gpt)/real(size(var%band2gpt)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%band2gpt)/real(size(kgenref_var%band2gpt)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_band2gpt 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_band2gpt 
>                   WRITE (*, *) "" 
>               END IF   
>           END IF   
>             
>       END IF   
>       IF (ALLOCATED(var%gpt2band)) THEN 
>           dtype_check_status%numTotal = dtype_check_status%numTotal + 1 
>           IF (ALL(var%gpt2band == kgenref_var%gpt2band)) THEN 
>               dtype_check_status%numIdentical = dtype_check_status%numIdentical + 1 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%gpt2band is IDENTICAL." 
>               END IF   
>               check_result = CHECK_IDENTICAL 
>           ELSE 
>               ALLOCATE (buf1_gpt2band(SIZE(var%gpt2band,dim=1))) 
>               ALLOCATE (buf2_gpt2band(SIZE(var%gpt2band,dim=1))) 
>               n_gpt2band = COUNT(var%gpt2band /= kgenref_var%gpt2band) 
>               WHERE ( ABS(kgenref_var%gpt2band) > kgen_minvalue ) 
>                   buf1_gpt2band = ((var%gpt2band-kgenref_var%gpt2band)/kgenref_var%gpt2band)**2 
>                   buf2_gpt2band = (var%gpt2band-kgenref_var%gpt2band)**2 
>               ELSEWHERE 
>                   buf1_gpt2band = (var%gpt2band-kgenref_var%gpt2band)**2 
>                   buf2_gpt2band = buf1_gpt2band 
>               END WHERE   
>               nrmsdiff_gpt2band = SQRT(SUM(buf1_gpt2band)/REAL(n_gpt2band)) 
>               rmsdiff_gpt2band = SQRT(SUM(buf2_gpt2band)/REAL(n_gpt2band)) 
>               IF (nrmsdiff_gpt2band > kgen_tolerance) THEN 
>                   dtype_check_status%numOutTol = dtype_check_status%numOutTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%gpt2band is NOT IDENTICAL(out of tolerance)." 
>                   END IF   
>                   check_result = CHECK_OUT_TOL 
>               ELSE 
>                   dtype_check_status%numInTol = dtype_check_status%numInTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%gpt2band is NOT IDENTICAL(within tolerance)." 
>                   END IF   
>                   check_result = CHECK_IN_TOL 
>               END IF   
>           END IF   
>           IF (check_result == CHECK_IDENTICAL) THEN 
>               CONTINUE 
>           ELSE IF (check_result == CHECK_OUT_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%gpt2band /= kgenref_var%gpt2band), " of ", size( var%gpt2band ), " elements are &
>                   &different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%gpt2band)/real(size(var%gpt2band)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%gpt2band)/real(size(kgenref_var%gpt2band)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_gpt2band 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_gpt2band 
>                   WRITE (*, *) "" 
>               END IF   
>           ELSE IF (check_result == CHECK_IN_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%gpt2band /= kgenref_var%gpt2band), " of ", size( var%gpt2band ), " elements are &
>                   &different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%gpt2band)/real(size(var%gpt2band)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%gpt2band)/real(size(kgenref_var%gpt2band)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_gpt2band 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_gpt2band 
>                   WRITE (*, *) "" 
>               END IF   
>           END IF   
>             
>       END IF   
>       IF (ALLOCATED(var%band_lims_wavenum)) THEN 
>           dtype_check_status%numTotal = dtype_check_status%numTotal + 1 
>           IF (ALL(var%band_lims_wavenum == kgenref_var%band_lims_wavenum)) THEN 
>               dtype_check_status%numIdentical = dtype_check_status%numIdentical + 1 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%band_lims_wavenum is IDENTICAL." 
>               END IF   
>               check_result = CHECK_IDENTICAL 
>           ELSE 
>               ALLOCATE (buf1_band_lims_wavenum(SIZE(var%band_lims_wavenum,dim=1),SIZE(var%band_lims_wavenum,dim=2))) 
>               ALLOCATE (buf2_band_lims_wavenum(SIZE(var%band_lims_wavenum,dim=1),SIZE(var%band_lims_wavenum,dim=2))) 
>               n_band_lims_wavenum = COUNT(var%band_lims_wavenum /= kgenref_var%band_lims_wavenum) 
>               WHERE ( ABS(kgenref_var%band_lims_wavenum) > kgen_minvalue ) 
>                   buf1_band_lims_wavenum = &
>                   &((var%band_lims_wavenum-kgenref_var%band_lims_wavenum)/kgenref_var%band_lims_wavenum)**2 
>                   buf2_band_lims_wavenum = (var%band_lims_wavenum-kgenref_var%band_lims_wavenum)**2 
>               ELSEWHERE 
>                   buf1_band_lims_wavenum = (var%band_lims_wavenum-kgenref_var%band_lims_wavenum)**2 
>                   buf2_band_lims_wavenum = buf1_band_lims_wavenum 
>               END WHERE   
>               nrmsdiff_band_lims_wavenum = SQRT(SUM(buf1_band_lims_wavenum)/REAL(n_band_lims_wavenum)) 
>               rmsdiff_band_lims_wavenum = SQRT(SUM(buf2_band_lims_wavenum)/REAL(n_band_lims_wavenum)) 
>               IF (nrmsdiff_band_lims_wavenum > kgen_tolerance) THEN 
>                   dtype_check_status%numOutTol = dtype_check_status%numOutTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%band_lims_wavenum is NOT IDENTICAL(out of tolerance)." 
>                   END IF   
>                   check_result = CHECK_OUT_TOL 
>               ELSE 
>                   dtype_check_status%numInTol = dtype_check_status%numInTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%band_lims_wavenum is NOT IDENTICAL(within tolerance)." 
>                   END IF   
>                   check_result = CHECK_IN_TOL 
>               END IF   
>           END IF   
>           IF (check_result == CHECK_IDENTICAL) THEN 
>               CONTINUE 
>           ELSE IF (check_result == CHECK_OUT_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%band_lims_wavenum /= kgenref_var%band_lims_wavenum), " of ", size( &
>                   &var%band_lims_wavenum ), " elements are different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%band_lims_wavenum)/real(size(var%band_lims_wavenum)) 
>                   WRITE (*, *) "Average - reference ", &
>                   &sum(kgenref_var%band_lims_wavenum)/real(size(kgenref_var%band_lims_wavenum)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_band_lims_wavenum 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_band_lims_wavenum 
>                   WRITE (*, *) "" 
>               END IF   
>           ELSE IF (check_result == CHECK_IN_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%band_lims_wavenum /= kgenref_var%band_lims_wavenum), " of ", size( &
>                   &var%band_lims_wavenum ), " elements are different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%band_lims_wavenum)/real(size(var%band_lims_wavenum)) 
>                   WRITE (*, *) "Average - reference ", &
>                   &sum(kgenref_var%band_lims_wavenum)/real(size(kgenref_var%band_lims_wavenum)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_band_lims_wavenum 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_band_lims_wavenum 
>                   WRITE (*, *) "" 
>               END IF   
>           END IF   
>             
>       END IF   
>       IF (ALLOCATED(var%press_ref)) THEN 
>           dtype_check_status%numTotal = dtype_check_status%numTotal + 1 
>           IF (ALL(var%press_ref == kgenref_var%press_ref)) THEN 
>               dtype_check_status%numIdentical = dtype_check_status%numIdentical + 1 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%press_ref is IDENTICAL." 
>               END IF   
>               check_result = CHECK_IDENTICAL 
>           ELSE 
>               ALLOCATE (buf1_press_ref(SIZE(var%press_ref,dim=1))) 
>               ALLOCATE (buf2_press_ref(SIZE(var%press_ref,dim=1))) 
>               n_press_ref = COUNT(var%press_ref /= kgenref_var%press_ref) 
>               WHERE ( ABS(kgenref_var%press_ref) > kgen_minvalue ) 
>                   buf1_press_ref = ((var%press_ref-kgenref_var%press_ref)/kgenref_var%press_ref)**2 
>                   buf2_press_ref = (var%press_ref-kgenref_var%press_ref)**2 
>               ELSEWHERE 
>                   buf1_press_ref = (var%press_ref-kgenref_var%press_ref)**2 
>                   buf2_press_ref = buf1_press_ref 
>               END WHERE   
>               nrmsdiff_press_ref = SQRT(SUM(buf1_press_ref)/REAL(n_press_ref)) 
>               rmsdiff_press_ref = SQRT(SUM(buf2_press_ref)/REAL(n_press_ref)) 
>               IF (nrmsdiff_press_ref > kgen_tolerance) THEN 
>                   dtype_check_status%numOutTol = dtype_check_status%numOutTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%press_ref is NOT IDENTICAL(out of tolerance)." 
>                   END IF   
>                   check_result = CHECK_OUT_TOL 
>               ELSE 
>                   dtype_check_status%numInTol = dtype_check_status%numInTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%press_ref is NOT IDENTICAL(within tolerance)." 
>                   END IF   
>                   check_result = CHECK_IN_TOL 
>               END IF   
>           END IF   
>           IF (check_result == CHECK_IDENTICAL) THEN 
>               CONTINUE 
>           ELSE IF (check_result == CHECK_OUT_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%press_ref /= kgenref_var%press_ref), " of ", size( var%press_ref ), " elements are &
>                   &different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%press_ref)/real(size(var%press_ref)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%press_ref)/real(size(kgenref_var%press_ref)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_press_ref 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_press_ref 
>                   WRITE (*, *) "" 
>               END IF   
>           ELSE IF (check_result == CHECK_IN_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%press_ref /= kgenref_var%press_ref), " of ", size( var%press_ref ), " elements are &
>                   &different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%press_ref)/real(size(var%press_ref)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%press_ref)/real(size(kgenref_var%press_ref)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_press_ref 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_press_ref 
>                   WRITE (*, *) "" 
>               END IF   
>           END IF   
>       END IF   
>       IF (ALLOCATED(var%press_ref_log)) THEN 
>           dtype_check_status%numTotal = dtype_check_status%numTotal + 1 
>           IF (ALL(var%press_ref_log == kgenref_var%press_ref_log)) THEN 
>               dtype_check_status%numIdentical = dtype_check_status%numIdentical + 1 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%press_ref_log is IDENTICAL." 
>               END IF   
>               check_result = CHECK_IDENTICAL 
>           ELSE 
>               ALLOCATE (buf1_press_ref_log(SIZE(var%press_ref_log,dim=1))) 
>               ALLOCATE (buf2_press_ref_log(SIZE(var%press_ref_log,dim=1))) 
>               n_press_ref_log = COUNT(var%press_ref_log /= kgenref_var%press_ref_log) 
>               WHERE ( ABS(kgenref_var%press_ref_log) > kgen_minvalue ) 
>                   buf1_press_ref_log = ((var%press_ref_log-kgenref_var%press_ref_log)/kgenref_var%press_ref_log)**2 
>                   buf2_press_ref_log = (var%press_ref_log-kgenref_var%press_ref_log)**2 
>               ELSEWHERE 
>                   buf1_press_ref_log = (var%press_ref_log-kgenref_var%press_ref_log)**2 
>                   buf2_press_ref_log = buf1_press_ref_log 
>               END WHERE   
>               nrmsdiff_press_ref_log = SQRT(SUM(buf1_press_ref_log)/REAL(n_press_ref_log)) 
>               rmsdiff_press_ref_log = SQRT(SUM(buf2_press_ref_log)/REAL(n_press_ref_log)) 
>               IF (nrmsdiff_press_ref_log > kgen_tolerance) THEN 
>                   dtype_check_status%numOutTol = dtype_check_status%numOutTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%press_ref_log is NOT IDENTICAL(out of tolerance)." 
>                   END IF   
>                   check_result = CHECK_OUT_TOL 
>               ELSE 
>                   dtype_check_status%numInTol = dtype_check_status%numInTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%press_ref_log is NOT IDENTICAL(within tolerance)." 
>                   END IF   
>                   check_result = CHECK_IN_TOL 
>               END IF   
>           END IF   
>           IF (check_result == CHECK_IDENTICAL) THEN 
>               CONTINUE 
>           ELSE IF (check_result == CHECK_OUT_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%press_ref_log /= kgenref_var%press_ref_log), " of ", size( var%press_ref_log ), " &
>                   &elements are different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%press_ref_log)/real(size(var%press_ref_log)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%press_ref_log)/real(size(kgenref_var%press_ref_log)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_press_ref_log 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_press_ref_log 
>                   WRITE (*, *) "" 
>               END IF   
>           ELSE IF (check_result == CHECK_IN_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%press_ref_log /= kgenref_var%press_ref_log), " of ", size( var%press_ref_log ), " &
>                   &elements are different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%press_ref_log)/real(size(var%press_ref_log)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%press_ref_log)/real(size(kgenref_var%press_ref_log)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_press_ref_log 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_press_ref_log 
>                   WRITE (*, *) "" 
>               END IF   
>           END IF   
>       END IF   
>       IF (ALLOCATED(var%temp_ref)) THEN 
>           dtype_check_status%numTotal = dtype_check_status%numTotal + 1 
>           IF (ALL(var%temp_ref == kgenref_var%temp_ref)) THEN 
>               dtype_check_status%numIdentical = dtype_check_status%numIdentical + 1 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%temp_ref is IDENTICAL." 
>               END IF   
>               check_result = CHECK_IDENTICAL 
>           ELSE 
>               ALLOCATE (buf1_temp_ref(SIZE(var%temp_ref,dim=1))) 
>               ALLOCATE (buf2_temp_ref(SIZE(var%temp_ref,dim=1))) 
>               n_temp_ref = COUNT(var%temp_ref /= kgenref_var%temp_ref) 
>               WHERE ( ABS(kgenref_var%temp_ref) > kgen_minvalue ) 
>                   buf1_temp_ref = ((var%temp_ref-kgenref_var%temp_ref)/kgenref_var%temp_ref)**2 
>                   buf2_temp_ref = (var%temp_ref-kgenref_var%temp_ref)**2 
>               ELSEWHERE 
>                   buf1_temp_ref = (var%temp_ref-kgenref_var%temp_ref)**2 
>                   buf2_temp_ref = buf1_temp_ref 
>               END WHERE   
>               nrmsdiff_temp_ref = SQRT(SUM(buf1_temp_ref)/REAL(n_temp_ref)) 
>               rmsdiff_temp_ref = SQRT(SUM(buf2_temp_ref)/REAL(n_temp_ref)) 
>               IF (nrmsdiff_temp_ref > kgen_tolerance) THEN 
>                   dtype_check_status%numOutTol = dtype_check_status%numOutTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%temp_ref is NOT IDENTICAL(out of tolerance)." 
>                   END IF   
>                   check_result = CHECK_OUT_TOL 
>               ELSE 
>                   dtype_check_status%numInTol = dtype_check_status%numInTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%temp_ref is NOT IDENTICAL(within tolerance)." 
>                   END IF   
>                   check_result = CHECK_IN_TOL 
>               END IF   
>           END IF   
>           IF (check_result == CHECK_IDENTICAL) THEN 
>               CONTINUE 
>           ELSE IF (check_result == CHECK_OUT_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%temp_ref /= kgenref_var%temp_ref), " of ", size( var%temp_ref ), " elements are &
>                   &different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%temp_ref)/real(size(var%temp_ref)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%temp_ref)/real(size(kgenref_var%temp_ref)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_temp_ref 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_temp_ref 
>                   WRITE (*, *) "" 
>               END IF   
>           ELSE IF (check_result == CHECK_IN_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%temp_ref /= kgenref_var%temp_ref), " of ", size( var%temp_ref ), " elements are &
>                   &different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%temp_ref)/real(size(var%temp_ref)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%temp_ref)/real(size(kgenref_var%temp_ref)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_temp_ref 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_temp_ref 
>                   WRITE (*, *) "" 
>               END IF   
>           END IF   
>             
>       END IF   
>       IF (ALLOCATED(var%vmr_ref)) THEN 
>           dtype_check_status%numTotal = dtype_check_status%numTotal + 1 
>           IF (ALL(var%vmr_ref == kgenref_var%vmr_ref)) THEN 
>               dtype_check_status%numIdentical = dtype_check_status%numIdentical + 1 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%vmr_ref is IDENTICAL." 
>               END IF   
>               check_result = CHECK_IDENTICAL 
>           ELSE 
>               ALLOCATE (buf1_vmr_ref(SIZE(var%vmr_ref,dim=1),SIZE(var%vmr_ref,dim=2),SIZE(var%vmr_ref,dim=3))) 
>               ALLOCATE (buf2_vmr_ref(SIZE(var%vmr_ref,dim=1),SIZE(var%vmr_ref,dim=2),SIZE(var%vmr_ref,dim=3))) 
>               n_vmr_ref = COUNT(var%vmr_ref /= kgenref_var%vmr_ref) 
>               WHERE ( ABS(kgenref_var%vmr_ref) > kgen_minvalue ) 
>                   buf1_vmr_ref = ((var%vmr_ref-kgenref_var%vmr_ref)/kgenref_var%vmr_ref)**2 
>                   buf2_vmr_ref = (var%vmr_ref-kgenref_var%vmr_ref)**2 
>               ELSEWHERE 
>                   buf1_vmr_ref = (var%vmr_ref-kgenref_var%vmr_ref)**2 
>                   buf2_vmr_ref = buf1_vmr_ref 
>               END WHERE   
>               nrmsdiff_vmr_ref = SQRT(SUM(buf1_vmr_ref)/REAL(n_vmr_ref)) 
>               rmsdiff_vmr_ref = SQRT(SUM(buf2_vmr_ref)/REAL(n_vmr_ref)) 
>               IF (nrmsdiff_vmr_ref > kgen_tolerance) THEN 
>                   dtype_check_status%numOutTol = dtype_check_status%numOutTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%vmr_ref is NOT IDENTICAL(out of tolerance)." 
>                   END IF   
>                   check_result = CHECK_OUT_TOL 
>               ELSE 
>                   dtype_check_status%numInTol = dtype_check_status%numInTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%vmr_ref is NOT IDENTICAL(within tolerance)." 
>                   END IF   
>                   check_result = CHECK_IN_TOL 
>               END IF   
>           END IF   
>           IF (check_result == CHECK_IDENTICAL) THEN 
>               CONTINUE 
>           ELSE IF (check_result == CHECK_OUT_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%vmr_ref /= kgenref_var%vmr_ref), " of ", size( var%vmr_ref ), " elements are &
>                   &different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%vmr_ref)/real(size(var%vmr_ref)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%vmr_ref)/real(size(kgenref_var%vmr_ref)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_vmr_ref 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_vmr_ref 
>                   WRITE (*, *) "" 
>               END IF   
>           ELSE IF (check_result == CHECK_IN_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%vmr_ref /= kgenref_var%vmr_ref), " of ", size( var%vmr_ref ), " elements are &
>                   &different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%vmr_ref)/real(size(var%vmr_ref)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%vmr_ref)/real(size(kgenref_var%vmr_ref)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_vmr_ref 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_vmr_ref 
>                   WRITE (*, *) "" 
>               END IF   
>           END IF   
>             
>       END IF   
>       dtype_check_status%numTotal = dtype_check_status%numTotal + 1 
>       IF (var%press_ref_min == kgenref_var%press_ref_min) THEN 
>           dtype_check_status%numIdentical = dtype_check_status%numIdentical + 1 
>           IF (check_status%verboseLevel > 2) THEN 
>               WRITE (*, *) trim(adjustl(varname)), "%press_ref_min is IDENTICAL." 
>           END IF   
>           check_result = CHECK_IDENTICAL 
>       ELSE 
>           diff_press_ref_min = ABS(var%press_ref_min - kgenref_var%press_ref_min) 
>           IF (diff_press_ref_min <= kgen_tolerance) THEN 
>               dtype_check_status%numInTol = dtype_check_status%numInTol + 1 
>               IF (check_status%verboseLevel > 1) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%press_ref_min is NOT IDENTICAL(within tolerance)." 
>               END IF   
>               check_result = CHECK_IN_TOL 
>           ELSE 
>               dtype_check_status%numOutTol = dtype_check_status%numOutTol + 1 
>               IF (check_status%verboseLevel > 1) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%press_ref_min is NOT IDENTICAL(out of tolerance)." 
>               END IF   
>               check_result = CHECK_OUT_TOL 
>           END IF   
>       END IF   
>       IF (check_result == CHECK_IDENTICAL) THEN 
>           CONTINUE 
>       ELSE IF (check_result == CHECK_OUT_TOL) THEN 
>           IF (check_status%verboseLevel > 2) THEN 
>               WRITE (*, *) "Difference is ", diff_press_ref_min 
>               WRITE (*, *) "" 
>           END IF   
>       ELSE IF (check_result == CHECK_IN_TOL) THEN 
>           IF (check_status%verboseLevel > 2) THEN 
>               WRITE (*, *) "Difference is ", diff_press_ref_min 
>               WRITE (*, *) "" 
>           END IF   
>       END IF   
>       dtype_check_status%numTotal = dtype_check_status%numTotal + 1 
>       IF (var%press_ref_max == kgenref_var%press_ref_max) THEN 
>           dtype_check_status%numIdentical = dtype_check_status%numIdentical + 1 
>           IF (check_status%verboseLevel > 2) THEN 
>               WRITE (*, *) trim(adjustl(varname)), "%press_ref_max is IDENTICAL." 
>           END IF   
>           check_result = CHECK_IDENTICAL 
>       ELSE 
>           diff_press_ref_max = ABS(var%press_ref_max - kgenref_var%press_ref_max) 
>           IF (diff_press_ref_max <= kgen_tolerance) THEN 
>               dtype_check_status%numInTol = dtype_check_status%numInTol + 1 
>               IF (check_status%verboseLevel > 1) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%press_ref_max is NOT IDENTICAL(within tolerance)." 
>               END IF   
>               check_result = CHECK_IN_TOL 
>           ELSE 
>               dtype_check_status%numOutTol = dtype_check_status%numOutTol + 1 
>               IF (check_status%verboseLevel > 1) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%press_ref_max is NOT IDENTICAL(out of tolerance)." 
>               END IF   
>               check_result = CHECK_OUT_TOL 
>           END IF   
>       END IF   
>       IF (check_result == CHECK_IDENTICAL) THEN 
>           CONTINUE 
>       ELSE IF (check_result == CHECK_OUT_TOL) THEN 
>           IF (check_status%verboseLevel > 2) THEN 
>               WRITE (*, *) "Difference is ", diff_press_ref_max 
>               WRITE (*, *) "" 
>           END IF   
>       ELSE IF (check_result == CHECK_IN_TOL) THEN 
>           IF (check_status%verboseLevel > 2) THEN 
>               WRITE (*, *) "Difference is ", diff_press_ref_max 
>               WRITE (*, *) "" 
>           END IF   
>       END IF   
>       dtype_check_status%numTotal = dtype_check_status%numTotal + 1 
>       IF (var%temp_ref_min == kgenref_var%temp_ref_min) THEN 
>           dtype_check_status%numIdentical = dtype_check_status%numIdentical + 1 
>           IF (check_status%verboseLevel > 2) THEN 
>               WRITE (*, *) trim(adjustl(varname)), "%temp_ref_min is IDENTICAL." 
>           END IF   
>           check_result = CHECK_IDENTICAL 
>       ELSE 
>           diff_temp_ref_min = ABS(var%temp_ref_min - kgenref_var%temp_ref_min) 
>           IF (diff_temp_ref_min <= kgen_tolerance) THEN 
>               dtype_check_status%numInTol = dtype_check_status%numInTol + 1 
>               IF (check_status%verboseLevel > 1) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%temp_ref_min is NOT IDENTICAL(within tolerance)." 
>               END IF   
>               check_result = CHECK_IN_TOL 
>           ELSE 
>               dtype_check_status%numOutTol = dtype_check_status%numOutTol + 1 
>               IF (check_status%verboseLevel > 1) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%temp_ref_min is NOT IDENTICAL(out of tolerance)." 
>               END IF   
>               check_result = CHECK_OUT_TOL 
>           END IF   
>       END IF   
>       IF (check_result == CHECK_IDENTICAL) THEN 
>           CONTINUE 
>       ELSE IF (check_result == CHECK_OUT_TOL) THEN 
>           IF (check_status%verboseLevel > 2) THEN 
>               WRITE (*, *) "Difference is ", diff_temp_ref_min 
>               WRITE (*, *) "" 
>           END IF   
>       ELSE IF (check_result == CHECK_IN_TOL) THEN 
>           IF (check_status%verboseLevel > 2) THEN 
>               WRITE (*, *) "Difference is ", diff_temp_ref_min 
>               WRITE (*, *) "" 
>           END IF   
>       END IF   
>       dtype_check_status%numTotal = dtype_check_status%numTotal + 1 
>       IF (var%temp_ref_max == kgenref_var%temp_ref_max) THEN 
>           dtype_check_status%numIdentical = dtype_check_status%numIdentical + 1 
>           IF (check_status%verboseLevel > 2) THEN 
>               WRITE (*, *) trim(adjustl(varname)), "%temp_ref_max is IDENTICAL." 
>           END IF   
>           check_result = CHECK_IDENTICAL 
>       ELSE 
>           diff_temp_ref_max = ABS(var%temp_ref_max - kgenref_var%temp_ref_max) 
>           IF (diff_temp_ref_max <= kgen_tolerance) THEN 
>               dtype_check_status%numInTol = dtype_check_status%numInTol + 1 
>               IF (check_status%verboseLevel > 1) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%temp_ref_max is NOT IDENTICAL(within tolerance)." 
>               END IF   
>               check_result = CHECK_IN_TOL 
>           ELSE 
>               dtype_check_status%numOutTol = dtype_check_status%numOutTol + 1 
>               IF (check_status%verboseLevel > 1) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%temp_ref_max is NOT IDENTICAL(out of tolerance)." 
>               END IF   
>               check_result = CHECK_OUT_TOL 
>           END IF   
>       END IF   
>       IF (check_result == CHECK_IDENTICAL) THEN 
>           CONTINUE 
>       ELSE IF (check_result == CHECK_OUT_TOL) THEN 
>           IF (check_status%verboseLevel > 2) THEN 
>               WRITE (*, *) "Difference is ", diff_temp_ref_max 
>               WRITE (*, *) "" 
>           END IF   
>       ELSE IF (check_result == CHECK_IN_TOL) THEN 
>           IF (check_status%verboseLevel > 2) THEN 
>               WRITE (*, *) "Difference is ", diff_temp_ref_max 
>               WRITE (*, *) "" 
>           END IF   
>       END IF   
>         
>       dtype_check_status%numTotal = dtype_check_status%numTotal + 1 
>       IF (var%press_ref_log_delta == kgenref_var%press_ref_log_delta) THEN 
>           dtype_check_status%numIdentical = dtype_check_status%numIdentical + 1 
>           IF (check_status%verboseLevel > 2) THEN 
>               WRITE (*, *) trim(adjustl(varname)), "%press_ref_log_delta is IDENTICAL." 
>           END IF   
>           check_result = CHECK_IDENTICAL 
>       ELSE 
>           diff_press_ref_log_delta = ABS(var%press_ref_log_delta - kgenref_var%press_ref_log_delta) 
>           IF (diff_press_ref_log_delta <= kgen_tolerance) THEN 
>               dtype_check_status%numInTol = dtype_check_status%numInTol + 1 
>               IF (check_status%verboseLevel > 1) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%press_ref_log_delta is NOT IDENTICAL(within tolerance)." 
>               END IF   
>               check_result = CHECK_IN_TOL 
>           ELSE 
>               dtype_check_status%numOutTol = dtype_check_status%numOutTol + 1 
>               IF (check_status%verboseLevel > 1) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%press_ref_log_delta is NOT IDENTICAL(out of tolerance)." 
>               END IF   
>               check_result = CHECK_OUT_TOL 
>           END IF   
>       END IF   
>       IF (check_result == CHECK_IDENTICAL) THEN 
>           CONTINUE 
>       ELSE IF (check_result == CHECK_OUT_TOL) THEN 
>           IF (check_status%verboseLevel > 2) THEN 
>               WRITE (*, *) "Difference is ", diff_press_ref_log_delta 
>               WRITE (*, *) "" 
>           END IF   
>       ELSE IF (check_result == CHECK_IN_TOL) THEN 
>           IF (check_status%verboseLevel > 2) THEN 
>               WRITE (*, *) "Difference is ", diff_press_ref_log_delta 
>               WRITE (*, *) "" 
>           END IF   
>       END IF   
>       dtype_check_status%numTotal = dtype_check_status%numTotal + 1 
>       IF (var%temp_ref_delta == kgenref_var%temp_ref_delta) THEN 
>           dtype_check_status%numIdentical = dtype_check_status%numIdentical + 1 
>           IF (check_status%verboseLevel > 2) THEN 
>               WRITE (*, *) trim(adjustl(varname)), "%temp_ref_delta is IDENTICAL." 
>           END IF   
>           check_result = CHECK_IDENTICAL 
>       ELSE 
>           diff_temp_ref_delta = ABS(var%temp_ref_delta - kgenref_var%temp_ref_delta) 
>           IF (diff_temp_ref_delta <= kgen_tolerance) THEN 
>               dtype_check_status%numInTol = dtype_check_status%numInTol + 1 
>               IF (check_status%verboseLevel > 1) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%temp_ref_delta is NOT IDENTICAL(within tolerance)." 
>               END IF   
>               check_result = CHECK_IN_TOL 
>           ELSE 
>               dtype_check_status%numOutTol = dtype_check_status%numOutTol + 1 
>               IF (check_status%verboseLevel > 1) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%temp_ref_delta is NOT IDENTICAL(out of tolerance)." 
>               END IF   
>               check_result = CHECK_OUT_TOL 
>           END IF   
>       END IF   
>       IF (check_result == CHECK_IDENTICAL) THEN 
>           CONTINUE 
>       ELSE IF (check_result == CHECK_OUT_TOL) THEN 
>           IF (check_status%verboseLevel > 2) THEN 
>               WRITE (*, *) "Difference is ", diff_temp_ref_delta 
>               WRITE (*, *) "" 
>           END IF   
>       ELSE IF (check_result == CHECK_IN_TOL) THEN 
>           IF (check_status%verboseLevel > 2) THEN 
>               WRITE (*, *) "Difference is ", diff_temp_ref_delta 
>               WRITE (*, *) "" 
>           END IF   
>       END IF   
>       dtype_check_status%numTotal = dtype_check_status%numTotal + 1 
>       IF (var%press_ref_trop_log == kgenref_var%press_ref_trop_log) THEN 
>           dtype_check_status%numIdentical = dtype_check_status%numIdentical + 1 
>           IF (check_status%verboseLevel > 2) THEN 
>               WRITE (*, *) trim(adjustl(varname)), "%press_ref_trop_log is IDENTICAL." 
>           END IF   
>           check_result = CHECK_IDENTICAL 
>       ELSE 
>           diff_press_ref_trop_log = ABS(var%press_ref_trop_log - kgenref_var%press_ref_trop_log) 
>           IF (diff_press_ref_trop_log <= kgen_tolerance) THEN 
>               dtype_check_status%numInTol = dtype_check_status%numInTol + 1 
>               IF (check_status%verboseLevel > 1) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%press_ref_trop_log is NOT IDENTICAL(within tolerance)." 
>               END IF   
>               check_result = CHECK_IN_TOL 
>           ELSE 
>               dtype_check_status%numOutTol = dtype_check_status%numOutTol + 1 
>               IF (check_status%verboseLevel > 1) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%press_ref_trop_log is NOT IDENTICAL(out of tolerance)." 
>               END IF   
>               check_result = CHECK_OUT_TOL 
>           END IF   
>       END IF   
>       IF (check_result == CHECK_IDENTICAL) THEN 
>           CONTINUE 
>       ELSE IF (check_result == CHECK_OUT_TOL) THEN 
>           IF (check_status%verboseLevel > 2) THEN 
>               WRITE (*, *) "Difference is ", diff_press_ref_trop_log 
>               WRITE (*, *) "" 
>           END IF   
>       ELSE IF (check_result == CHECK_IN_TOL) THEN 
>           IF (check_status%verboseLevel > 2) THEN 
>               WRITE (*, *) "Difference is ", diff_press_ref_trop_log 
>               WRITE (*, *) "" 
>           END IF   
>       END IF   
>         
>       dtype_check_status%numTotal = dtype_check_status%numTotal + 1 
>       IF (var%stpfac == kgenref_var%stpfac) THEN 
>           dtype_check_status%numIdentical = dtype_check_status%numIdentical + 1 
>           IF (check_status%verboseLevel > 2) THEN 
>               WRITE (*, *) trim(adjustl(varname)), "%stpfac is IDENTICAL." 
>           END IF   
>           check_result = CHECK_IDENTICAL 
>       ELSE 
>           diff_stpfac = ABS(var%stpfac - kgenref_var%stpfac) 
>           IF (diff_stpfac <= kgen_tolerance) THEN 
>               dtype_check_status%numInTol = dtype_check_status%numInTol + 1 
>               IF (check_status%verboseLevel > 1) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%stpfac is NOT IDENTICAL(within tolerance)." 
>               END IF   
>               check_result = CHECK_IN_TOL 
>           ELSE 
>               dtype_check_status%numOutTol = dtype_check_status%numOutTol + 1 
>               IF (check_status%verboseLevel > 1) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%stpfac is NOT IDENTICAL(out of tolerance)." 
>               END IF   
>               check_result = CHECK_OUT_TOL 
>           END IF   
>       END IF   
>       IF (check_result == CHECK_IDENTICAL) THEN 
>           CONTINUE 
>       ELSE IF (check_result == CHECK_OUT_TOL) THEN 
>           IF (check_status%verboseLevel > 2) THEN 
>               WRITE (*, *) "Difference is ", diff_stpfac 
>               WRITE (*, *) "" 
>           END IF   
>       ELSE IF (check_result == CHECK_IN_TOL) THEN 
>           IF (check_status%verboseLevel > 2) THEN 
>               WRITE (*, *) "Difference is ", diff_stpfac 
>               WRITE (*, *) "" 
>           END IF   
>       END IF   
>         
>       IF (ALLOCATED(var%kmajor)) THEN 
>           dtype_check_status%numTotal = dtype_check_status%numTotal + 1 
>           IF (ALL(var%kmajor == kgenref_var%kmajor)) THEN 
>               dtype_check_status%numIdentical = dtype_check_status%numIdentical + 1 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%kmajor is IDENTICAL." 
>               END IF   
>               check_result = CHECK_IDENTICAL 
>           ELSE 
>               ALLOCATE (buf1_kmajor(SIZE(var%kmajor,dim=1),SIZE(var%kmajor,dim=2),SIZE(var%kmajor,dim=3),SIZE(var%kmajor,dim=4))) 
>               ALLOCATE (buf2_kmajor(SIZE(var%kmajor,dim=1),SIZE(var%kmajor,dim=2),SIZE(var%kmajor,dim=3),SIZE(var%kmajor,dim=4))) 
>               n_kmajor = COUNT(var%kmajor /= kgenref_var%kmajor) 
>               WHERE ( ABS(kgenref_var%kmajor) > kgen_minvalue ) 
>                   buf1_kmajor = ((var%kmajor-kgenref_var%kmajor)/kgenref_var%kmajor)**2 
>                   buf2_kmajor = (var%kmajor-kgenref_var%kmajor)**2 
>               ELSEWHERE 
>                   buf1_kmajor = (var%kmajor-kgenref_var%kmajor)**2 
>                   buf2_kmajor = buf1_kmajor 
>               END WHERE   
>               nrmsdiff_kmajor = SQRT(SUM(buf1_kmajor)/REAL(n_kmajor)) 
>               rmsdiff_kmajor = SQRT(SUM(buf2_kmajor)/REAL(n_kmajor)) 
>               IF (nrmsdiff_kmajor > kgen_tolerance) THEN 
>                   dtype_check_status%numOutTol = dtype_check_status%numOutTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%kmajor is NOT IDENTICAL(out of tolerance)." 
>                   END IF   
>                   check_result = CHECK_OUT_TOL 
>               ELSE 
>                   dtype_check_status%numInTol = dtype_check_status%numInTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%kmajor is NOT IDENTICAL(within tolerance)." 
>                   END IF   
>                   check_result = CHECK_IN_TOL 
>               END IF   
>           END IF   
>           IF (check_result == CHECK_IDENTICAL) THEN 
>               CONTINUE 
>           ELSE IF (check_result == CHECK_OUT_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%kmajor /= kgenref_var%kmajor), " of ", size( var%kmajor ), " elements are different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%kmajor)/real(size(var%kmajor)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%kmajor)/real(size(kgenref_var%kmajor)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_kmajor 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_kmajor 
>                   WRITE (*, *) "" 
>               END IF   
>           ELSE IF (check_result == CHECK_IN_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%kmajor /= kgenref_var%kmajor), " of ", size( var%kmajor ), " elements are different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%kmajor)/real(size(var%kmajor)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%kmajor)/real(size(kgenref_var%kmajor)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_kmajor 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_kmajor 
>                   WRITE (*, *) "" 
>               END IF   
>           END IF   
>             
>       END IF   
>       IF (ALLOCATED(var%selfrefin)) THEN 
>           dtype_check_status%numTotal = dtype_check_status%numTotal + 1 
>           IF (ALL(var%selfrefin == kgenref_var%selfrefin)) THEN 
>               dtype_check_status%numIdentical = dtype_check_status%numIdentical + 1 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%selfrefin is IDENTICAL." 
>               END IF   
>               check_result = CHECK_IDENTICAL 
>           ELSE 
>               ALLOCATE (buf1_selfrefin(SIZE(var%selfrefin,dim=1),SIZE(var%selfrefin,dim=2),SIZE(var%selfrefin,dim=3))) 
>               ALLOCATE (buf2_selfrefin(SIZE(var%selfrefin,dim=1),SIZE(var%selfrefin,dim=2),SIZE(var%selfrefin,dim=3))) 
>               n_selfrefin = COUNT(var%selfrefin /= kgenref_var%selfrefin) 
>               WHERE ( ABS(kgenref_var%selfrefin) > kgen_minvalue ) 
>                   buf1_selfrefin = ((var%selfrefin-kgenref_var%selfrefin)/kgenref_var%selfrefin)**2 
>                   buf2_selfrefin = (var%selfrefin-kgenref_var%selfrefin)**2 
>               ELSEWHERE 
>                   buf1_selfrefin = (var%selfrefin-kgenref_var%selfrefin)**2 
>                   buf2_selfrefin = buf1_selfrefin 
>               END WHERE   
>               nrmsdiff_selfrefin = SQRT(SUM(buf1_selfrefin)/REAL(n_selfrefin)) 
>               rmsdiff_selfrefin = SQRT(SUM(buf2_selfrefin)/REAL(n_selfrefin)) 
>               IF (nrmsdiff_selfrefin > kgen_tolerance) THEN 
>                   dtype_check_status%numOutTol = dtype_check_status%numOutTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%selfrefin is NOT IDENTICAL(out of tolerance)." 
>                   END IF   
>                   check_result = CHECK_OUT_TOL 
>               ELSE 
>                   dtype_check_status%numInTol = dtype_check_status%numInTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%selfrefin is NOT IDENTICAL(within tolerance)." 
>                   END IF   
>                   check_result = CHECK_IN_TOL 
>               END IF   
>           END IF   
>           IF (check_result == CHECK_IDENTICAL) THEN 
>               CONTINUE 
>           ELSE IF (check_result == CHECK_OUT_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%selfrefin /= kgenref_var%selfrefin), " of ", size( var%selfrefin ), " elements are &
>                   &different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%selfrefin)/real(size(var%selfrefin)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%selfrefin)/real(size(kgenref_var%selfrefin)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_selfrefin 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_selfrefin 
>                   WRITE (*, *) "" 
>               END IF   
>           ELSE IF (check_result == CHECK_IN_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%selfrefin /= kgenref_var%selfrefin), " of ", size( var%selfrefin ), " elements are &
>                   &different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%selfrefin)/real(size(var%selfrefin)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%selfrefin)/real(size(kgenref_var%selfrefin)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_selfrefin 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_selfrefin 
>                   WRITE (*, *) "" 
>               END IF   
>           END IF   
>       END IF   
>       IF (ALLOCATED(var%forrefin)) THEN 
>           dtype_check_status%numTotal = dtype_check_status%numTotal + 1 
>           IF (ALL(var%forrefin == kgenref_var%forrefin)) THEN 
>               dtype_check_status%numIdentical = dtype_check_status%numIdentical + 1 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%forrefin is IDENTICAL." 
>               END IF   
>               check_result = CHECK_IDENTICAL 
>           ELSE 
>               ALLOCATE (buf1_forrefin(SIZE(var%forrefin,dim=1),SIZE(var%forrefin,dim=2),SIZE(var%forrefin,dim=3))) 
>               ALLOCATE (buf2_forrefin(SIZE(var%forrefin,dim=1),SIZE(var%forrefin,dim=2),SIZE(var%forrefin,dim=3))) 
>               n_forrefin = COUNT(var%forrefin /= kgenref_var%forrefin) 
>               WHERE ( ABS(kgenref_var%forrefin) > kgen_minvalue ) 
>                   buf1_forrefin = ((var%forrefin-kgenref_var%forrefin)/kgenref_var%forrefin)**2 
>                   buf2_forrefin = (var%forrefin-kgenref_var%forrefin)**2 
>               ELSEWHERE 
>                   buf1_forrefin = (var%forrefin-kgenref_var%forrefin)**2 
>                   buf2_forrefin = buf1_forrefin 
>               END WHERE   
>               nrmsdiff_forrefin = SQRT(SUM(buf1_forrefin)/REAL(n_forrefin)) 
>               rmsdiff_forrefin = SQRT(SUM(buf2_forrefin)/REAL(n_forrefin)) 
>               IF (nrmsdiff_forrefin > kgen_tolerance) THEN 
>                   dtype_check_status%numOutTol = dtype_check_status%numOutTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%forrefin is NOT IDENTICAL(out of tolerance)." 
>                   END IF   
>                   check_result = CHECK_OUT_TOL 
>               ELSE 
>                   dtype_check_status%numInTol = dtype_check_status%numInTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%forrefin is NOT IDENTICAL(within tolerance)." 
>                   END IF   
>                   check_result = CHECK_IN_TOL 
>               END IF   
>           END IF   
>           IF (check_result == CHECK_IDENTICAL) THEN 
>               CONTINUE 
>           ELSE IF (check_result == CHECK_OUT_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%forrefin /= kgenref_var%forrefin), " of ", size( var%forrefin ), " elements are &
>                   &different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%forrefin)/real(size(var%forrefin)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%forrefin)/real(size(kgenref_var%forrefin)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_forrefin 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_forrefin 
>                   WRITE (*, *) "" 
>               END IF   
>           ELSE IF (check_result == CHECK_IN_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%forrefin /= kgenref_var%forrefin), " of ", size( var%forrefin ), " elements are &
>                   &different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%forrefin)/real(size(var%forrefin)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%forrefin)/real(size(kgenref_var%forrefin)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_forrefin 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_forrefin 
>                   WRITE (*, *) "" 
>               END IF   
>           END IF   
>             
>       END IF   
>       IF (ALLOCATED(var%kminor_lower)) THEN 
>           dtype_check_status%numTotal = dtype_check_status%numTotal + 1 
>           IF (ALL(var%kminor_lower == kgenref_var%kminor_lower)) THEN 
>               dtype_check_status%numIdentical = dtype_check_status%numIdentical + 1 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%kminor_lower is IDENTICAL." 
>               END IF   
>               check_result = CHECK_IDENTICAL 
>           ELSE 
>               ALLOCATE &
>               &(buf1_kminor_lower(SIZE(var%kminor_lower,dim=1),SIZE(var%kminor_lower,dim=2),SIZE(var%kminor_lower,dim=3),SIZE(var%&
>               &kminor_lower,dim=4))) 
>               ALLOCATE &
>               &(buf2_kminor_lower(SIZE(var%kminor_lower,dim=1),SIZE(var%kminor_lower,dim=2),SIZE(var%kminor_lower,dim=3),SIZE(var%&
>               &kminor_lower,dim=4))) 
>               n_kminor_lower = COUNT(var%kminor_lower /= kgenref_var%kminor_lower) 
>               WHERE ( ABS(kgenref_var%kminor_lower) > kgen_minvalue ) 
>                   buf1_kminor_lower = ((var%kminor_lower-kgenref_var%kminor_lower)/kgenref_var%kminor_lower)**2 
>                   buf2_kminor_lower = (var%kminor_lower-kgenref_var%kminor_lower)**2 
>               ELSEWHERE 
>                   buf1_kminor_lower = (var%kminor_lower-kgenref_var%kminor_lower)**2 
>                   buf2_kminor_lower = buf1_kminor_lower 
>               END WHERE   
>               nrmsdiff_kminor_lower = SQRT(SUM(buf1_kminor_lower)/REAL(n_kminor_lower)) 
>               rmsdiff_kminor_lower = SQRT(SUM(buf2_kminor_lower)/REAL(n_kminor_lower)) 
>               IF (nrmsdiff_kminor_lower > kgen_tolerance) THEN 
>                   dtype_check_status%numOutTol = dtype_check_status%numOutTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%kminor_lower is NOT IDENTICAL(out of tolerance)." 
>                   END IF   
>                   check_result = CHECK_OUT_TOL 
>               ELSE 
>                   dtype_check_status%numInTol = dtype_check_status%numInTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%kminor_lower is NOT IDENTICAL(within tolerance)." 
>                   END IF   
>                   check_result = CHECK_IN_TOL 
>               END IF   
>           END IF   
>           IF (check_result == CHECK_IDENTICAL) THEN 
>               CONTINUE 
>           ELSE IF (check_result == CHECK_OUT_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%kminor_lower /= kgenref_var%kminor_lower), " of ", size( var%kminor_lower ), " elements &
>                   &are different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%kminor_lower)/real(size(var%kminor_lower)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%kminor_lower)/real(size(kgenref_var%kminor_lower)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_kminor_lower 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_kminor_lower 
>                   WRITE (*, *) "" 
>               END IF   
>           ELSE IF (check_result == CHECK_IN_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%kminor_lower /= kgenref_var%kminor_lower), " of ", size( var%kminor_lower ), " elements &
>                   &are different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%kminor_lower)/real(size(var%kminor_lower)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%kminor_lower)/real(size(kgenref_var%kminor_lower)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_kminor_lower 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_kminor_lower 
>                   WRITE (*, *) "" 
>               END IF   
>           END IF   
>       END IF   
>       IF (ALLOCATED(var%kminor_upper)) THEN 
>           dtype_check_status%numTotal = dtype_check_status%numTotal + 1 
>           IF (ALL(var%kminor_upper == kgenref_var%kminor_upper)) THEN 
>               dtype_check_status%numIdentical = dtype_check_status%numIdentical + 1 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%kminor_upper is IDENTICAL." 
>               END IF   
>               check_result = CHECK_IDENTICAL 
>           ELSE 
>               ALLOCATE &
>               &(buf1_kminor_upper(SIZE(var%kminor_upper,dim=1),SIZE(var%kminor_upper,dim=2),SIZE(var%kminor_upper,dim=3),SIZE(var%&
>               &kminor_upper,dim=4))) 
>               ALLOCATE &
>               &(buf2_kminor_upper(SIZE(var%kminor_upper,dim=1),SIZE(var%kminor_upper,dim=2),SIZE(var%kminor_upper,dim=3),SIZE(var%&
>               &kminor_upper,dim=4))) 
>               n_kminor_upper = COUNT(var%kminor_upper /= kgenref_var%kminor_upper) 
>               WHERE ( ABS(kgenref_var%kminor_upper) > kgen_minvalue ) 
>                   buf1_kminor_upper = ((var%kminor_upper-kgenref_var%kminor_upper)/kgenref_var%kminor_upper)**2 
>                   buf2_kminor_upper = (var%kminor_upper-kgenref_var%kminor_upper)**2 
>               ELSEWHERE 
>                   buf1_kminor_upper = (var%kminor_upper-kgenref_var%kminor_upper)**2 
>                   buf2_kminor_upper = buf1_kminor_upper 
>               END WHERE   
>               nrmsdiff_kminor_upper = SQRT(SUM(buf1_kminor_upper)/REAL(n_kminor_upper)) 
>               rmsdiff_kminor_upper = SQRT(SUM(buf2_kminor_upper)/REAL(n_kminor_upper)) 
>               IF (nrmsdiff_kminor_upper > kgen_tolerance) THEN 
>                   dtype_check_status%numOutTol = dtype_check_status%numOutTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%kminor_upper is NOT IDENTICAL(out of tolerance)." 
>                   END IF   
>                   check_result = CHECK_OUT_TOL 
>               ELSE 
>                   dtype_check_status%numInTol = dtype_check_status%numInTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%kminor_upper is NOT IDENTICAL(within tolerance)." 
>                   END IF   
>                   check_result = CHECK_IN_TOL 
>               END IF   
>           END IF   
>           IF (check_result == CHECK_IDENTICAL) THEN 
>               CONTINUE 
>           ELSE IF (check_result == CHECK_OUT_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%kminor_upper /= kgenref_var%kminor_upper), " of ", size( var%kminor_upper ), " elements &
>                   &are different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%kminor_upper)/real(size(var%kminor_upper)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%kminor_upper)/real(size(kgenref_var%kminor_upper)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_kminor_upper 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_kminor_upper 
>                   WRITE (*, *) "" 
>               END IF   
>           ELSE IF (check_result == CHECK_IN_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%kminor_upper /= kgenref_var%kminor_upper), " of ", size( var%kminor_upper ), " elements &
>                   &are different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%kminor_upper)/real(size(var%kminor_upper)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%kminor_upper)/real(size(kgenref_var%kminor_upper)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_kminor_upper 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_kminor_upper 
>                   WRITE (*, *) "" 
>               END IF   
>           END IF   
>             
>       END IF   
>       IF (ALLOCATED(var%krayl)) THEN 
>           dtype_check_status%numTotal = dtype_check_status%numTotal + 1 
>           IF (ALL(var%krayl == kgenref_var%krayl)) THEN 
>               dtype_check_status%numIdentical = dtype_check_status%numIdentical + 1 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%krayl is IDENTICAL." 
>               END IF   
>               check_result = CHECK_IDENTICAL 
>           ELSE 
>               ALLOCATE (buf1_krayl(SIZE(var%krayl,dim=1),SIZE(var%krayl,dim=2),SIZE(var%krayl,dim=3),SIZE(var%krayl,dim=4))) 
>               ALLOCATE (buf2_krayl(SIZE(var%krayl,dim=1),SIZE(var%krayl,dim=2),SIZE(var%krayl,dim=3),SIZE(var%krayl,dim=4))) 
>               n_krayl = COUNT(var%krayl /= kgenref_var%krayl) 
>               WHERE ( ABS(kgenref_var%krayl) > kgen_minvalue ) 
>                   buf1_krayl = ((var%krayl-kgenref_var%krayl)/kgenref_var%krayl)**2 
>                   buf2_krayl = (var%krayl-kgenref_var%krayl)**2 
>               ELSEWHERE 
>                   buf1_krayl = (var%krayl-kgenref_var%krayl)**2 
>                   buf2_krayl = buf1_krayl 
>               END WHERE   
>               nrmsdiff_krayl = SQRT(SUM(buf1_krayl)/REAL(n_krayl)) 
>               rmsdiff_krayl = SQRT(SUM(buf2_krayl)/REAL(n_krayl)) 
>               IF (nrmsdiff_krayl > kgen_tolerance) THEN 
>                   dtype_check_status%numOutTol = dtype_check_status%numOutTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%krayl is NOT IDENTICAL(out of tolerance)." 
>                   END IF   
>                   check_result = CHECK_OUT_TOL 
>               ELSE 
>                   dtype_check_status%numInTol = dtype_check_status%numInTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%krayl is NOT IDENTICAL(within tolerance)." 
>                   END IF   
>                   check_result = CHECK_IN_TOL 
>               END IF   
>           END IF   
>           IF (check_result == CHECK_IDENTICAL) THEN 
>               CONTINUE 
>           ELSE IF (check_result == CHECK_OUT_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%krayl /= kgenref_var%krayl), " of ", size( var%krayl ), " elements are different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%krayl)/real(size(var%krayl)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%krayl)/real(size(kgenref_var%krayl)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_krayl 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_krayl 
>                   WRITE (*, *) "" 
>               END IF   
>           ELSE IF (check_result == CHECK_IN_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%krayl /= kgenref_var%krayl), " of ", size( var%krayl ), " elements are different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%krayl)/real(size(var%krayl)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%krayl)/real(size(kgenref_var%krayl)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_krayl 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_krayl 
>                   WRITE (*, *) "" 
>               END IF   
>           END IF   
>             
>       END IF   
>       IF (ALLOCATED(var%planck_frac)) THEN 
>           dtype_check_status%numTotal = dtype_check_status%numTotal + 1 
>           IF (ALL(var%planck_frac == kgenref_var%planck_frac)) THEN 
>               dtype_check_status%numIdentical = dtype_check_status%numIdentical + 1 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%planck_frac is IDENTICAL." 
>               END IF   
>               check_result = CHECK_IDENTICAL 
>           ELSE 
>               ALLOCATE &
>               &(buf1_planck_frac(SIZE(var%planck_frac,dim=1),SIZE(var%planck_frac,dim=2),SIZE(var%planck_frac,dim=3),SIZE(var%plan&
>               &ck_frac,dim=4))) 
>               ALLOCATE &
>               &(buf2_planck_frac(SIZE(var%planck_frac,dim=1),SIZE(var%planck_frac,dim=2),SIZE(var%planck_frac,dim=3),SIZE(var%plan&
>               &ck_frac,dim=4))) 
>               n_planck_frac = COUNT(var%planck_frac /= kgenref_var%planck_frac) 
>               WHERE ( ABS(kgenref_var%planck_frac) > kgen_minvalue ) 
>                   buf1_planck_frac = ((var%planck_frac-kgenref_var%planck_frac)/kgenref_var%planck_frac)**2 
>                   buf2_planck_frac = (var%planck_frac-kgenref_var%planck_frac)**2 
>               ELSEWHERE 
>                   buf1_planck_frac = (var%planck_frac-kgenref_var%planck_frac)**2 
>                   buf2_planck_frac = buf1_planck_frac 
>               END WHERE   
>               nrmsdiff_planck_frac = SQRT(SUM(buf1_planck_frac)/REAL(n_planck_frac)) 
>               rmsdiff_planck_frac = SQRT(SUM(buf2_planck_frac)/REAL(n_planck_frac)) 
>               IF (nrmsdiff_planck_frac > kgen_tolerance) THEN 
>                   dtype_check_status%numOutTol = dtype_check_status%numOutTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%planck_frac is NOT IDENTICAL(out of tolerance)." 
>                   END IF   
>                   check_result = CHECK_OUT_TOL 
>               ELSE 
>                   dtype_check_status%numInTol = dtype_check_status%numInTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%planck_frac is NOT IDENTICAL(within tolerance)." 
>                   END IF   
>                   check_result = CHECK_IN_TOL 
>               END IF   
>           END IF   
>           IF (check_result == CHECK_IDENTICAL) THEN 
>               CONTINUE 
>           ELSE IF (check_result == CHECK_OUT_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%planck_frac /= kgenref_var%planck_frac), " of ", size( var%planck_frac ), " elements &
>                   &are different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%planck_frac)/real(size(var%planck_frac)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%planck_frac)/real(size(kgenref_var%planck_frac)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_planck_frac 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_planck_frac 
>                   WRITE (*, *) "" 
>               END IF   
>           ELSE IF (check_result == CHECK_IN_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%planck_frac /= kgenref_var%planck_frac), " of ", size( var%planck_frac ), " elements &
>                   &are different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%planck_frac)/real(size(var%planck_frac)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%planck_frac)/real(size(kgenref_var%planck_frac)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_planck_frac 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_planck_frac 
>                   WRITE (*, *) "" 
>               END IF   
>           END IF   
>             
>       END IF   
>       IF (ALLOCATED(var%totplnk)) THEN 
>           dtype_check_status%numTotal = dtype_check_status%numTotal + 1 
>           IF (ALL(var%totplnk == kgenref_var%totplnk)) THEN 
>               dtype_check_status%numIdentical = dtype_check_status%numIdentical + 1 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%totplnk is IDENTICAL." 
>               END IF   
>               check_result = CHECK_IDENTICAL 
>           ELSE 
>               ALLOCATE (buf1_totplnk(SIZE(var%totplnk,dim=1),SIZE(var%totplnk,dim=2))) 
>               ALLOCATE (buf2_totplnk(SIZE(var%totplnk,dim=1),SIZE(var%totplnk,dim=2))) 
>               n_totplnk = COUNT(var%totplnk /= kgenref_var%totplnk) 
>               WHERE ( ABS(kgenref_var%totplnk) > kgen_minvalue ) 
>                   buf1_totplnk = ((var%totplnk-kgenref_var%totplnk)/kgenref_var%totplnk)**2 
>                   buf2_totplnk = (var%totplnk-kgenref_var%totplnk)**2 
>               ELSEWHERE 
>                   buf1_totplnk = (var%totplnk-kgenref_var%totplnk)**2 
>                   buf2_totplnk = buf1_totplnk 
>               END WHERE   
>               nrmsdiff_totplnk = SQRT(SUM(buf1_totplnk)/REAL(n_totplnk)) 
>               rmsdiff_totplnk = SQRT(SUM(buf2_totplnk)/REAL(n_totplnk)) 
>               IF (nrmsdiff_totplnk > kgen_tolerance) THEN 
>                   dtype_check_status%numOutTol = dtype_check_status%numOutTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%totplnk is NOT IDENTICAL(out of tolerance)." 
>                   END IF   
>                   check_result = CHECK_OUT_TOL 
>               ELSE 
>                   dtype_check_status%numInTol = dtype_check_status%numInTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%totplnk is NOT IDENTICAL(within tolerance)." 
>                   END IF   
>                   check_result = CHECK_IN_TOL 
>               END IF   
>           END IF   
>           IF (check_result == CHECK_IDENTICAL) THEN 
>               CONTINUE 
>           ELSE IF (check_result == CHECK_OUT_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%totplnk /= kgenref_var%totplnk), " of ", size( var%totplnk ), " elements are &
>                   &different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%totplnk)/real(size(var%totplnk)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%totplnk)/real(size(kgenref_var%totplnk)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_totplnk 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_totplnk 
>                   WRITE (*, *) "" 
>               END IF   
>           ELSE IF (check_result == CHECK_IN_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%totplnk /= kgenref_var%totplnk), " of ", size( var%totplnk ), " elements are &
>                   &different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%totplnk)/real(size(var%totplnk)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%totplnk)/real(size(kgenref_var%totplnk)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_totplnk 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_totplnk 
>                   WRITE (*, *) "" 
>               END IF   
>           END IF   
>             
>       END IF   
>       dtype_check_status%numTotal = dtype_check_status%numTotal + 1 
>       IF (var%totplnk_delta == kgenref_var%totplnk_delta) THEN 
>           dtype_check_status%numIdentical = dtype_check_status%numIdentical + 1 
>           IF (check_status%verboseLevel > 2) THEN 
>               WRITE (*, *) trim(adjustl(varname)), "%totplnk_delta is IDENTICAL." 
>           END IF   
>           check_result = CHECK_IDENTICAL 
>       ELSE 
>           diff_totplnk_delta = ABS(var%totplnk_delta - kgenref_var%totplnk_delta) 
>           IF (diff_totplnk_delta <= kgen_tolerance) THEN 
>               dtype_check_status%numInTol = dtype_check_status%numInTol + 1 
>               IF (check_status%verboseLevel > 1) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%totplnk_delta is NOT IDENTICAL(within tolerance)." 
>               END IF   
>               check_result = CHECK_IN_TOL 
>           ELSE 
>               dtype_check_status%numOutTol = dtype_check_status%numOutTol + 1 
>               IF (check_status%verboseLevel > 1) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%totplnk_delta is NOT IDENTICAL(out of tolerance)." 
>               END IF   
>               check_result = CHECK_OUT_TOL 
>           END IF   
>       END IF   
>       IF (check_result == CHECK_IDENTICAL) THEN 
>           CONTINUE 
>       ELSE IF (check_result == CHECK_OUT_TOL) THEN 
>           IF (check_status%verboseLevel > 2) THEN 
>               WRITE (*, *) "Difference is ", diff_totplnk_delta 
>               WRITE (*, *) "" 
>           END IF   
>       ELSE IF (check_result == CHECK_IN_TOL) THEN 
>           IF (check_status%verboseLevel > 2) THEN 
>               WRITE (*, *) "Difference is ", diff_totplnk_delta 
>               WRITE (*, *) "" 
>           END IF   
>       END IF   
>         
>       IF (ALLOCATED(var%solar_src)) THEN 
>           dtype_check_status%numTotal = dtype_check_status%numTotal + 1 
>           IF (ALL(var%solar_src == kgenref_var%solar_src)) THEN 
>               dtype_check_status%numIdentical = dtype_check_status%numIdentical + 1 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%solar_src is IDENTICAL." 
>               END IF   
>               check_result = CHECK_IDENTICAL 
>           ELSE 
>               ALLOCATE (buf1_solar_src(SIZE(var%solar_src,dim=1))) 
>               ALLOCATE (buf2_solar_src(SIZE(var%solar_src,dim=1))) 
>               n_solar_src = COUNT(var%solar_src /= kgenref_var%solar_src) 
>               WHERE ( ABS(kgenref_var%solar_src) > kgen_minvalue ) 
>                   buf1_solar_src = ((var%solar_src-kgenref_var%solar_src)/kgenref_var%solar_src)**2 
>                   buf2_solar_src = (var%solar_src-kgenref_var%solar_src)**2 
>               ELSEWHERE 
>                   buf1_solar_src = (var%solar_src-kgenref_var%solar_src)**2 
>                   buf2_solar_src = buf1_solar_src 
>               END WHERE   
>               nrmsdiff_solar_src = SQRT(SUM(buf1_solar_src)/REAL(n_solar_src)) 
>               rmsdiff_solar_src = SQRT(SUM(buf2_solar_src)/REAL(n_solar_src)) 
>               IF (nrmsdiff_solar_src > kgen_tolerance) THEN 
>                   dtype_check_status%numOutTol = dtype_check_status%numOutTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%solar_src is NOT IDENTICAL(out of tolerance)." 
>                   END IF   
>                   check_result = CHECK_OUT_TOL 
>               ELSE 
>                   dtype_check_status%numInTol = dtype_check_status%numInTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%solar_src is NOT IDENTICAL(within tolerance)." 
>                   END IF   
>                   check_result = CHECK_IN_TOL 
>               END IF   
>           END IF   
>           IF (check_result == CHECK_IDENTICAL) THEN 
>               CONTINUE 
>           ELSE IF (check_result == CHECK_OUT_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%solar_src /= kgenref_var%solar_src), " of ", size( var%solar_src ), " elements are &
>                   &different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%solar_src)/real(size(var%solar_src)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%solar_src)/real(size(kgenref_var%solar_src)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_solar_src 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_solar_src 
>                   WRITE (*, *) "" 
>               END IF   
>           ELSE IF (check_result == CHECK_IN_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%solar_src /= kgenref_var%solar_src), " of ", size( var%solar_src ), " elements are &
>                   &different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%solar_src)/real(size(var%solar_src)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%solar_src)/real(size(kgenref_var%solar_src)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_solar_src 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_solar_src 
>                   WRITE (*, *) "" 
>               END IF   
>           END IF   
>             
>       END IF   
>       IF (ALLOCATED(var%kminor_activity)) THEN 
>           dtype_check_status%numTotal = dtype_check_status%numTotal + 1 
>           IF (ALL(var%kminor_activity == kgenref_var%kminor_activity)) THEN 
>               dtype_check_status%numIdentical = dtype_check_status%numIdentical + 1 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%kminor_activity is IDENTICAL." 
>               END IF   
>               check_result = CHECK_IDENTICAL 
>           ELSE 
>               ALLOCATE (buf1_kminor_activity(SIZE(var%kminor_activity,dim=1),SIZE(var%kminor_activity,dim=2))) 
>               ALLOCATE (buf2_kminor_activity(SIZE(var%kminor_activity,dim=1),SIZE(var%kminor_activity,dim=2))) 
>               n_kminor_activity = COUNT(var%kminor_activity /= kgenref_var%kminor_activity) 
>               WHERE ( ABS(kgenref_var%kminor_activity) > kgen_minvalue ) 
>                   buf1_kminor_activity = ((var%kminor_activity-kgenref_var%kminor_activity)/kgenref_var%kminor_activity)**2 
>                   buf2_kminor_activity = (var%kminor_activity-kgenref_var%kminor_activity)**2 
>               ELSEWHERE 
>                   buf1_kminor_activity = (var%kminor_activity-kgenref_var%kminor_activity)**2 
>                   buf2_kminor_activity = buf1_kminor_activity 
>               END WHERE   
>               nrmsdiff_kminor_activity = SQRT(SUM(buf1_kminor_activity)/REAL(n_kminor_activity)) 
>               rmsdiff_kminor_activity = SQRT(SUM(buf2_kminor_activity)/REAL(n_kminor_activity)) 
>               IF (nrmsdiff_kminor_activity > kgen_tolerance) THEN 
>                   dtype_check_status%numOutTol = dtype_check_status%numOutTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%kminor_activity is NOT IDENTICAL(out of tolerance)." 
>                   END IF   
>                   check_result = CHECK_OUT_TOL 
>               ELSE 
>                   dtype_check_status%numInTol = dtype_check_status%numInTol + 1 
>                   IF (check_status%verboseLevel > 1) THEN 
>                       WRITE (*, *) trim(adjustl(varname)), "%kminor_activity is NOT IDENTICAL(within tolerance)." 
>                   END IF   
>                   check_result = CHECK_IN_TOL 
>               END IF   
>           END IF   
>           IF (check_result == CHECK_IDENTICAL) THEN 
>               CONTINUE 
>           ELSE IF (check_result == CHECK_OUT_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%kminor_activity /= kgenref_var%kminor_activity), " of ", size( var%kminor_activity ), " &
>                   &elements are different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%kminor_activity)/real(size(var%kminor_activity)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%kminor_activity)/real(size(kgenref_var%kminor_activity)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_kminor_activity 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_kminor_activity 
>                   WRITE (*, *) "" 
>               END IF   
>           ELSE IF (check_result == CHECK_IN_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) count( var%kminor_activity /= kgenref_var%kminor_activity), " of ", size( var%kminor_activity ), " &
>                   &elements are different." 
>                   WRITE (*, *) "Average - kernel ", sum(var%kminor_activity)/real(size(var%kminor_activity)) 
>                   WRITE (*, *) "Average - reference ", sum(kgenref_var%kminor_activity)/real(size(kgenref_var%kminor_activity)) 
>                   WRITE (*, *) "RMS of difference is ", rmsdiff_kminor_activity 
>                   WRITE (*, *) "Normalized RMS of difference is ", nrmsdiff_kminor_activity 
>                   WRITE (*, *) "" 
>               END IF   
>           END IF   
>             
>       END IF   
>       IF (ALLOCATED(var%is_key)) THEN 
>           dtype_check_status%numTotal = dtype_check_status%numTotal + 1 
>           IF (ALL(var%is_key .EQV. kgenref_var%is_key)) THEN 
>               dtype_check_status%numIdentical = dtype_check_status%numIdentical + 1 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%is_key is IDENTICAL." 
>               END IF   
>               check_result = CHECK_IDENTICAL 
>           ELSE 
>               n_is_key = COUNT(var%is_key .NEQV. kgenref_var%is_key) 
>               dtype_check_status%numOutTol = dtype_check_status%numOutTol + 1 
>               IF (check_status%verboseLevel > 1) THEN 
>                   WRITE (*, *) trim(adjustl(varname)), "%is_key is NOT IDENTICAL(out of tolerance)." 
>               END IF   
>               check_result = CHECK_OUT_TOL 
>           END IF   
>           IF (check_result == CHECK_IDENTICAL) THEN 
>               CONTINUE 
>           ELSE IF (check_result == CHECK_OUT_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) "NOT IMPLEMENTED YET" 
>                   WRITE (*, *) "" 
>               END IF   
>           ELSE IF (check_result == CHECK_IN_TOL) THEN 
>               IF (check_status%verboseLevel > 2) THEN 
>                   WRITE (*, *) "NOT IMPLEMENTED YET" 
>                   WRITE (*, *) "" 
>               END IF   
>           END IF   
>             
>       END IF   
>       IF (dtype_check_status%numTotal == dtype_check_status%numIdentical) THEN 
>           check_status%numIdentical = check_status%numIdentical + 1 
>       ELSE IF (dtype_check_status%numOutTol > 0) THEN 
>           check_status%numOutTol = check_status%numOutTol + 1 
>       ELSE IF (dtype_check_status%numInTol > 0) THEN 
>           check_status%numInTol = check_status%numInTol + 1 
>       END IF   
>   END SUBROUTINE kv_kgen_mo_gas_optics_specification_typesubp0 
>     
> end module mo_gas_optics_specification
\ No newline at end of file
0a1,5
> !KGEN-generated Fortran source file 
>   
> !Generated at : 2017-06-01 10:39:46 
> !KGEN version : 0.7.3 
>   
52,59c57,62
<   use mo_rrtmgp_kind,   only: wp
<   use mo_gas_optics_specification, &
<                         only: ty_gas_optics_specification
<   use mo_gas_concentrations, & 
<                         only: ty_gas_concs
<   use mo_optical_props, only: ty_optical_props, ty_optical_props_2str, ty_optical_props_nstr
<   use mo_fluxes,        only: ty_fluxes
<   use mo_lw_solver,     only: lw_solver_init, lw_solver
---
>     USE mo_rrtmgp_kind, ONLY: wp 
>     USE mo_gas_optics_specification, ONLY: ty_gas_optics_specification 
>     USE mo_gas_concentrations, ONLY: ty_gas_concs 
>     USE mo_optical_props, ONLY: ty_optical_props, ty_optical_props_2str, ty_optical_props_nstr 
>     USE mo_fluxes, ONLY: ty_fluxes 
>     USE mo_lw_solver, ONLY: lw_solver 
61,65c64,79
<   use mo_rng
<   use mo_cloud_optics
<   use mo_aerosol_optics
<   implicit none
<   private
---
>     USE kgen_utils_mod, ONLY: kgen_dp, kgen_array_sumcheck 
>     USE tprof_mod, ONLY: tstart, tstop, tnull, tprnt 
>     USE mo_gas_optics_specification, ONLY: kr_kgen_mo_gas_optics_specification_typesubp0 
>     USE mo_gas_concentrations, ONLY: kr_mo_gas_concentrations_ty_gas_concs 
>     USE mo_optical_props, ONLY: kr_mo_optical_props_ty_optical_props 
>     USE mo_optical_props, ONLY: kr_mo_optical_props_ty_optical_props_2str 
>     USE mo_optical_props, ONLY: kr_mo_optical_props_ty_optical_props_nstr 
>     USE mo_fluxes, ONLY: kr_mo_fluxes_ty_fluxes 
>     USE mo_gas_optics_specification, ONLY: kv_kgen_mo_gas_optics_specification_typesubp0 
>     USE mo_gas_concentrations, ONLY: kv_mo_gas_concentrations_ty_gas_concs 
>     USE mo_optical_props, ONLY: kv_mo_optical_props_ty_optical_props 
>     USE mo_optical_props, ONLY: kv_mo_optical_props_ty_optical_props_2str 
>     USE mo_optical_props, ONLY: kv_mo_optical_props_ty_optical_props_nstr 
>     USE mo_fluxes, ONLY: kv_mo_fluxes_ty_fluxes 
>     IMPLICIT NONE 
>     PRIVATE 
72c86
<   public :: rrtmgp_lw_init, rrtmgp_lw_opt
---
>     PUBLIC rrtmgp_lw_opt 
79a94,107
>   PUBLIC kr_externs_in_mo_rrtmgp_lw 
>   PUBLIC kr_externs_out_mo_rrtmgp_lw 
>   PUBLIC kr_kgen_mo_gas_optics_specification_typesubp0 
>   PUBLIC kr_mo_gas_concentrations_ty_gas_concs 
>   PUBLIC kr_mo_optical_props_ty_optical_props 
>   PUBLIC kr_mo_optical_props_ty_optical_props_2str 
>   PUBLIC kr_mo_optical_props_ty_optical_props_nstr 
>   PUBLIC kr_mo_fluxes_ty_fluxes 
>   PUBLIC kv_kgen_mo_gas_optics_specification_typesubp0 
>   PUBLIC kv_mo_gas_concentrations_ty_gas_concs 
>   PUBLIC kv_mo_optical_props_ty_optical_props 
>   PUBLIC kv_mo_optical_props_ty_optical_props_2str 
>   PUBLIC kv_mo_optical_props_ty_optical_props_nstr 
>   PUBLIC kv_mo_fluxes_ty_fluxes 
84,88d111
<   function rrtmgp_lw_init(nlwstreams, nangles) result(error_msg)
<     integer,           optional, intent( in) :: nlwstreams ! Scattering/no scattering
<     integer,           optional, intent( in) :: nangles    ! number of quadrature angles for 
<                                                            ! no-scattering calculation
<     character(len=128)                       :: error_msg
90,103d112
<     error_msg = ""
<     if(present(nlwstreams)) then
<       if(nlwstreams >= 0) then  ! Check for an even number?
<         nstreams = nlwstreams
<       else
<         error_msg = "rrtmgp_lw_init: nlwstreams provided is less than 0"
<         return 
<       end if
<     end if
<     if(present(nangles)) then
<       error_msg = lw_solver_init(n_angles = nangles)
<       if(error_msg /= "") return 
<     end if
<   end function rrtmgp_lw_init
111,174d119
<   function rrtmgp_lw_phys(k_dist, gas_concs, p_lay, t_lay, p_lev, t_sfc, emis_sfc,   &
<                           clouds, rngs, allsky_fluxes, clrsky_fluxes,                &
<                           aerosols, col_dry, t_lev, inc_flux) result(error_msg)
<     type(ty_gas_optics_specification), &
<                               intent(in ) :: k_dist    !< derived type with spectral information
<     type(ty_gas_concs),        intent(in ) :: gas_concs !< derived type encapsulating gas concentrations
<     real(wp), dimension(:,:), intent(in ) :: p_lay     !< pressure at layer centers     [Pa] (ncol, nlay)
<     real(wp), dimension(:,:), intent(in ) :: t_lay     !< temperature at layer centers  [K]  (ncol, nlay)
<     real(wp), dimension(:,:), intent(in ) :: p_lev     !< pressure at levels/interfaces [Pa] (ncol, nlay+1)
<     real(wp), dimension(:),   intent(in ) :: t_sfc     !< surface temperature   [K] (ncol)
<     real(wp), dimension(:,:), intent(in ) :: emis_sfc  !< emissivity at surface []  (nbands, ncol)
<     class(ty_cloud_desc),     intent(in ) :: clouds    !< cloud physical description
<     class(ty_rng), &
<         dimension(:),       intent(inout) :: rngs      !< random number generator states
<     class(ty_fluxes),       intent(inout) :: allsky_fluxes, clrsky_fluxes
<     class(ty_aerosol_desc),  &
<               optional,       intent(in ) :: aerosols  !< aerosol physical description
<     real(wp), dimension(:,:), target, &
<               optional,       intent(in ) :: col_dry   !< Molecular number density 
<     real(wp), dimension(:,:), target, &
<               optional,       intent(in ) :: t_lev     !< temperature at levels [K] (ncol, nlay+1)
<     real(wp), dimension(:,:),         &
<               optional,       intent(in ) :: inc_flux   !< incident flux at domain top [W/m2] (ncol, ngpts)
<     character(len=128)                    :: error_msg
<     !---------------------------------
<     ! Local variables
< 
<     integer :: ncol, nlay, ngpt, nband
<     ! Variables to represent clouds, aerosol optical props
<     class(ty_optical_props), allocatable :: cloud_props, aer_props
<     !---------------------------------
< 
<     if(.not. k_dist%is_initialized()) then
<       error_msg = "rrtmgp_lw: k-distribution isn't initialized"
<       return
<     end if
< 
<     ! Problem sizes
<     ncol = size(p_lay,dim=1)
<     nlay = size(p_lay,dim=2)
<     ngpt = k_dist%get_ngpt()
<     nband = k_dist%get_nband()
< 
<     !
<     ! Initialize optical properties objects: is LW scattering to be included?
<     !
<     select case(nstreams)
<       case(0)       ! No scattering
<         allocate(ty_optical_props::cloud_props)
<       case(2)       ! two-stream calculation
<         allocate(ty_optical_props_2str::cloud_props)
<       case default  ! n-stream calculation
<         allocate(ty_optical_props_nstr::cloud_props)
<     end select
< 
<     select type (cloud_props)
<       class is (ty_optical_props)      ! No scattering
<         error_msg = cloud_props%init_1scalar(ncol, nlay, ngpt)
<       class is (ty_optical_props_2str) ! two-stream calculation
<         error_msg = cloud_props%init_2stream(ncol, nlay, ngpt)
<       class is (ty_optical_props_nstr) ! n-stream calculation
<         error_msg = cloud_props%init_nstream(nstreams/2, ncol, nlay, ngpt)
<     end select
<     if (error_msg /= '') return
176,190d120
<     !
<     ! No need to allocate memory for aerosols if they aren't provided.
<     !
<     if(present(aerosols)) then
<       allocate(aer_props, source=cloud_props) 
<       select type (aer_props)
<         class is (ty_optical_props)      ! No scattering
<           error_msg = aer_props%init_1scalar(ncol, nlay, nband)
<         class is (ty_optical_props_2str) ! two-stream calculation
<           error_msg = aer_props%init_2stream(ncol, nlay, nband)
<         class is (ty_optical_props_nstr) ! n-stream calculation
<           error_msg = aer_props%init_nstream(nstreams/2, ncol, nlay, nband)
<       end select
<     end if
<     if (error_msg /= '') return
192,210d121
<     !
<     ! Map physical properties to optical properties
<     !
<     error_msg = clouds%sample_and_optics(rngs, k_dist, cloud_props)
<     if(error_msg /= '') return
<     if(present(aerosols)) call aerosols%optics(k_dist, aer_props)
< 
<     if(present(aerosols)) then
<       error_msg = rrtmgp_lw_opt(k_dist, gas_concs, p_lay, t_lay, p_lev, t_sfc, emis_sfc, &
<                                 cloud_props, allsky_fluxes, clrsky_fluxes,               &
<                                 aer_props, col_dry, t_lev, inc_flux)
<     else
<       error_msg = rrtmgp_lw_opt(k_dist, gas_concs, p_lay, t_lay, p_lev, t_sfc, emis_sfc, &
<                                 cloud_props, allsky_fluxes, clrsky_fluxes,               &
<                                 col_dry = col_dry,       & 
<                                 t_lev=t_lev,             &
<                                 inc_flux=inc_flux)
<     end if
<   end function rrtmgp_lw_phys
462c373,390
< end module mo_rrtmgp_lw
---
>   !read state subroutine for kr_externs_in_mo_rrtmgp_lw 
>   SUBROUTINE kr_externs_in_mo_rrtmgp_lw(kgen_unit) 
>       INTEGER, INTENT(IN) :: kgen_unit 
>       LOGICAL :: kgen_istrue 
>       REAL(KIND=8) :: kgen_array_sum 
>         
>       READ (UNIT = kgen_unit) nstreams 
>   END SUBROUTINE kr_externs_in_mo_rrtmgp_lw 
>     
>   !read state subroutine for kr_externs_out_mo_rrtmgp_lw 
>   SUBROUTINE kr_externs_out_mo_rrtmgp_lw(kgen_unit) 
>       INTEGER, INTENT(IN) :: kgen_unit 
>         
>       LOGICAL :: kgen_istrue 
>       REAL(KIND=8) :: kgen_array_sum 
>   END SUBROUTINE kr_externs_out_mo_rrtmgp_lw 
>     
> end module mo_rrtmgp_lw
\ No newline at end of file
1,81c1,88
< !>
< !! @par Copyright
< !! This code is subject to the MPI-M-Software - License - Agreement in it's most recent form.
< !! Please see URL http://www.mpimet.mpg.de/en/science/models/model-distribution.html and the
< !! file COPYING in the root of the source tree for this code.
< !! Where software is supplied by third parties, it is indicated in the headers of the routines.
< !!
< !! @brief Module to provide string related utilities
< !!
< !! @author Andre Wehe (2014)
< !!
< !
< 
< module mo_util_string
<   implicit none
<   private
<   public :: lower_case, string_in_array, string_loc_in_array
< 
<   ! List of character for case conversion
<   character(len=26), parameter :: LOWER_CASE_CHARS = 'abcdefghijklmnopqrstuvwxyz'
<   character(len=26), parameter :: UPPER_CASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
< 
< contains
<   ! --------------------------------------------------------------------------------------
<   pure function lower_case( input_string ) result( output_string )
<     character(len=*), intent(in) :: input_string
<     character(len=len(input_string)) :: output_string
<     integer :: i, n
< 
<     ! Copy input string
<     output_string = input_string
< 
<     ! Convert case character by character
<     do i = 1, len(output_string)
<       n = index(UPPER_CASE_CHARS, output_string(i:i))
<       if ( n /= 0 ) output_string(i:i) = LOWER_CASE_CHARS(n:n)
<     end do
<   end function
<   ! --------------------------------------------------------------------------------------
<   !
<   ! Is string somewhere in array? 
<   !
<   pure function string_in_array(string, array) 
<     character(len=*),               intent(in) :: string
<     character(len=*), dimension(:), intent(in) :: array
<     logical                                    :: string_in_array
<     
<     integer :: i
<     character(len=len_trim(string)) :: lc_string  
<     
<     string_in_array = .false. 
<     lc_string = lower_case(trim(string))
<     do i = 1, size(array) 
<       if(lc_string == lower_case(trim(array(i)))) then 
<         string_in_array = .true. 
<         exit 
<       end if 
<     end do 
<   end function string_in_array
<   ! --------------------------------------------------------------------------------------
<   !
<   ! Is string somewhere in array? 
<   !
<   pure function string_loc_in_array(string, array) 
<     character(len=*),               intent(in) :: string
<     character(len=*), dimension(:), intent(in) :: array
<     integer                                    :: string_loc_in_array
<     
<     integer :: i
<     character(len=len_trim(string)) :: lc_string  
<     
<     string_loc_in_array = -1
<     lc_string = lower_case(trim(string))
<     do i = 1, size(array) 
<       if(lc_string == lower_case(trim(array(i)))) then 
<         string_loc_in_array = i
<         exit 
<       end if 
<     end do 
<   end function string_loc_in_array
< end module
---
> !KGEN-generated Fortran source file 
>   
> !Generated at : 2017-06-01 10:39:47 
> !KGEN version : 0.7.3 
>   
> !>
> !! @par Copyright
> !! This code is subject to the MPI-M-Software - License - Agreement in it's most recent form.
> !! Please see URL http://www.mpimet.mpg.de/en/science/models/model-distribution.html and the
> !! file COPYING in the root of the source tree for this code.
> !! Where software is supplied by third parties, it is indicated in the headers of the routines.
> !!
> !! @brief Module to provide string related utilities
> !!
> !! @author Andre Wehe (2014)
> !!
> !
> 
> module mo_util_string
>     USE kgen_utils_mod, ONLY: kgen_dp, kgen_array_sumcheck 
>     USE tprof_mod, ONLY: tstart, tstop, tnull, tprnt 
>     IMPLICIT NONE 
>     PRIVATE 
>     PUBLIC lower_case, string_in_array, string_loc_in_array 
> 
>   ! List of character for case conversion
>   character(len=26), parameter :: LOWER_CASE_CHARS = 'abcdefghijklmnopqrstuvwxyz'
>   character(len=26), parameter :: UPPER_CASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
> 
> contains
>   ! --------------------------------------------------------------------------------------
>   pure function lower_case( input_string ) result( output_string )
>     character(len=*), intent(in) :: input_string
>     character(len=len(input_string)) :: output_string
>     integer :: i, n
> 
>     ! Copy input string
>     output_string = input_string
> 
>     ! Convert case character by character
>     do i = 1, len(output_string)
>       n = index(UPPER_CASE_CHARS, output_string(i:i))
>       if ( n /= 0 ) output_string(i:i) = LOWER_CASE_CHARS(n:n)
>     end do
>   end function
>   ! --------------------------------------------------------------------------------------
>   !
>   ! Is string somewhere in array? 
>   !
>   pure function string_in_array(string, array) 
>     character(len=*),               intent(in) :: string
>     character(len=*), dimension(:), intent(in) :: array
>     logical                                    :: string_in_array
>     
>     integer :: i
>     character(len=len_trim(string)) :: lc_string  
>     
>     string_in_array = .false. 
>     lc_string = lower_case(trim(string))
>     do i = 1, size(array) 
>       if(lc_string == lower_case(trim(array(i)))) then 
>         string_in_array = .true. 
>         exit 
>       end if 
>     end do 
>   end function string_in_array
>   ! --------------------------------------------------------------------------------------
>   !
>   ! Is string somewhere in array? 
>   !
>   pure function string_loc_in_array(string, array) 
>     character(len=*),               intent(in) :: string
>     character(len=*), dimension(:), intent(in) :: array
>     integer                                    :: string_loc_in_array
>     
>     integer :: i
>     character(len=len_trim(string)) :: lc_string  
>     
>     string_loc_in_array = -1
>     lc_string = lower_case(trim(string))
>     do i = 1, size(array) 
>       if(lc_string == lower_case(trim(array(i)))) then 
>         string_loc_in_array = i
>         exit 
>       end if 
>     end do 
>   end function string_loc_in_array
> end module
\ No newline at end of file
